all_tactics = {
"abstract",
"absurd",
"admit",
"apply",
"assert",
"assert_fails",
"assert_succeeds",
"assumption",
"auto",
"autoapply",
"autorewrite",
"autounfold",
"autounfold_one",
"btauto",
"by",
"case",
"case_eq",
"cbn",
"cbv",
"change",
"change_no_check",
"classical_left",
"classical_right",
"clear",
"clear dependent",
"clearbody",
"cofix",
"compare",
"compute",
"congr",
"congruence",
"constr_eq",
"constr_eq_nounivs",
"constr_eq_strict",
"constructor",
"context",
"contradict",
"contradiction",
"convert",
"cut",
"cutrewrite",
"cycle",
"debug",
"decide",
"decompose",
"dependent",
"destauto",
"destruct",
"dfs",
"dintuition",
"discriminate",
"discrR",
"do",
"done",
"dtauto",
"eapply",
"eassert",
"eassumption",
"easy",
"eauto",
"ecase",
"econstructor",
"edestruct",
"ediscriminate",
"eelim",
"eenough",
"eexact",
"eexists",
"einduction",
"einjection",
"eintros",
"eleft",
"elim",
"enough",
"epose",
"epose proof",
"eremember",
"erewrite",
"eright",
"eset",
"esimplify_eq",
"esplit",
"etransitivity",
"eval",
"evar",
"exact",
"exact_no_check",
"exactly_once",
"exfalso",
"exists",
"f_equal",
"fail",
"field",
"field_lookup",
"field_simplify",
"field_simplify_eq",
"finish_timing",
"first",
"first last",
"firstorder",
"fix",
"fold",
"fresh",
"fun",
"functional",
"generalize",
"generalize_eqs",
"generalize_eqs_vars",
"generally have",
"gfail",
"gintuition",
"give_up",
"guard",
"has_evar",
"have",
"head_of_constr",
"hnf",
"idtac",
"in",
"induction",
"info_auto",
"info_eauto",
"info_trivial",
"injection",
"instantiate",
"intro",
"intros",
"intros until",
"intuition",
"inversion",
"inversion_clear",
"inversion_sigma",
"is_cofix",
"is_const",
"is_constructor",
"is_evar",
"is_fix",
"is_ground",
"is_ind",
"is_proj",
"is_var",
"lapply",
"last",
"last first",
"lazy",
"lazy_match!",
"lazy_match! goal",
"lazymatch",
"lazymatch goal",
"left",
"let",
"lia",
"lra",
"ltac-seq",
"match",
"match!",
"move",
"multi_match!",
"multimatch",
"native_cast_no_check",
"native_compute",
"nia",
"not_evar",
"now",
"now_show",
"nra",
"nsatz",
"nsatz_compute",
"numgoals",
"once",
"only",
"optimize_heap",
"over",
"pattern",
"pose",
"progress",
"protect_fv",
"psatz",
"rapply",
"red",
"refine",
"reflexivity",
"remember",
"rename",
"repeat",
"replace",
"reset",
"restart_timer",
"revert",
"revgoals",
"rewrite",
"rewrite",
"rewrite_db",
"rewrite_strat",
"right",
"ring",
"ring_lookup",
"ring_simplify",
"rtauto",
"set",
"setoid_etransitivity",
"setoid_reflexivity",
"setoid_replace",
"setoid_rewrite",
"setoid_symmetry",
"setoid_transitivity",
"shelve",
"shelve_unifiable",
"show",
"simpl",
"simple",
"simplify_eq",
"soft",
"solve",
"solve_constraints",
"specialize",
"specialize_eqs",
"split",
"split_Rabs",
"split_Rmult",
"start",
"stepl",
"stepr",
"stop",
"subst",
"substitute",
"suff",
"suffices",
"swap",
"symmetry",
"tauto",
"time",
"time_constr",
"timeout",
"transitivity",
"transparent_abstract",
"trivial",
"try",
"tryif",
"type of",
"type_term",
"typeclasses",
"under",
"unfold",
"unify",
"unlock",
"unshelve",
"vm_cast_no_check",
"vm_compute",
"with_strategy",
"without",
"wlia",
"wlog",
"wlra_Q",
"wnia",
"wnra_Q",
"wpsatz_Q",
"wpsatz_Z",
"wsos_Q",
"wsos_Z",
"xlia",
"xlra_Q",
"xlra_R",
"xnia",
"xnra_Q",
"xnra_R",
"xpsatz_Q",
"xpsatz_R",
"xpsatz_Z",
"xsos_Q",
"xsos_R",
"xsos_Z",
"zify",
"zify_elim_let",
"zify_iter_let",
"zify_iter_specs",
"zify_op",
"zify_saturate",

"forall",
"exists",

"-",
'+',
"*",
":=",
"->",
}

keywords = {
    'Lemma',
    'Theorem',
    'Inductive',
    'Fixpoint',
    'CoInductive',
    'CoFixpoint',
    'Definition',
    'Axiom',
    'Hypothesis',
    'Variable',
    'Parameter',
    'Program',
    'Proof',
    'Proof with',
    'Qed',
    'Defined',
    'Admitted',
    'Abort',
    'Section',
    'End',
}