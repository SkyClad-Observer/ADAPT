{"9d8baa4024893f2cc2128e83244c68c721cd70ef": {"SK.v": [{"name": "minrec0_next", "text": "Lemma minrec0_next: forall f n, sk_red (f @ n) ff -> sk_red (minrec0 f @ n) (minrec0 f @ (succ1 @ n)).", "decomposition": ["ff_red"], "retrieval": ["Z_red"], "remove_type": "abort"}, {"name": "minrec0_found", "text": "Lemma minrec0_found: forall f n, sk_red (f @ n) tt -> sk_red (minrec0 f @ n) n.", "decomposition": [], "retrieval": ["Z_red"], "remove_type": "abort"}, {"name": "min_rec_abs_val", "text": "Lemma min_rec_abs_val : minrec_abs = Sop @ (Kop @ (Sop @ (Sop @ Ref \"f\" @ Iop))) @ (Sop @ (Sop @ (Kop @ Sop) @ Kop) @ (Kop @ (Sop @ (Sop @ (Kop @ Sop) @ Kop)))).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "primrec0_red_succ", "text": "Lemma primrec0_red_succ : forall k g h, sk_red (primrec0 g h @ (num (S k))) (h @ (num k) @ (primrec0 g h @ (num k))).", "decomposition": ["ff_red"], "retrieval": ["Z_red", "isZero_succ", "pred_red"], "remove_type": "abort"}, {"name": "primrec0_red_zero", "text": "Lemma primrec0_red_zero : forall g h, sk_red (primrec0 g h @ zero) g.", "decomposition": [], "retrieval": ["Z_red", "isZero_zero"], "remove_type": "abort"}, {"name": "primrec0_val", "text": "Lemma primrec0_val: primrec0_abs = Sop @ (Kop @ (Sop @ (Sop @ isZero @ (Kop @ Ref \"g\")))) @ (Sop @ (Kop @ (Sop @ (Sop @ (Kop @ Ref \"h\") @ predN))) @ (Sop @ (Sop @ (Kop @ Sop) @ Kop) @ (Kop @ predN))).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pred_red", "text": "Theorem pred_red: forall k, sk_red (predN @ (num k)) (num (pred k)).", "decomposition": [], "retrieval": ["star_occurs_true", "num_iterates", "star_occurs_false", "star_id", "pred_aux"], "remove_type": "abort"}, {"name": "pred_aux", "text": "Lemma pred_aux: forall k, sk_red (iter k (App PSucc) PZero) (pairL (num (Nat.pred k)) (num k)).", "decomposition": [], "retrieval": ["PSucc_red"], "remove_type": "abort"}, {"name": "num_iterates", "text": "Lemma num_iterates: forall m f x, sk_red (num m @ f @ x) (iter m (App f) x).", "decomposition": [], "retrieval": ["preserves_appr_sk_red"], "remove_type": "abort"}, {"name": "Kn_red", "text": "Lemma Kn_red: forall xs g, sk_red (fold_left App xs (Kn (List.length xs) @ g)) g.", "decomposition": [], "retrieval": ["fold_left_app_preserves_red", "transitive_red", "Kn_closed"], "remove_type": "abort"}, {"name": "ff_red", "text": "Lemma ff_red: forall x y, sk_red (ff @ x @ y) y.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "tt_red", "text": "Lemma tt_red: forall x y, sk_red (tt @ x @ y) x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "y_red", "text": "Lemma y_red: forall f, sk_red (Yop @ f) (f @ (Yop @ f)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "s_red_to_sk_red", "text": "Lemma s_red_to_sk_red: implies_red s_red sk_red.", "decomposition": [], "retrieval": ["to_sk_red_multi_step"], "remove_type": "abort"}, {"name": "sk_red1_to_s_red1", "text": "Lemma sk_red1_to_s_red1 : implies_red sk_red1 s_red1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "s_red_refl", "text": "Lemma s_red_refl: forall M, s_red1 M M.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "to_sk_red_multi_step", "text": "Lemma to_sk_red_multi_step: forall red, implies_red red sk_red -> implies_red (multi_step red) sk_red.", "decomposition": [], "retrieval": ["transitive_red"], "remove_type": "abort"}, {"name": "implies_red_multi_step", "text": "Lemma implies_red_multi_step: forall red1 red2, implies_red red1 (multi_step red2) -> implies_red (multi_step red1) (multi_step red2).", "decomposition": [], "retrieval": ["transitive_red"], "remove_type": "abort"}, {"name": "preserves_appr_multi_step", "text": "Lemma preserves_appr_multi_step : forall (red: SK -> SK -> Prop), preserves_appr red -> preserves_appr (multi_step red).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "preserves_appl_multi_step", "text": "Lemma preserves_appl_multi_step : forall (red: SK -> SK -> Prop), preserves_appl red -> preserves_appl (multi_step red).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "typed_triage.v": [{"name": "derive_equal", "text": "Theorem derive_equal: forall gamma, derive gamma equal (quant 2 (Funty (Var 0) (Funty (Var 1) Bool_ty))).", "decomposition": [], "retrieval": ["derive_star", "subtype_leaf_fork", "derive_generalisation_q", "derive_swap", "derive_generalisation", "subst_rec_lift_rec", "derive_false", "derive_K", "derive_K1", "derive_subtype", "derive_Z", "lift_rec_null", "subtype_lift", "derive_triage"], "remove_type": "abort"}, {"name": "derive_size", "text": "Theorem derive_size : forall gamma, derive gamma size (quant 1 (Funty (Var 0) Nat_ty)).", "decomposition": ["derive_prim_succ_plus"], "retrieval": ["derive_star", "derive_generalisation", "derive_query", "derive_I", "derive_K", "derive_succ1", "derive_Z"], "remove_type": "abort"}, {"name": "derive_prim_succ_plus", "text": "Lemma derive_prim_succ_plus: forall gamma, derive gamma prim_succ_plus (Funty (Quant (Funty (Funty (Var 0) (Var 0)) (Funty (Var 0) (Var 0)))) (Funty (Quant (Funty (Funty (Var 0) (Var 0)) (Funty (Var 0) (Var 0)))) Nat_ty)).", "decomposition": ["derive_prim_plus"], "retrieval": ["derive_star", "derive_succ1"], "remove_type": "abort"}, {"name": "derive_prim_plus", "text": "Lemma derive_prim_plus: forall gamma, derive gamma prim_plus (Funty (Quant (Funty (Funty (Var 0) (Var 0)) (Funty (Var 0) (Var 0)))) (Funty (Quant (Funty (Funty (Var 0) (Var 0)) (Funty (Var 0) (Var 0)))) Nat_ty)).", "decomposition": [], "retrieval": ["derive_star", "subtype_leaf_fork", "derive_primrec", "derive_generalisation", "derive_I", "derive_K", "derive_K1", "derive_subtype", "derive_S2", "derive_S1"], "remove_type": "abort"}, {"name": "derive_isFork", "text": "Theorem derive_isFork: forall gamma, derive gamma isFork (Quant (Funty (Var 0) Bool_ty)).", "decomposition": [], "retrieval": ["derive_generalisation", "derive_query", "derive_false", "derive_K", "derive_true"], "remove_type": "abort"}, {"name": "derive_isStem", "text": "Theorem derive_isStem: forall gamma, derive gamma isStem (Quant (Funty (Var 0) Bool_ty)).", "decomposition": [], "retrieval": ["derive_generalisation", "derive_query", "derive_false", "derive_K", "derive_true"], "remove_type": "abort"}, {"name": "derive_isLeaf", "text": "Theorem derive_isLeaf: forall gamma, derive gamma isLeaf (Quant (Funty (Var 0) Bool_ty)).", "decomposition": [], "retrieval": ["derive_generalisation", "derive_query", "derive_false", "derive_K", "derive_true"], "remove_type": "abort"}, {"name": "derive_update", "text": "Theorem derive_update : forall gamma f0 f1 f2, derive gamma f0 Leaf -> derive gamma f1 (Quant (Funty (Var 0) (Stem (Var 0)))) -> derive gamma f2 (Quant (Quant (Funty (Var 1) (Funty (Var 0) (Fork(Var 1) (Var 0)))))) -> derive gamma (triage f0 f1 f2) (Funty (Var 0) (Var 0)).", "decomposition": [], "retrieval": ["derive_triage"], "remove_type": "abort"}, {"name": "derive_query", "text": "Theorem derive_query : forall gamma f0 f1 f2 vty, derive gamma f0 (lift 1 vty) -> derive gamma f1 (Quant (Funty (Var 0) (lift 2 vty))) -> derive gamma f2 (Quant (Quant (Funty (Var 1) (Funty (Var 0) (lift 3 vty))))) -> derive gamma (triage f0 f1 f2) (Funty (Var 0) (lift 1 vty)).", "decomposition": [], "retrieval": ["subst_rec_lift_rec", "derive_triage", "lift_rec_preserves_variant2", "lift_rec_lift_rec"], "remove_type": "abort"}, {"name": "derive_triage", "text": "Theorem derive_triage : forall gamma ty f0 f1 f2, covariant ty -> derive gamma f0 (subst ty Leaf) -> derive gamma f1 (Quant (Funty (Var 0) (subst (lift_rec ty 1 1) (Stem (Var 0))))) -> derive gamma f2 (Quant (Quant (Funty (Var 1) (Funty (Var 0) (subst (lift_rec ty 1 2) (Fork (Var 1) (Var 0))))))) -> derive gamma (triage f0 f1 f2) (Funty (Var 0) (subst_rec ty (Var 0) 0)).", "decomposition": [], "retrieval": ["subtype_leaf_fork"], "remove_type": "abort"}], "classify.v": [{"name": "subtype_from_fork_of_fork_of_stem", "text": "Theorem subtype_from_fork_of_fork_of_stem: forall wty uty vty zty ty, subtype (Fork (Fork wty uty) vty) (Funty (Stem zty) ty) -> subtype uty (Funty zty ty).", "decomposition": [], "retrieval": ["quant_plus2", "trim_preserves_subtype", "trim_lift2", "chip_lift_variant", "quant0", "subtype_lift", "subtype_stemty_not_leafty", "subtype_from_asf", "subtype_stemty_not_forkty", "subtype_of_stemty", "subst_rec_subst_rec", "chip_lift_zero", "lift_rec_preserves_subtype", "subtype_from_fork_of_fork", "subtype_quant", "subst_rec_lift_rec", "subtype_from_quanta_funty", "lift_rec_null", "subtype_quantf_Quant", "trim_preserves_subst_rec"], "remove_type": "abort"}, {"name": "subtype_from_fork_of_fork", "text": "Theorem subtype_from_fork_of_fork: forall ty1 ty2, subtype ty1 ty2 -> forall bs1 n1 wty1 uty1 vty1, ty1 = quanta bs1 (Fork (quant n1 (Fork wty1 uty1)) vty1) -> not_funty ty2 \\/ (exists sigma p1 k n2 bs2 wty2 uty2 vty2, chip_count sigma (quant_count bs1) (p1 + (quant_count bs2)) /\\ subtype (quant p1 (trim sigma (quant n1 wty1))) (quant n2 wty2) /\\ subtype (quant p1 (trim sigma (quant n1 uty1))) (quantf k (quant n2 uty2)) /\\ subtype (quant p1 (trim sigma vty1)) (iter k bfff_aug vty2) /\\ (ty2 = quanta bs2 (Fork (quant n2 (Fork wty2 uty2)) vty2) (* fold quantf k into bs2 *) \\/ (exists zty, n2 = 0 /\\ ty2 = quanta bs2 (Funty zty wty2) /\\ subtype zty Leaf) \\/ (exists u2 u3 zty, n2 = 0 /\\ ty2 = quanta bs2 (Funty zty u3) /\\ uty2 = Funty u2 u3 /\\ subtype zty (Stem u2)) \\/ (exists v2 v3 v4 zty, n2 = 0 /\\ ty2 = quanta bs2 (Funty zty v4) /\\ vty2 = Funty v2 (Funty v3 v4) /\\subtype zty (Fork v2 v3)) \\/ (exists zty cty, n2 = 0 /\\ covariant cty /\\ wty2 = subst cty Leaf /\\ uty2 = quant 1 (Funty (Var 0) (subst (lift_rec cty 1 1) (Stem (Var 0)))) /\\ vty2 = quant 2 (Funty (Var 1) (Funty (Var 0) (subst (lift_rec cty 1 2) (Fork (Var 1) (Var 0))))) /\\ subtype (quanta bs2 (Funty zty (subst cty zty))) ty2))).", "decomposition": ["iter_plus"], "retrieval": ["quant_count_quant_to_quanta", "lift_rec_preserves_quanta", "quanta_to_quant", "trim_preserves_iter_bfff_aug", "quant_plus2", "trim_leaf", "trim_preserves_subtype", "quanta_app", "chip_count_succ", "subtype_quant_fork", "subtype_not_funty", "chip_count_app2", "subst_rec_preserves_quant", "subtype_preserves_iter_bfff_aug", "subtype_quanta", "subtype_quant_iter_bfff_aug", "quant_succ2", "subst_rec_quant", "quant_succ", "quant_count_app", "subtype_quant_stem", "lift_rec_preserves_quant", "subst_rec_preserves_quanta", "quanta_is_quant", "subtype_quant", "trim_stem", "trim_funty", "subtype_quant_to_quanta", "trim_fork", "subtype_from_quanta_funty", "quanta_is_asf", "subtype_lift2"], "remove_type": "abort"}, {"name": "subtype_from_fork_of_stem_to_funty", "text": "Theorem subtype_from_fork_of_stem_to_funty: forall uty vty zty ty, subtype (Fork (Stem uty) vty) (Funty zty ty) -> exists v2, subtype uty (Funty zty (Funty v2 ty)) /\\ subtype vty (Funty zty v2).", "decomposition": ["iter_bffs_aug"], "retrieval": ["subtype_from_asf", "subtype_from_fork_of_stem", "quant0"], "remove_type": "abort"}, {"name": "iter_bffs_aug", "text": "Lemma iter_bffs_aug: forall n uty vty wty, subtype (iter n bffs_aug (Funty uty (Funty vty wty))) (Funty uty (Funty vty wty)).", "decomposition": [], "retrieval": ["subtype_preserves_bffs_aug", "bffs_aug_of_binary_fun"], "remove_type": "abort"}, {"name": "subtype_from_fork_of_stem2", "text": "Theorem subtype_from_fork_of_stem2: forall ty1 ty2, subtype ty1 ty2 -> forall bs1 n1 uty1 vty1, ty1 = quanta bs1 (Fork (quant n1 (Stem uty1)) vty1) -> not_funty ty2 \\/ (exists sigma p1 k n2 bs2 uty2 vty2, chip_count sigma (quant_count bs1) (p1 + (quant_count bs2)) /\\ subtype (quant p1 (trim sigma (quant n1 uty1))) (iter k bffs_aug (quant n2 uty2)) /\\ subtype (quant p1 (trim sigma vty1)) (quantf k vty2) /\\ (ty2 = quanta bs2 (Fork (quant n2 (Stem uty2)) vty2) (* fold quantf k into bs2 *) \\/ exists u2 v2 w2, n2 = 0 /\\ uty2 = Funty u2 (Funty v2 w2) /\\ vty2 = Funty u2 v2 /\\ ty2 = quanta bs2 (Funty u2 w2) )).", "decomposition": ["iter_plus"], "retrieval": ["quantf_plus", "subtype_to_asf", "subtype_quant_quantf", "lift_rec_preserves_quanta", "trim_preserves_subtype", "quanta_app", "chip_count_succ", "subtype_quantf", "subtype_not_funty", "chip_count_app2", "subtype_preserves_iter_bffs_aug", "subtype_from_asf", "subtype_quant_iter_bffs_aug", "subst_rec_preserves_quant", "quant_succ2", "quant_succ", "quant_count_app", "lift_rec_preserves_quant", "subst_rec_preserves_quanta", "quanta_is_quant", "subtype_quant", "trim_funty", "subtype_from_quanta_funty", "quanta_is_asf", "trim_preserves_iter_bffs_aug", "trim_quantf"], "remove_type": "abort"}, {"name": "subtype_from_fork_of_stem", "text": "Theorem subtype_from_fork_of_stem: forall ty1 ty2, subtype ty1 ty2 -> forall bs1 n1 uty1 vty1, ty1 = quanta bs1 (Fork (quant n1 (Stem uty1)) vty1) -> not_funty ty2 \\/ (exists sigma p1 k n2 bs2 uty2 vty2, chip_count sigma (quant_count bs1) (p1 + (quant_count bs2)) /\\ subtype (quant p1 (trim sigma (quant n1 uty1))) (iter k bffs_aug (quant n2 uty2)) /\\ subtype (quant p1 (trim sigma vty1)) (quantf k vty2) /\\ (ty2 = quanta bs2 (Fork (quant n2 (Stem uty2)) vty2) (* fold quantf k into bs2 *) \\/ exists u2 v2 w2, n2 = 0 /\\ uty2 = Funty u2 (Funty v2 w2) /\\ vty2 = Funty u2 v2 /\\ ty2 = quanta bs2 (Funty u2 w2) )).", "decomposition": ["iter_plus"], "retrieval": ["subtype_quant_quantf", "lift_rec_preserves_quanta", "quanta_app", "chip_count_succ", "subtype_quantf", "subtype_not_funty", "chip_count_app2", "subtype_preserves_iter_bffs_aug", "subtype_quant_iter_bffs_aug", "subst_rec_preserves_quant", "quant_succ2", "quant_count_app", "quant_succ", "lift_rec_preserves_quant", "subst_rec_preserves_quanta", "trim_funty", "quanta_is_quant", "subtype_from_quanta_funty", "quanta_is_asf", "trim_preserves_iter_bffs_aug", "trim_quantf"], "remove_type": "abort"}, {"name": "iter_plus", "text": "Lemma iter_plus: forall m n f x, iter (m+n) f (x: dtype) = iter m f (iter n f x).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "<unknown>", "text": "Proposition subtype_omega22_ty : forall k uty vty, subtype omega22_ty (Funty omega2_ty (Funty (Funty (quant k (Funty uty vty)) (quant k (Funty uty vty))) (quant k (Funty uty vty)))).", "decomposition": [], "retrieval": ["subtype_leaf_fork", "lift_rec_preserves_quant", "subtype_quant", "lift_rec_funty", "subtype_lift4", "subtype_lift", "subtype_Kty"], "remove_type": "abort"}, {"name": "subtype_from_fork_of_leaf_to_fun", "text": "Theorem subtype_from_fork_of_leaf_to_fun: forall vty zty ty, subtype (Fork Leaf vty) (Funty zty ty) -> subtype vty ty.", "decomposition": [], "retrieval": ["subtype_from_fork_of_leaf", "subtype_of_funty", "subtype_lift"], "remove_type": "abort"}, {"name": "subtype_from_fork_of_leaf", "text": "Theorem subtype_from_fork_of_leaf: forall bs uty vty ty2, subtype (quanta bs (Fork uty vty)) ty2 -> isLeafty uty -> (exists p bs2 uty2 vty2 sigma, ty2 = quanta bs2 (Fork uty2 vty2) /\\ chip_count sigma (quant_count bs) (p + (quant_count bs2)) /\\ subtype (quant p (trim sigma uty)) uty2 /\\ subtype (quant p (trim sigma vty)) vty2) \\/ subtype (Quant (Funty (Var 0) (lift 1 (quant (quant_count bs) vty)))) ty2.", "decomposition": [], "retrieval": ["quanta_not_fork", "lift_rec_preserves_quanta", "quant_plus2", "lift_lift_rec", "quanta_app", "chip_count_succ", "quanta_not_funty", "subtype_from_leafty", "isLeafty_quant", "chip_count_app2", "subtype_lift3", "trim_preserves_isLeafty", "subtype_from_fork_of_funty", "quant_count_app", "lift_rec_preserves_subtype", "subst_rec_preserves_quanta", "quanta_is_quant", "subtype_quant", "quanta_is_asf"], "remove_type": "abort"}, {"name": "subtype_from_fork_of_funty", "text": "Theorem subtype_from_fork_of_funty: forall bs uty vty ty2, subtype (quanta bs (Fork uty vty)) ty2 -> isFunty uty -> exists p bs2 uty2 vty2 sigma, ty2 = quanta bs2 (Fork uty2 vty2) /\\ chip_count sigma (quant_count bs) (p + (quant_count bs2)) /\\ subtype (quant p (trim sigma uty)) uty2 /\\ subtype (quant p (trim sigma vty)) vty2.", "decomposition": [], "retrieval": ["quant_count_app", "chip_count_succ", "subst_rec_preserves_quanta", "quanta_app", "quanta_is_quant", "lift_rec_preserves_quanta", "quanta_is_asf", "subtype_from_funty", "isFunty_quant", "trim_preserves_isFunty", "chip_count_app2"], "remove_type": "abort"}, {"name": "subtype_of_funty", "text": "Theorem subtype_of_funty: forall n u v u2 v2, subtype (quant n (Funty u v)) (Funty u2 v2) -> exists sigma n2, chip_count sigma n n2 /\\ subtype (quant n2 (trim sigma v)) v2 /\\ subtype u2 (quant n2 (trim sigma u)).", "decomposition": [], "retrieval": ["quant_count_quant_to_quanta", "quanta_to_quant", "subtype_from_quanta_funty"], "remove_type": "abort"}, {"name": "subtype_from_quanta_funty", "text": "Theorem subtype_from_quanta_funty: forall ty1 ty2, subtype ty1 ty2 -> forall bs u v, ty1 = quanta bs (Funty u v) -> exists p bs2 u2 v2 sigma, ty2 = quanta bs2 (Funty u2 v2) /\\ chip_count sigma (quant_count bs) (p + (quant_count bs2)) /\\ subtype (quant p (trim sigma v)) v2 /\\ subtype u2 (quant p (trim sigma u)).", "decomposition": [], "retrieval": ["quant_count_app", "chip_count_succ", "subst_rec_preserves_quanta", "quanta_app", "trim_app", "subtype_quant", "quanta_is_quant", "lift_rec_preserves_quanta", "trim_quant", "quanta_is_asf", "quant_plus2", "trim_preserves_subtype", "quanta_cases", "chip_count_app2"], "remove_type": "abort"}, {"name": "trim_preserves_isFunty", "text": "Lemma trim_preserves_isFunty: forall sigma ty, isFunty ty -> isFunty (trim sigma ty).", "decomposition": [], "retrieval": ["subst_rec_preserves_funty", "lift_rec_preserves_funty"], "remove_type": "abort"}, {"name": "trim_preserves_subst_rec", "text": "Lemma trim_preserves_subst_rec: forall ty uty k sigma, trim (map (chip_lift k) sigma) (subst_rec ty uty k) = subst_rec (trim (map (chip_lift (S k)) sigma) ty) (trim sigma uty) k.", "decomposition": [], "retrieval": ["subst_rec_lift_rec", "trim_lift_miss", "chip_lift_plus", "lift_preserves_trim"], "remove_type": "abort"}, {"name": "trim_preserves_bfff_aug", "text": "Lemma trim_preserves_bfff_aug: forall sigma ty, trim sigma (bfff_aug ty) = bfff_aug (trim sigma ty).", "decomposition": [], "retrieval": ["trim_lift_miss"], "remove_type": "abort"}, {"name": "trim_leaf", "text": "Lemma trim_leaf : forall sigma, trim sigma Leaf = Leaf.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "trim_funty", "text": "Lemma trim_funty : forall sigma uty vty, trim sigma (Funty uty vty) = Funty (trim sigma uty) (trim sigma vty).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "trim_quant", "text": "Lemma trim_quant : forall p sigma ty, trim sigma (quant p ty) = quant p (trim (map (chip_lift p) sigma) ty).", "decomposition": [], "retrieval": ["chip_lift_zero", "chip_lift_plus", "trim_Quant"], "remove_type": "admit"}, {"name": "chip_lift_trim", "text": "Lemma chip_lift_trim: forall sigma k ty, lift k (trim sigma ty) = trim (map (chip_lift k) sigma) (lift k ty).", "decomposition": [], "retrieval": ["subst_rec_lift_rec1", "lift_lift_rec"], "remove_type": "abort"}, {"name": "trim_lift_miss", "text": "Lemma trim_lift_miss: forall sigma k n, k > n -> trim (map (chip_lift k) sigma) (Var n) = Var n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subtype_of_forkty", "text": "Lemma subtype_of_forkty: forall uty vty uty2 vty2, subtype (Fork uty vty) (Fork uty2 vty2) -> subtype uty uty2 /\\ subtype vty vty2.", "decomposition": [], "retrieval": ["subtype_from_forkty", "subtype_to_forkty"], "remove_type": "abort"}, {"name": "subtype_to_forkty", "text": "Lemma subtype_to_forkty: forall ty1 ty2, subtype ty1 ty2 -> forall n2 uty2 vty2, ty2 = quant n2 (Fork uty2 vty2) -> (subtype ty1 (Quant (Var 0)) \\/ exists n1 uty1 vty1, ty1 = quant n1 (Fork uty1 vty1) /\\ subtype (quant n1 uty1) (quant n2 uty2) /\\ subtype (quant n1 vty1) (quant n2 vty2)).", "decomposition": ["subtype_of_empty_type"], "retrieval": ["subst_rec_to_fork", "quant_succ", "lift_rec_preserves_quant", "subst_rec_lift_rec", "lift_rec_null", "lift_rec_lift_rec", "subst_rec_preserves_quant", "quant_succ2"], "remove_type": "abort"}, {"name": "subst_rec_to_fork", "text": "Lemma subst_rec_to_fork: forall ty uty k n rty sty, subst_rec ty uty k = quant n (Fork rty sty) -> ((exists m rty0 sty0, ty = quant m (Fork rty0 sty0)) \\/ exists m, ty = quant m (Var (m+k))).", "decomposition": [], "retrieval": ["quant_succ"], "remove_type": "abort"}, {"name": "subtype_of_stemty", "text": "Lemma subtype_of_stemty: forall uty vty, subtype (Stem uty) (Stem vty) -> subtype uty vty.", "decomposition": [], "retrieval": ["subtype_from_stemty", "subtype_to_stemty"], "remove_type": "abort"}, {"name": "subtype_to_stemty", "text": "Lemma subtype_to_stemty: forall ty1 ty2, subtype ty1 ty2 -> forall n2 uty2, ty2 = quant n2 (Stem uty2) -> (subtype ty1 (Quant (Var 0)) \\/ exists n1 uty1, ty1 = quant n1 (Stem uty1) /\\ subtype (quant n1 uty1) (quant n2 uty2)).", "decomposition": ["subtype_of_empty_type"], "retrieval": ["quant_succ", "lift_rec_preserves_quant", "subst_rec_to_stem", "subtype_quant", "subst_rec_lift_rec", "lift_rec_null", "lift_rec_lift_rec", "subst_rec_preserves_quant", "quant_succ2"], "remove_type": "abort"}, {"name": "subtype_of_empty_type", "text": "Lemma subtype_of_empty_type: forall n ty, subtype (Quant (quant n (Var n))) ty.", "decomposition": [], "retrieval": ["subtype_quant"], "remove_type": "abort"}, {"name": "subst_rec_to_stem", "text": "Lemma subst_rec_to_stem: forall ty uty k n rty, subst_rec ty uty k = quant n (Stem rty) -> ((exists m ty0, ty = quant m (Stem ty0)) \\/ exists m, ty = quant m (Var (m+k))).", "decomposition": [], "retrieval": ["quant_succ"], "remove_type": "abort"}, {"name": "subtype_not_funty", "text": "Lemma subtype_not_funty: forall ty1 ty2, subtype ty1 ty2 -> not_funty ty1 -> not_funty ty2.", "decomposition": [], "retrieval": ["lift_rec_preserves_not_funty", "subst_rec_preserves_not_funty", "subtype_from_funty"], "remove_type": "abort"}, {"name": "subtype_from_forkty", "text": "Lemma subtype_from_forkty: forall ty1 ty2, subtype ty1 ty2 -> isForkty ty1 -> isForkty ty2 \\/ isFunty ty2.", "decomposition": [], "retrieval": ["lift_rec_preserves_forkty", "subtype_from_funty", "subst_rec_preserves_forkty"], "remove_type": "abort"}, {"name": "subtype_from_stemty", "text": "Lemma subtype_from_stemty: forall ty1 ty2, subtype ty1 ty2 -> isStemty ty1 -> isStemty ty2 \\/ isFunty ty2.", "decomposition": [], "retrieval": ["subst_rec_preserves_stemty", "lift_rec_preserves_stemty", "subtype_from_funty"], "remove_type": "abort"}, {"name": "subtype_from_leafty", "text": "Lemma subtype_from_leafty: forall ty1 ty2, subtype ty1 ty2 -> isLeafty ty1 -> (isLeafty ty2 \\/ isFunty ty2).", "decomposition": [], "retrieval": ["subst_rec_preserves_leafty", "subtype_from_funty", "lift_rec_preserves_leafty"], "remove_type": "abort"}], "rewriting_theorems.v": [{"name": "branch_first_eval_iff_bf", "text": "Theorem branch_first_eval_iff_bf: forall M N P, program M -> program N -> program P -> (branch_first_eval M N P <-> t_red (bf @ M @ N) P).", "decomposition": [], "retrieval": ["t_red_to_s_red", "programs_are_stable2", "bf_to_branch_first_eval"], "remove_type": "abort"}, {"name": "bf_to_branch_first_eval", "text": "Theorem bf_to_branch_first_eval: forall M N P, t_red (bf @ M @ N) P -> program M -> program N -> factorable P -> exists Q, branch_first_eval M N Q /\\ t_red P Q .", "decomposition": [], "retrieval": ["bf_needy", "multi_ranked_iff_multi_red", "program_application2_t_red1", "t_red_to_s_red", "hap1_functional", "programs_are_stable2", "diamond_t_red", "s_red_to_t_red", "eager_needy", "program_application2_s_red1", "diamond_multi_ranked", "diamond_s_red1_s_red", "diamond_s_red", "needy_s_red_factorable", "transitive_red", "t_red_preserves_factorable"], "remove_type": "abort"}, {"name": "needy_s_red_factorable", "text": "Lemma needy_s_red_factorable: forall n R M Q, multi_ranked s_red1 n R Q -> factorable Q -> needs R M -> exists M1, multi_ranked s_red1 n M M1 /\\ factorable M1.", "decomposition": [], "retrieval": ["active_s_red_factorable", "s_red_to_t_red", "diamond_multi_ranked", "diamond_s_red1_s_red", "t_red_preserves_factorable"], "remove_type": "abort"}, {"name": "needy_app", "text": "Lemma needy_app: forall R M, needs R M -> forall N, needs (R@ N) M.", "decomposition": [], "retrieval": ["preserves_app_s_red", "active_app"], "remove_type": "abort"}, {"name": "active_s_red_factorable", "text": "Lemma active_s_red_factorable: forall n R M Q, multi_ranked s_red1 n R Q -> active R M -> factorable Q -> exists M1 , multi_ranked s_red1 n M M1 /\\ factorable M1 .", "decomposition": [], "retrieval": ["active_s_red1", "multi_ranked_of_reflexive", "active_not_factorable", "s_red_refl"], "remove_type": "abort"}, {"name": "active_s_red1", "text": "Lemma active_s_red1: forall R M, active R M -> forall R1, s_red1 R R1 -> factorable M \\/ exists M1, s_red1 M M1 /\\ active R1 M1.", "decomposition": [], "retrieval": ["active_app", "active_not_factorable", "next_s_red1"], "remove_type": "abort"}, {"name": "next_s_red1", "text": "Lemma next_s_red1: forall R M, next R M -> forall R1, s_red1 R R1 -> factorable M \\/ exists M1, s_red1 M M1 /\\ next R1 M1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "s_red_preserves_head_ref", "text": "Lemma s_red_preserves_head_ref: forall M N s, s_red M N -> head_term M = Ref s -> head_term N = Ref s.", "decomposition": [], "retrieval": ["multi_ranked_iff_multi_red"], "remove_type": "abort"}, {"name": "active_combination", "text": "Lemma active_combination: forall R M, active R M -> combination R -> combination M.", "decomposition": [], "retrieval": ["next_combination"], "remove_type": "abort"}, {"name": "multi_ranked_of_reflexive", "text": "Lemma multi_ranked_of_reflexive: forall red, reflexive red -> forall n m, m <= n -> forall M N, multi_ranked red m M N -> multi_ranked red n M N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "substitution_preserves_s_red", "text": "Lemma substitution_preserves_s_red: forall M N, s_red M N -> forall x U, s_red (substitute M x U) (substitute N x U).", "decomposition": [], "retrieval": ["multi_ranked_iff_multi_red", "substitution_preserves_s_red1"], "remove_type": "abort"}, {"name": "factorable_decidable", "text": "Lemma factorable_decidable: forall M, factorable M \\/ ~ factorable M.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "program_application2_multi", "text": "Lemma program_application2_multi : forall n M N, multi_ranked s_red1 (S n) M N -> forall M1 M2 M3, M = M1 @ M2 @ M3 -> program M1 -> program M2 ->program M3 -> M= N \\/ exists Q, hap1 M Q /\\ multi_ranked s_red1 n Q N.", "decomposition": [], "retrieval": ["program_application2_s_red1"], "remove_type": "abort"}, {"name": "program_application_multi", "text": "Lemma program_application_multi : forall n M N, multi_ranked s_red1 (S n) M N -> forall M1 M2, M = M1 @ M2 -> program M1 -> program M2 -> M= N \\/ exists Q, hap1 M Q /\\ multi_ranked s_red1 n Q N.", "decomposition": [], "retrieval": ["program_application_s_red1"], "remove_type": "abort"}, {"name": "program_application3_s_red1", "text": "Lemma program_application3_s_red1 : forall M N, s_red1 M N -> forall M1 M2 M3 M4, M = M1 @ M2 @ M3 @ M4 -> program M1 -> program M2 -> program M3 -> program M4 -> M= N \\/ hap1 M N.", "decomposition": [], "retrieval": ["program_application2_s_red1"], "remove_type": "abort"}, {"name": "program_application2_s_red1", "text": "Lemma program_application2_s_red1 : forall M N, s_red1 M N -> forall M1 M2 M3, M = M1 @ M2 @ M3 -> program M1 -> program M2 -> program M3 -> M= N \\/ hap1 M N.", "decomposition": [], "retrieval": ["program_application_s_red1"], "remove_type": "abort"}, {"name": "head_reduction_to_factorable_form", "text": "Theorem head_reduction_to_factorable_form: forall M N, t_red M N -> factorable N -> exists Q, hap M Q /\\ factorable Q /\\ t_red Q N.", "decomposition": [], "retrieval": ["t_red_implies_t_red_rev", "hap_preserves_appr", "st_red_implies_seq_red", "seq_red_to_t_red", "transitive_red", "t_red_rev_st_red"], "remove_type": "abort"}, {"name": "leftmost_reduction", "text": "Corollary leftmost_reduction: forall M N, t_red M N -> program N -> l_red M N.", "decomposition": [], "retrieval": ["standardization", "program_no_redexes"], "remove_type": "abort"}, {"name": "t_red_rev_st_red", "text": "Lemma t_red_rev_st_red : forall M N, t_red_rev M N -> st_red M N.", "decomposition": [], "retrieval": ["st_red_then_t_nred1", "st_red_refl"], "remove_type": "abort"}, {"name": "t_red_implies_t_red_rev", "text": "Lemma t_red_implies_t_red_rev: forall M N, t_red M N -> t_red_rev M N.", "decomposition": [], "retrieval": ["transitive_t_red_rev", "t_red1_implies_t_nred1"], "remove_type": "abort"}, {"name": "t_red1_implies_t_nred1", "text": "Lemma t_red1_implies_t_nred1: forall M N, t_red1 M N -> exists n, t_nred1 n M N.", "decomposition": [], "retrieval": ["ready_or_not"], "remove_type": "abort"}, {"name": "transitive_t_red_rev", "text": "Lemma transitive_t_red_rev : forall N P, t_red_rev N P -> forall M, t_red_rev M N -> t_red_rev M P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "hap_then_seq_red", "text": "Lemma hap_then_seq_red: forall M N, hap M N -> forall n P, seq_red n N P -> seq_red n M P.", "decomposition": [], "retrieval": ["hap1_implies_t_nred1"], "remove_type": "abort"}, {"name": "hap_implies_l_red", "text": "Lemma hap_implies_l_red: forall M N, hap M N -> l_red M N.", "decomposition": [], "retrieval": ["hap1_implies_t_nred1"], "remove_type": "abort"}, {"name": "hap1_implies_t_nred1", "text": "Lemma hap1_implies_t_nred1: forall M N, hap1 M N -> t_nred1 0 M N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "st_fork_fork_red", "text": "Lemma st_fork_fork_red : forall M N R P Q1 Q2, st_red M (App (App (\u25b3 @ (\u25b3 @ N @ R)) P) (Node @ Q1 @ Q2)) -> st_red M (P @ Q1 @ Q2).", "decomposition": [], "retrieval": ["hap_preserves_appr", "hap_then_st_red"], "remove_type": "abort"}, {"name": "st_fork_stem_red", "text": "Lemma st_fork_stem_red : forall M N R P Q, st_red M (App (App (\u25b3 @ (\u25b3 @ N @ R)) P) (Node @ Q)) -> st_red M (R @ Q).", "decomposition": [], "retrieval": ["hap_preserves_appr", "hap_then_st_red"], "remove_type": "abort"}, {"name": "st_fork_leaf_red", "text": "Lemma st_fork_leaf_red : forall M N R P, st_red M (App (App (\u25b3 @ (\u25b3 @ N @ R)) P) Node) -> st_red M N.", "decomposition": [], "retrieval": ["hap_then_st_red"], "remove_type": "abort"}, {"name": "st_stem_red", "text": "Lemma st_stem_red : forall M N P Q, st_red M (\u25b3 @ (\u25b3 @ N) @ P @ Q) -> st_red M (N@Q @(P@Q)).", "decomposition": [], "retrieval": ["hap_then_st_red"], "remove_type": "abort"}, {"name": "st_kernel_red", "text": "Lemma st_kernel_red : forall M N P, st_red M (\u25b3 @ \u25b3 @ N @ P) -> st_red M N.", "decomposition": [], "retrieval": ["hap_then_st_red"], "remove_type": "abort"}, {"name": "seq_red_app", "text": "Lemma seq_red_app: forall M M1, seq_red (redexes M1) M M1 -> forall N N1, seq_red (redexes N1) N N1 -> seq_red (redexes (M1 @ N1)) (M@N) (M1 @ N1).", "decomposition": [], "retrieval": ["t_red_preserves_ready", "redexes_ready", "seq_red_redexes", "ready_or_not", "seq_red_to_t_red", "redexes_unready"], "remove_type": "abort"}, {"name": "seq_red_preserves_factorable", "text": "Lemma seq_red_preserves_factorable: forall n M N, seq_red n M N -> factorable M -> factorable N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "l_red_transitive", "text": "Lemma l_red_transitive: forall M N, l_red M N -> forall P, l_red N P -> l_red M P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "seq_red_to_t_red", "text": "Lemma seq_red_to_t_red : forall n M N, seq_red n M N -> t_red M N.", "decomposition": [], "retrieval": ["t_nred1_to_t_red1"], "remove_type": "abort"}, {"name": "redexes_unready", "text": "Lemma redexes_unready: forall M N, ~ ready (M @ N) -> redexes (M @ N) = redexes M + redexes N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "t_red_preserves_ready", "text": "Lemma t_red_preserves_ready: forall M N, ready (M @ N) -> forall M' N', t_red M M' -> t_red N N' -> ready (M' @ N').", "decomposition": [], "retrieval": ["t_red_preserves_fork", "t_red_preserves_stem"], "remove_type": "abort"}, {"name": "t_red_preserves_fork", "text": "Lemma t_red_preserves_fork: forall M N red, multi_step red M N -> red = t_red1 -> forall M1 M2, M = Node @ M1 @ M2 -> exists N1 N2, N = Node @ N1 @ N2 /\\ t_red M1 N1 /\\ t_red M2 N2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "t_red_preserves_stem", "text": "Lemma t_red_preserves_stem: forall M N red, multi_step red M N -> red = t_red1 -> forall M1, M = Node @ M1 -> exists N1, N = Node @ N1 /\\ t_red M1 N1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "t_red_preserves_leaf", "text": "Lemma t_red_preserves_leaf: forall M N red, multi_step red M N -> red = t_red1 -> M = Node -> N = Node.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ready_or_not", "text": "Lemma ready_or_not: forall M, ready M \\/ ~(ready M).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "no_redexes_program", "text": "Lemma no_redexes_program: forall N, redexes N = 0 -> combination N -> program N.", "decomposition": [], "retrieval": ["quaternary_redexes"], "remove_type": "abort"}, {"name": "quaternary_redexes", "text": "Lemma quaternary_redexes: forall M, combination M -> forall N P Q R, M = N @ P @ Q @ R -> redexes M >0.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "irreducible_no_redexes", "text": "Lemma irreducible_no_redexes: forall N, irreducible N -> redexes N = 0.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "halting_problem_insoluble", "text": "Theorem halting_problem_insoluble : forall h, ~(halting h).", "decomposition": [], "retrieval": ["omega_omega_has_no_value", "programs_are_stable2", "t_red_to_s_red", "diamond_t_red"], "remove_type": "abort"}, {"name": "omega_omega_has_no_value", "text": "Lemma omega_omega_has_no_value: ~(valuable (omega @ omega)).", "decomposition": [], "retrieval": ["multi_ranked_iff_multi_red", "t_red_to_s_red", "omega_omega_doesn't_halt"], "remove_type": "abort"}, {"name": "omega_omega_doesn't_halt", "text": "Lemma omega_omega_doesn't_halt: forall n h M, h < n -> multi_ranked s_red1 h (omega@ omega) M -> factorable M -> False.", "decomposition": [], "retrieval": ["t_red_to_s_red", "s_red_to_t_red", "diamond_strip", "diamond_multi_ranked", "t_red_preserves_factorable"], "remove_type": "abort"}, {"name": "diamond_multi_ranked", "text": "Lemma diamond_multi_ranked: forall red1 red2, diamond red1 red2 -> forall n, diamond (multi_ranked red1 n) red2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "multi_ranked_iff_multi_red", "text": "Lemma multi_ranked_iff_multi_red : forall (red : Tree -> Tree -> Prop) M N, multi_step red M N <-> exists n, multi_ranked red n M N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "t_red_preserves_factorable", "text": "Lemma t_red_preserves_factorable: forall M N, t_red M N -> factorable M -> factorable N.", "decomposition": [], "retrieval": ["t_red_preserves_forks", "t_red_preserves_stems", "programs_are_stable2", "t_red_to_s_red"], "remove_type": "abort"}, {"name": "t_red_preserves_forks", "text": "Lemma t_red_preserves_forks: forall M N, t_red M N -> forall M0 M1, M = \u25b3 @ M0 @ M1 -> exists N0 N1, N = \u25b3 @ N0 @ N1 /\\ t_red M0 N0 /\\ t_red M1 N1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "t_red_preserves_stems", "text": "Lemma t_red_preserves_stems: forall M N, t_red M N -> forall M0, M = \u25b3 @ M0 -> exists N0, N = \u25b3 @ N0 /\\ t_red M0 N0.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "programs_are_stable2", "text": "Lemma programs_are_stable2: forall M N, s_red M N -> program M -> N = M.", "decomposition": [], "retrieval": ["programs_are_stable"], "remove_type": "admit"}, {"name": "diamond_t_red", "text": "Lemma diamond_t_red: diamond t_red t_red.", "decomposition": [], "retrieval": ["diamond_s_red", "t_red_to_s_red", "s_red_to_t_red"], "remove_type": "abort"}, {"name": "s_red_to_t_red", "text": "Lemma s_red_to_t_red: implies_red s_red t_red.", "decomposition": [], "retrieval": ["s_red1_to_t_red", "to_t_red_multi_step"], "remove_type": "abort"}, {"name": "s_red1_to_t_red", "text": "Lemma s_red1_to_t_red: implies_red s_red1 t_red .", "decomposition": [], "retrieval": ["transitive_red"], "remove_type": "abort"}, {"name": "diamond_s_red1_s_red1", "text": "Theorem diamond_s_red1_s_red1 : diamond s_red1 s_red1.", "decomposition": [], "retrieval": ["s_red_refl"], "remove_type": "admit"}, {"name": "diamond_star_strip", "text": "Lemma diamond_star_strip: forall red1 red2, diamond_star red1 red2 -> diamond (multi_step red2) red1 .", "decomposition": [], "retrieval": ["transitive_red"], "remove_type": "abort"}, {"name": "diamond_strip", "text": "Lemma diamond_strip : forall red1 red2, diamond red1 red2 -> diamond red1 (multi_step red2).", "decomposition": [], "retrieval": ["diamond_flip"], "remove_type": "abort"}, {"name": "diamond_flip", "text": "Lemma diamond_flip: forall red1 red2, diamond red1 red2 -> diamond red2 red1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "implies_red_multi_step", "text": "Lemma implies_red_multi_step: forall red1 red2, implies_red red1 (multi_step red2) -> implies_red (multi_step red1) (multi_step red2).", "decomposition": [], "retrieval": ["transitive_red"], "remove_type": "abort"}, {"name": "preserves_app_s_red", "text": "Lemma preserves_app_s_red : preserves_app s_red.", "decomposition": [], "retrieval": ["preserves_app_multi_step"], "remove_type": "abort"}, {"name": "preserves_appr_s_red", "text": "Lemma preserves_appr_s_red : preserves_appr s_red.", "decomposition": [], "retrieval": ["preserves_appr_multi_step"], "remove_type": "abort"}, {"name": "preserves_appl_s_red", "text": "Lemma preserves_appl_s_red : preserves_appl s_red.", "decomposition": [], "retrieval": ["preserves_appl_multi_step"], "remove_type": "abort"}], "typed_evaluator.v": [{"name": "derive_bf", "text": "Theorem derive_bf : derive nil bf eval_ty.", "decomposition": [], "retrieval": ["derive_star", "derive_eager", "subtype_leaf_fork", "derive_generalisation_q", "derive_generalisation", "derive_subtype", "derive_Z"], "remove_type": "abort"}, {"name": "<unknown>", "text": "Proposition subtype_bf: subtype (Fork (Fork Leaf Leaf) (quant 2 (Funty (Var 1) (Funty (Var 0) (Asf (Fork (Var 1) (Var 0))))))) eval_ty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "derive_eager", "text": "Theorem derive_eager: (* note the use of double-negative covariance ! *) forall gamma, derive gamma eager eager_ty.", "decomposition": [], "retrieval": ["derive_star", "derive_subtype", "derive_generalisation_q"], "remove_type": "abort"}], "typed_recursion.v": [{"name": "derive_minrec", "text": "Theorem derive_minrec: forall gamma xs f, derive gamma f (iter (length xs) (Funty Nat_ty) (Funty Nat_ty Bool_ty)) -> Forall (fun x => derive gamma x Nat_ty) xs -> derive gamma (minrec f xs) (Funty Nat_ty Nat_ty).", "decomposition": [], "retrieval": ["derive_minrec0"], "remove_type": "abort"}, {"name": "<unknown>", "text": "Proposition derive_minrec0: forall gamma f, derive gamma f (Funty Nat_ty Bool_ty) -> derive gamma (minrec0 f) (Funty Nat_ty Nat_ty).", "decomposition": [], "retrieval": ["derive_star", "subtype_leaf_fork", "derive_I", "derive_K", "derive_Y2", "derive_succ1", "derive_S2"], "remove_type": "abort"}, {"name": "derive_primrec", "text": "Theorem derive_primrec: forall gamma xs g h, derive gamma g (iter (length xs) (Funty Nat_ty) Nat_ty) -> derive gamma h (iter (2 + length xs) (Funty Nat_ty) Nat_ty) -> Forall (fun x => derive gamma x Nat_ty) xs -> derive gamma (primrec g h xs) (Funty Nat_ty Nat_ty).", "decomposition": [], "retrieval": ["derive_primrec0"], "remove_type": "abort"}, {"name": "derive_predN", "text": "Theorem derive_predN : forall gamma, derive gamma predN (Funty Nat_ty Nat_ty).", "decomposition": [], "retrieval": ["derive_star", "derive_fstL"], "remove_type": "abort"}, {"name": "derive_cond", "text": "Theorem derive_cond: forall gamma ty, derive gamma cond (Funty Bool_ty (Funty ty (Funty ty ty))).", "decomposition": [], "retrieval": ["derive_S2", "derive_subtype", "derive_K"], "remove_type": "abort"}, {"name": "derive_isZero", "text": "Theorem derive_isZero: forall gamma, derive gamma isZero (Funty Nat_ty Bool_ty).", "decomposition": [], "retrieval": ["derive_star", "derive_false", "derive_K1", "derive_true", "derive_subtype"], "remove_type": "abort"}, {"name": "derive_num", "text": "Lemma derive_num: forall k gamma, derive gamma (num k) Nat_ty.", "decomposition": [], "retrieval": ["derive_succ1", "derive_I", "derive_K1", "derive_generalisation"], "remove_type": "abort"}, {"name": "derive_succ1", "text": "Theorem derive_succ1: forall gamma, derive gamma succ1 (Funty Nat_ty Nat_ty).", "decomposition": [], "retrieval": ["subtype_leaf_fork", "derive_generalisation", "derive_K", "derive_K1", "derive_subtype", "derive_S2"], "remove_type": "abort"}, {"name": "derive_sndL", "text": "Theorem derive_sndL : forall gamma uty vty, derive gamma sndL (Funty (product uty vty) vty).", "decomposition": [], "retrieval": ["derive_I", "derive_K", "derive_K1", "derive_subtype", "derive_S2"], "remove_type": "abort"}, {"name": "derive_fstL", "text": "Theorem derive_fstL : forall gamma uty vty, derive gamma fstL (Funty (product uty vty) uty).", "decomposition": [], "retrieval": ["derive_I", "derive_K", "derive_K1", "derive_subtype", "derive_S2"], "remove_type": "abort"}, {"name": "derive_pairL", "text": "Theorem derive_pairL : forall gamma m n uty vty, derive gamma m uty -> derive gamma n vty -> derive gamma (pairL m n) (product uty vty).", "decomposition": [], "retrieval": ["derive_I", "derive_generalisation", "derive_K1", "lift_rec_preserves_derive", "derive_S2"], "remove_type": "abort"}, {"name": "derive_compose", "text": "Theorem derive_compose : forall gamma vtys utys wty, derive gamma (compose (length vtys) (length utys)) (Funty (fold_right Funty wty vtys) (* type of g *) (fold_right Funty (fold_right Funty wty utys) (map (fun vty => fold_right Funty vty utys) vtys) (* types of fs *) )).", "decomposition": [], "retrieval": ["derive_S2", "derive_compose0", "derive_K1", "derive_Kn"], "remove_type": "abort"}, {"name": "derive_compose0", "text": "Lemma derive_compose0 : forall vtys gamma utys wty, derive gamma (compose0 (length vtys) (length utys)) (Funty (fold_right Funty (fold_right Funty wty vtys) utys) (* type of g *) (fold_right Funty (fold_right Funty wty utys) (map (fun vty => fold_right Funty vty utys) vtys) (* types of fs *) )).", "decomposition": [], "retrieval": ["derive_star", "compose1_closed", "derive_I", "derive_compose1", "derive_K1", "derive_S2"], "remove_type": "abort"}, {"name": "derive_compose1", "text": "Lemma derive_compose1 : forall utys gamma vty wty, derive gamma (compose1 (length utys)) (Funty (fold_right Funty (Funty vty wty) utys) (Funty (fold_right Funty vty utys) (fold_right Funty wty utys) )).", "decomposition": [], "retrieval": ["derive_star", "derive_S2", "derive_K1", "derive_I"], "remove_type": "abort"}, {"name": "derive_Kn", "text": "Lemma derive_Kn : forall utys gamma ty, derive gamma (Kn (length utys)) (Funty ty (fold_right Funty ty utys)).", "decomposition": [], "retrieval": ["derive_star", "derive_I", "derive_K", "derive_K1", "derive_S2"], "remove_type": "abort"}, {"name": "derive_Z", "text": "Theorem derive_Z: forall k gamma f uty vty, derive gamma f (Funty ((quant k (Funty uty vty))) ((quant k (Funty uty vty)))) -> derive gamma (Z f) (quant k (Funty uty vty)).", "decomposition": [], "retrieval": ["lift_rec_preserves_subtype", "derive_generalisation_q", "subtype_lift3", "derive_generalisation2_q", "lift_rec_funty", "derive_subtype", "subtype_lift", "lift_rec_preserves_derive", "derive_wait2", "programs_have_types"], "remove_type": "abort"}], "subtypes.v": [{"name": "subtype_leaf_quant", "text": "Lemma subtype_leaf_quant: forall k, subtype Leaf (quant k Leaf).", "decomposition": [], "retrieval": ["subtype_quant"], "remove_type": "abort"}, {"name": "subtype_quant_leaf", "text": "Lemma subtype_quant_leaf: forall k, subtype (quant k Leaf) Leaf.", "decomposition": [], "retrieval": ["subtype_quant"], "remove_type": "abort"}, {"name": "fork_quant_commute", "text": "Lemma fork_quant_commute: forall k ty1 ty2, subtype (Fork(quant k ty1)(quant k ty2)) (quant k (Fork ty1 ty2)).", "decomposition": [], "retrieval": ["quant_succ", "fork_Quant_commute"], "remove_type": "abort"}, {"name": "fork_Quant_commute", "text": "Lemma fork_Quant_commute: forall ty1 ty2, subtype (Fork (Quant ty1) (Quant ty2)) (Quant (Fork ty1 ty2)) .", "decomposition": [], "retrieval": ["subst_rec_lift_rec0", "lift_rec_null"], "remove_type": "abort"}, {"name": "asf_quant_commute", "text": "Lemma asf_quant_commute: forall k ty, subtype (Asf (quant k ty)) (quant k (Asf ty)) .", "decomposition": [], "retrieval": ["quant_succ", "asf_Quant_commute"], "remove_type": "abort"}, {"name": "stem_quant_commute", "text": "Lemma stem_quant_commute: forall k ty, subtype (Stem (quant k ty)) (quant k (Stem ty)) .", "decomposition": [], "retrieval": ["stem_Quant_commute", "quant_succ"], "remove_type": "abort"}, {"name": "stem_Quant_commute", "text": "Lemma stem_Quant_commute: forall ty, subtype (Stem (Quant ty)) (Quant (Stem ty)) .", "decomposition": [], "retrieval": ["subst_rec_lift_rec0", "lift_rec_null"], "remove_type": "abort"}, {"name": "subtype_quantf_Quant", "text": "Lemma subtype_quantf_Quant: forall n ty, subtype (quantf n (Quant ty)) (Quant (quantf n ty)).", "decomposition": [], "retrieval": ["lift_rec_preserves_quantf", "subtype_lift3", "subtype_quantf"], "remove_type": "abort"}, {"name": "subtype_quant_quantf", "text": "Lemma subtype_quant_quantf: forall m n ty, subtype (quant m (quantf n ty)) (quantf n (quant m ty)).", "decomposition": [], "retrieval": ["quantf_succ", "subtype_quant"], "remove_type": "abort"}, {"name": "quanta_leaf", "text": "Lemma quanta_leaf: forall bs, subtype Leaf (quanta bs Leaf).", "decomposition": [], "retrieval": ["subtype_quanta"], "remove_type": "abort"}, {"name": "subtype_quanta_to_quant_count", "text": "Lemma subtype_quanta_to_quant_count: forall bs bs2 uty vty, subtype (quanta bs (quanta bs2 (Funty uty vty))) (quant (quant_count bs) (quanta bs2 (Funty uty vty))).", "decomposition": [], "retrieval": ["subtype_asf_quanta", "subtype_quanta", "quanta_app", "subtype_quant"], "remove_type": "abort"}, {"name": "subtype_quant_asf", "text": "Lemma subtype_quant_asf: forall n ty, subtype (quant n (Asf ty)) (Asf (quant n ty)) .", "decomposition": [], "retrieval": ["subtype_quant"], "remove_type": "abort"}, {"name": "subtype_quanta_asf", "text": "Lemma subtype_quanta_asf: forall bs ty, subtype (quanta bs (Asf ty)) (Asf (quanta bs ty)) .", "decomposition": [], "retrieval": ["subtype_quanta"], "remove_type": "abort"}, {"name": "subtype_asf_quanta", "text": "Lemma subtype_asf_quanta: forall bs ty, subtype (Asf (quanta bs ty)) (quanta bs (Asf ty)).", "decomposition": [], "retrieval": ["subtype_quanta", "asf_Quant_commute"], "remove_type": "abort"}, {"name": "asf_Quant_commute", "text": "Lemma asf_Quant_commute: forall ty, subtype (Asf (Quant ty)) (Quant (Asf ty)) .", "decomposition": [], "retrieval": ["subst_rec_lift_rec0", "lift_rec_null"], "remove_type": "abort"}, {"name": "subtype_quant_stem", "text": "Lemma subtype_quant_stem: forall k uty, subtype (quant k (Stem uty)) (Stem (quant k uty)).", "decomposition": [], "retrieval": ["subtype_quant"], "remove_type": "abort"}, {"name": "subtype_lift3", "text": "Lemma subtype_lift3: forall (n : nat) (ty : dtype), subtype (lift n (quant n ty)) ty.", "decomposition": [], "retrieval": ["subst_rec_lift_rec0", "lift_rec_null", "lift_rec_lift_rec", "lift_rec_preserves_subtype"], "remove_type": "abort"}, {"name": "subtype_lift2", "text": "Lemma subtype_lift2 : forall n ty, subtype (quant n (lift n ty)) ty.", "decomposition": [], "retrieval": ["subst_rec_lift_rec", "lift_rec_null", "subtype_quant", "lift_rec_lift_rec"], "remove_type": "abort"}, {"name": "subtype_lift", "text": "Lemma subtype_lift: forall n ty, subtype ty (quant n (lift n ty)).", "decomposition": [], "retrieval": ["lift_rec_null", "lift_rec_lift_rec"], "remove_type": "abort"}, {"name": "subst_rec_preserves_subtype", "text": "Lemma subst_rec_preserves_subtype: forall uty vty, subtype uty vty -> forall ty k, subtype (subst_rec uty ty k) (subst_rec vty ty k).", "decomposition": [], "retrieval": ["subst_rec_subst_rec", "subst_rec_preserves_quant", "subst_rec_lift_rec1", "variant_subst_rec_miss"], "remove_type": "abort"}, {"name": "lift_rec_preserves_subtype", "text": "Lemma lift_rec_preserves_subtype: forall ty1 ty2, subtype ty1 ty2 -> forall n k, subtype (lift_rec ty1 n k) (lift_rec ty2 n k).", "decomposition": [], "retrieval": ["lift_lift_rec", "lift_rec_preserves_variant", "lift_rec_preserves_quant", "lift_rec_subst_rec"], "remove_type": "abort"}], "derive.v": [{"name": "programs_have_types", "text": "Theorem programs_have_types: forall p gamma, program p -> derive gamma p (program_type p).", "decomposition": [], "retrieval": ["subtype_leaf_fork"], "remove_type": "abort"}, {"name": "derive_wait2", "text": "Theorem derive_wait2: forall gamma M N P u1 u2 u3 ty, derive gamma M (Funty u1 (Funty u2 (Funty u3 ty))) -> derive gamma N u1 -> derive gamma P u2 -> derive gamma (wait2 M N P) (Funty u3 ty).", "decomposition": [], "retrieval": ["derive_S2", "derive_K1", "derive_I"], "remove_type": "abort"}, {"name": "derive_wait", "text": "Theorem derive_wait: forall gamma M N uty k vty wty, derive gamma M (Funty uty (quant k (Funty vty wty))) -> derive gamma N uty -> derive gamma (wait M N) (quant k (Funty vty wty)).", "decomposition": [], "retrieval": ["derive_generalisation_q", "subtype_lift3", "subtype_quant", "derive_I", "derive_generalisation2_q", "derive_K1", "derive_subtype", "subtype_lift", "derive_S2"], "remove_type": "abort"}, {"name": "derive_swap", "text": "Theorem derive_swap: forall gamma f u v w, derive gamma f (Funty u (Funty v w)) -> derive gamma (swap f) (Funty v (Funty u w)).", "decomposition": [], "retrieval": ["derive_S2", "derive_S1", "derive_K", "derive_K1"], "remove_type": "abort"}, {"name": "derive_S", "text": "Theorem derive_S : forall gamma uty vty wty, derive gamma Sop (Funty (Funty uty (Funty vty wty)) (Funty (Funty uty vty) (Funty uty wty))).", "decomposition": [], "retrieval": ["derive_S2", "derive_K1"], "remove_type": "abort"}, {"name": "derive_S1", "text": "Theorem derive_S1 : forall gamma f uty vty wty, derive gamma f (Funty uty (Funty vty wty)) -> derive gamma (S1 f) (Funty (Funty uty vty) (Funty uty wty)).", "decomposition": [], "retrieval": ["subtype_leaf_fork"], "remove_type": "abort"}, {"name": "derive_generalisation2_q", "text": "Corollary derive_generalisation2_q: forall k gamma M T, derive gamma M (quant k T) -> derive (lift_context k gamma) M T.", "decomposition": [], "retrieval": ["lift_rec_lift_context", "derive_generalisation2", "lift_context_zero"], "remove_type": "abort"}, {"name": "derive_generalisation2", "text": "Theorem derive_generalisation2: forall gamma M T, derive gamma M (Quant T) -> derive (lift_context 1 gamma) M T.", "decomposition": [], "retrieval": ["derive_subtype", "subst_rec_lift_rec0", "lift_rec_null", "lift_rec_preserves_derive"], "remove_type": "abort"}, {"name": "derive_generalisation_q", "text": "Corollary derive_generalisation_q: forall k gamma M T, derive (lift_context k gamma) M T -> derive gamma M (quant k T).", "decomposition": [], "retrieval": ["lift_rec_lift_context", "lift_context_zero", "derive_generalisation"], "remove_type": "abort"}, {"name": "derive_generalisation", "text": "Theorem derive_generalisation: forall gamma M T, derive (lift_context 1 gamma) M T -> derive gamma M (Quant T).", "decomposition": [], "retrieval": ["derive_subtype", "get_lift_rec"], "remove_type": "abort"}, {"name": "derive_subst_rec", "text": "Lemma derive_subst_rec: forall gamma M ty, derive gamma M ty -> forall u k, derive (subst_rec_context u k gamma) M (subst_rec ty u k).", "decomposition": [], "retrieval": ["get_subst_rec", "subst_rec_preserves_subtype"], "remove_type": "abort"}, {"name": "lift_rec_preserves_derive", "text": "Lemma lift_rec_preserves_derive: forall gamma M ty, derive gamma M ty -> forall n k, derive (lift_rec_context n k gamma) M (lift_rec ty n k).", "decomposition": [], "retrieval": ["get_lift_rec", "lift_rec_preserves_subtype"], "remove_type": "abort"}], "types.v": [{"name": "subst_rec_preserves_quant", "text": "Lemma subst_rec_preserves_quant : forall n ty uty k, subst_rec (quant n ty) uty k = quant n (subst_rec ty uty (n+k)).", "decomposition": [], "retrieval": ["quant_succ"], "remove_type": "abort"}, {"name": "lift_lift_rec", "text": "Lemma lift_lift_rec : forall (U : dtype) (k p n i : nat), i <= n -> lift_rec (lift_rec U i p) (p + n) k = lift_rec (lift_rec U n k) i p.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lift1", "text": "Lemma lift1 : forall (U : dtype) (j i k : nat), lift_rec (lift_rec U i j) (j + i) k = lift_rec U i (j + k).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "relocate_succ", "text": "Lemma relocate_succ : forall n n0 k, relocate (S n) (S n0) k = S(relocate n n0 k).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "relocate_greaterthan", "text": "Lemma relocate_greaterthan : forall m n k, m>k -> relocate k m n = k.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "relocate_lessthan", "text": "Lemma relocate_lessthan : forall m n k, m<=k -> relocate k m n = (n+k).", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "typed_lambda.v": [{"name": "derive_star", "text": "Theorem derive_star: forall M gamma x uty ty, derive ((x,uty) :: gamma) M ty -> derive gamma (star x M) (Funty uty ty).", "decomposition": [], "retrieval": ["derive_I", "derive_K1", "derive_subtype", "derive_occurs_false", "derive_S2"], "remove_type": "abort"}, {"name": "<unknown>", "text": "Proposition derive_ref_sub: forall gamma M ty, derive gamma M ty -> forall s uty gamma1, gamma = (s,uty):: gamma1 -> M = Ref s -> subtype uty ty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "derive_occurs_false2", "text": "Lemma derive_occurs_false2: forall gamma M ty, derive gamma M ty -> forall x uty, occurs x M = false -> gamma <> nil -> derive ((x,uty):: gamma) M ty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "derive_occurs_false", "text": "Lemma derive_occurs_false: forall gamma M ty, derive gamma M ty -> forall x uty gamma1, gamma = (x,uty):: gamma1 -> occurs x M = false -> derive gamma1 M ty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "37e0bac2b1f206d1f786a3cb464cd62fd008ba08": {}}