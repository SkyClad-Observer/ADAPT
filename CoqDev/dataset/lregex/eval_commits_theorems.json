{"f611ebf5a9a4643b3a51fea7a273d705f0edf139": {"theories/Layerwise.v": [{"name": "oscanMatcher_is_oscanMatcher", "text": "Lemma oscanMatcher_is_oscanMatcher : is_oscanMatcher (@cScanMatch A).", "decomposition": [], "retrieval": ["cScanMatch_tape"], "remove_type": "admit"}, {"name": "rPass_abstract_rl", "text": "Lemma rPass_abstract_rl (r : @LRegex A) (w : list A) (vs : list valuation) : outer_length_wf (w, vs) -> is_oval r w vs -> forall n, n <= length w -> match_oregex (rPass (abstract r)) (ofirstn n (w, vs)) <-> exists m, m <= n /\\ match_regex r w m (n - m).", "decomposition": [], "retrieval": ["ofirstn_outer_length_wf", "rPass_match", "oracle_compose_aux", "oskipn_ofirstn_comm", "ofirstn_olength"], "remove_type": "abort"}, {"name": "reverse_pass_match_rl", "text": "Lemma reverse_pass_match_rl (r : @LRegex A) (w : list A) (vs : list valuation) : outer_length_wf (w, vs) -> is_oval r w vs -> forall n d, d <= n <= length w -> match_oregex (oreverse (abstract r)) (ofirstn d (orev (ofirstn n (w, vs)))) <-> match_regex r w (n - d) d.", "decomposition": [], "retrieval": ["ofirstn_outer_length_wf", "oracle_compose_aux", "oreverse_match_iff", "oskipn_outer_length_wf", "ofirstn_orev", "oskipn_ofirstn_comm", "ofirstn_olength"], "remove_type": "abort"}, {"name": "reverse_pass_match_ll", "text": "Lemma reverse_pass_match_ll (r : @LRegex A) (w : list A) (vs : list valuation) : outer_length_wf (w, vs) -> is_oval r w vs -> forall n, n <= length w -> match_oregex (rPass (oreverse (abstract r))) (ofirstn n (orev (w, vs))) <-> exists d, d <= n /\\ match_regex r w (length w - n) d.", "decomposition": [], "retrieval": ["oskipn_olength", "ofirstn_outer_length_wf", "oracle_compose_aux", "rPass_match", "oreverse_match_iff", "orev_outer_length_wf", "oskipn_outer_length_wf", "ofirstn_orev", "orev_olength", "oskipn_orev", "ofirstn_olength"], "remove_type": "abort"}, {"name": "reverse_pass_Some", "text": "Lemma reverse_pass_Some (r : @LRegex A) (or : ORegex) (w : list A) (vs : list valuation) : outer_length_wf (w, vs) -> is_oval r w vs -> or = abstract r -> forall lend', find_largest_true (cScanMatch (rPass (oreverse or)) (orev (w, vs))) = Some lend' <-> ((exists d, lend' <= length w /\\ (length w - lend') + d <= length w /\\ match_regex r w (length w - lend') d) /\\ (forall lend_more_left, lend_more_left < length w - lend' -> ~ (exists d, lend_more_left + d <= length w /\\ match_regex r w lend_more_left d))).", "decomposition": [], "retrieval": ["reverse_pass_match_ll", "cScanMatch_tape", "orev_outer_length_wf", "orev_olength", "find_largest_true_Some"], "remove_type": "abort"}, {"name": "reverse_pass_None", "text": "Lemma reverse_pass_None (r : @LRegex A) (or : ORegex) (w : list A) (vs : list valuation) : outer_length_wf (w, vs) -> is_oval r w vs -> or = abstract r -> find_largest_true (cScanMatch (rPass (oreverse or)) (orev (w, vs))) = None <-> (forall lend d, lend <= lend + d <= length w -> ~ match_regex r w lend d).", "decomposition": [], "retrieval": ["find_largest_true_None", "cScanMatch_tape", "orev_outer_length_wf", "orev_olength", "reverse_pass_match_ll"], "remove_type": "abort"}, {"name": "forward_pass_Some", "text": "Lemma forward_pass_Some (r : @LRegex A) (or : ORegex) (w : list A) (vs : list valuation) : outer_length_wf (w, vs) -> is_oval r w vs -> or = abstract r -> forall lend d, lend <= length w -> find_largest_true (cScanMatch or (oskipn lend (w, vs))) = Some d <-> match_regex r w lend d /\\ (forall d', d' > d -> lend + d' <= length w -> ~ match_regex r w lend d').", "decomposition": [], "retrieval": ["oskipn_olength", "oracle_compose_aux", "cScanMatch_tape", "oskipn_outer_length_wf", "match_length", "find_largest_true_Some"], "remove_type": "abort"}, {"name": "forward_pass_None", "text": "Lemma forward_pass_None (r : @LRegex A) (or : ORegex) (w : list A) (vs : list valuation) : outer_length_wf (w, vs) -> is_oval r w vs -> or = abstract r -> forall lend, lend <= length w -> find_largest_true (cScanMatch or (oskipn lend (w, vs))) = None <-> (forall d, lend + d <= length w -> ~ match_regex r w lend d).", "decomposition": [], "retrieval": ["oskipn_olength", "find_largest_true_None", "oracle_compose_aux", "cScanMatch_tape", "oskipn_outer_length_wf", "nth_error_Some_ex"], "remove_type": "abort"}, {"name": "llmatch_Some", "text": "Lemma llmatch_Some : forall r w n d, llmatch r w = Some (n, d) -> match_regex r w n d (* match *) /\\ (forall n', n' < n -> ~ (exists d', n' + d' <= length w /\\ match_regex r w n' d')) (* leftmost *) /\\ (forall d', d' > d -> n + d' <= length w -> ~ match_regex r w n d') (* longest *).", "decomposition": [], "retrieval": ["forward_pass_Some", "cScanMatch_tape", "absEval_spec", "transpose_length", "reverse_pass_Some"], "remove_type": "admit"}, {"name": "llmatch_None", "text": "Lemma llmatch_None : forall r w, llmatch r w = None -> forall n d, n <= n + d <= length w -> ~ match_regex r w n d.", "decomposition": [], "retrieval": ["forward_pass_None", "reverse_pass_None", "cScanMatch_tape", "absEval_spec", "transpose_length", "reverse_pass_Some"], "remove_type": "admit"}], "theories/OReverse.v": [{"name": "oreverse_match", "text": "Lemma oreverse_match : forall r ostr, outer_length_wf ostr -> match_oregex r ostr -> match_oregex (oreverse r) (orev ostr).", "decomposition": [], "retrieval": ["ofirstn_outer_length_wf", "ofirstn_all2", "orev_outer_length_wf", "oskipn_outer_length_wf", "ofirstn_orev", "orev_olength", "omatch_star_r", "oskipn_all2", "oskipn_all3", "oskipn_orev"], "remove_type": "admit"}], "theories/Reverse.v": [{"name": "reverse_match_aux", "text": "Lemma reverse_match_aux (r : LRegex) : (forall w start delta, start <= length w -> match_regex r w start delta -> match_regex (reverse r) (rev w) (length w - (start + delta)) delta) /\\ (forall w start delta, start <= length w -> match_regex (reverse r) w start delta -> match_regex r (rev w) (length w - (start + delta)) delta).", "decomposition": [], "retrieval": ["match_union_iff", "match_length", "match_lookahead_iff", "match_neglookahead_iff", "match_concat_iff", "match_neglookbehind_iff", "match_eps_iff", "match_class_iff", "match_lookbehind_iff", "match_not_match"], "remove_type": "admit"}], "theories/Equations.v": [{"name": "lookahead_neglookahead_inverse", "text": "Lemma lookahead_neglookahead_inverse : forall (r : LRegex), (?> r) \u222a (?!> r) \u2261 Epsilon.", "decomposition": [], "retrieval": ["match_union_iff", "match_lookahead_iff", "match_neglookahead_iff", "match_lem", "match_eps_iff", "match_not_match"], "remove_type": "admit"}, {"name": "lookahead_neglookahead_eps", "text": "Lemma lookahead_neglookahead_eps (r : LRegex) : (?> r) \u222a (?!> r) \u2261 Epsilon.", "decomposition": [], "retrieval": ["match_union_iff", "match_lookahead_iff", "match_neglookahead_iff", "match_lem", "match_eps_iff", "match_not_match"], "remove_type": "admit"}]}}