{"88ffe854a3116b9a6e794291e73794d23ceaaac8": {"theories/Prelude/ConstructiveFacts.v": [{"name": "first_nat_spec", "text": "Theorem first_nat_spec (p : nat -> bool) (n : nat) (WITNESS : p n = true) (m := first_nat p n) : p m = true /\\ \u27ea MIN : forall i, p i = true -> i >= m \u27eb.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/Logic/PrimRec.v": [{"name": "PrimRecsSpec_iff", "text": "Theorem PrimRecsSpec_iff (n : arity) (m : arity) (f : PrimRecs n m) (xs : Vector.t nat n) (z : Vector.t nat m) : PrimRecsSpec n m f xs z <-> V.map (eval_vec xs) (runPrimRecs f) = z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "PrimRecSpec_iff", "text": "Theorem PrimRecSpec_iff (n : arity) (f : PrimRec n) (xs : Vector.t nat n) (z : nat) : PrimRecSpec n f xs z <-> eval_vec xs (runPrimRec f) = z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "PrimRecsGraph_correct", "text": "Theorem PrimRecsGraph_correct (n : arity) (m : arity) (f : PrimRecs n m) (xs : Vector.t nat n) (z : Vector.t nat m) : PrimRecsGraph f xs z <-> PrimRecsSpec n m f xs z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "PrimRecGraph_correct", "text": "Theorem PrimRecGraph_correct (n : arity) (f : PrimRec n) (xs : Vector.t nat n) (z : nat) : PrimRecGraph f xs z <-> PrimRecSpec n f xs z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "PrimRecs_caseS", "text": "Lemma PrimRecs_caseS {n' : nat} (phi : forall x, PrimRecs x (S n') -> Type) (phi_cons: forall n, forall f', forall fs', phi n (PRs_cons n n' f' fs')) : forall x, forall fs, phi x fs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "PrimRecs_case0", "text": "Lemma PrimRecs_case0 (phi : forall x, PrimRecs x O -> Type) (phi_nil : forall n, phi n (PRs_nil n)) : forall x, forall fs, phi x fs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eval_compose_2_spec", "text": "Lemma eval_compose_2_spec (n : arity) (g : naryFun n) (h : naryFun (S n)) (xs : Vector.t nat n) (a : nat) (z : nat) (g_spec : eval_vec xs g = a) (h_spec : eval_vec (a :: xs) h = z) : eval_vec xs (eval_compose_2 g h) = z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eval_compose_spec", "text": "Lemma eval_compose_spec (n : arity) (m : arity) (gs : Vector.t (naryFun n) m) (h : naryFun m) (xs : Vector.t nat n) (ys : Vector.t nat m) (z : nat) (gs_spec : V.map (eval_vec xs) gs = ys) (h_spec : eval_vec ys h = z) : eval_vec xs (eval_compose gs h) = z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eval_proj_spec", "text": "Lemma eval_proj_spec (n : arity) (i : Fin.t n) (xs : Vector.t nat n) : eval_vec xs (eval_proj i) = xs !! i.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Data/Aczel.v": [{"name": "min_C_isOrdinal", "text": "Lemma min_C_isOrdinal (C : ensemble Tree) (min_C : Tree) (NONEMPTY : exists d, E.In d C) (ORDINAL : forall alpha, E.In alpha C -> isOrdinal alpha) (min_C_SPEC : forall z, z \\in min_C <-> (forall alpha, E.In alpha C -> z \\in alpha)) : isOrdinal min_C.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sup_C_isOrdinal", "text": "Lemma sup_C_isOrdinal (C : Tree) (ORDINAL : forall alpha, alpha \\in C -> isOrdinal alpha) : isOrdinal (unions C).", "decomposition": [], "retrieval": ["unions_spec"], "remove_type": "abort"}, {"name": "fromAcc_unfold", "text": "Lemma fromAcc_unfold (A : Type@{Set_u}) (R : A -> A -> Prop) (x : A) (ACC : Acc R x) : forall z, z \\in @fromAcc A R x ACC <-> (exists c : { y : A | R y x }, z == fromAcc (proj1_sig c) (Acc_inv ACC (proj2_sig c))).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subseteq_implies_rLe", "text": "Lemma subseteq_implies_rLe lhs rhs (SUBSET : lhs \\subseteq rhs) : lhs \u2266\u1d63 rhs.", "decomposition": [], "retrieval": ["member_implies_rLt", "member_intro"], "remove_type": "abort"}, {"name": "rLt_implies_rLe", "text": "Lemma rLt_implies_rLe lhs rhs (H_rLt : lhs <\u1d63 rhs) : lhs \u2266\u1d63 rhs.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/Logic/PropositionalLogic.v": [{"name": "weak_completeness", "text": "Corollary weak_completeness (Gamma : list formula) (C : formula) (ENTAILS : finite_entails Gamma C) : E.fromList Gamma \u22a2 C.", "decomposition": ["tautology_is_theorem", "extend_infers"], "retrieval": [], "remove_type": "abort"}, {"name": "tautology_is_theorem", "text": "Theorem tautology_is_theorem (C : formula) (ENTAILS : finite_entails [] C) : E.fromList [] \u22a2 C.", "decomposition": ["infers_dec", "is_theorem_if_is_deducible_for_any_gen_context"], "retrieval": [], "remove_type": "abort"}, {"name": "is_theorem_if_is_deducible_for_any_gen_context", "text": "Lemma is_theorem_if_is_deducible_for_any_gen_context (C : formula) (ls : list propLetter) (OCCURS : forall i : propLetter, In i ls -> occurs i C) (INFERS : forall e : propLetter -> bool, E.fromList (gen_context_for e ls) \u22a2 C) : E.fromList [] \u22a2 C.", "decomposition": ["Law_of_Excluded_Middle", "extend_infers"], "retrieval": [], "remove_type": "abort"}, {"name": "infers_dec", "text": "Lemma infers_dec (C : formula) : { ls : list propLetter | \u27ea OCCURS : forall l, In l ls <-> occurs l C \u27eb /\\ \u27ea INFERS_DEC : forall e, let Gamma := E.fromList (gen_context_for e ls) in if eval_bool e C then Gamma \u22a2 C else Gamma \u22a2 NegationF C \u27eb }.", "decomposition": ["extend_infers"], "retrieval": [], "remove_type": "abort"}, {"name": "finite_entails_if_entails", "text": "Theorem finite_entails_if_entails (Gamma : list formula) (C : formula) (ENTAILS : E.fromList Gamma \u22a8 C) : finite_entails Gamma C.", "decomposition": ["eval_bool_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "finite_entails_premise", "text": "Lemma finite_entails_premise (Gamma : list formula) (H : formula) (IN : In H Gamma) : finite_entails Gamma H.", "decomposition": ["finite_entails_monotonic"], "retrieval": [], "remove_type": "abort"}, {"name": "finite_entails_monotonic", "text": "Lemma finite_entails_monotonic (Gamma : list formula) (Gamma' : list formula) (C : formula) (ENTAILS : finite_entails Gamma C) (SUBSET : forall H, In H Gamma -> In H Gamma') : finite_entails Gamma' C.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eval_bool_spec", "text": "Theorem eval_bool_spec (e : propLetter -> bool) (p : formula) (e' := fun i => if e i then True else False) : forall b, eval_bool e p = b <-> (if b then evalFormula e' p else ~ evalFormula e' p).", "decomposition": ["eval_bool_true_iff"], "retrieval": [], "remove_type": "abort"}, {"name": "eval_bool_true_iff", "text": "Lemma eval_bool_true_iff (e : propLetter -> bool) (p : formula) : eval_bool e p = true <-> evalFormula (fun i => if e i then True else False) p.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Deduction_thm", "text": "Lemma Deduction_thm (Gamma : ensemble formula) (H : formula) (C : formula) : Gamma \u22a2 ImplicationF H C <-> E.insert H Gamma \u22a2 C.", "decomposition": ["extend_infers"], "retrieval": [], "remove_type": "abort"}, {"name": "extend_infers", "text": "Lemma extend_infers Gamma Gamma' C (INFERS : Gamma \u22a2 C) (SUBSET : Gamma \\subseteq Gamma') : Gamma' \u22a2 C.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Cut_property", "text": "Lemma Cut_property Gamma A B (INFERS : Gamma \u22a2 A) (IMPLY : E.insert A Gamma \u22a2 B) : Gamma \u22a2 B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Law_of_Excluded_Middle", "text": "Lemma Law_of_Excluded_Middle A : E.empty \u22a2 DisjunctionF A (NegationF A).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "structure_gives_its_subset_to_model", "text": "Lemma structure_gives_its_subset_to_model (Gamma : ensemble formula) (Gamma' : ensemble formula) (IS_STRUCTURE : is_structure Gamma') (INCL : Gamma \\subseteq Gamma') : forall p, p \\in Gamma -> evalFormula (E.preimage AtomF Gamma') p.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "extend_entails", "text": "Lemma extend_entails Gamma Gamma' C (ENTAILS: Gamma \u22a8 C) (SUBSET: Gamma \\subseteq Gamma') : Gamma' \u22a8 C.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Logic/MuRec.v": [{"name": "MuRecs_isPartialFunction", "text": "Theorem MuRecs_isPartialFunction (n : Arity) (m : Arity) (fs : MuRecs n m) (xs : Vector.t Value n) (z : Vector.t Value m) (z' : Vector.t Value m) (SPEC : MuRecsSpec n m fs xs z) (SPEC' : MuRecsSpec n m fs xs z') : z = z'.", "decomposition": ["MuRecsGraph_correct"], "retrieval": [], "remove_type": "abort"}, {"name": "MuRec_isPartialFunction", "text": "Theorem MuRec_isPartialFunction (n : Arity) (f : MuRec n) (xs : Vector.t Value n) (z : Value) (z' : Value) (SPEC : MuRecSpec n f xs z) (SPEC' : MuRecSpec n f xs z') : z = z'.", "decomposition": ["MuRecGraph_correct"], "retrieval": [], "remove_type": "abort"}, {"name": "MuRecsGraph_correct", "text": "Theorem MuRecsGraph_correct (n : Arity) (m : Arity) (f : MuRecs n m) (xs : Vector.t Value n) (z : Vector.t Value m) : MuRecsGraph f xs z <-> MuRecsSpec n m f xs z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "MuRecGraph_correct", "text": "Theorem MuRecGraph_correct (n : Arity) (f : MuRec n) (xs : Vector.t Value n) (z : Value) : MuRecGraph f xs z <-> MuRecSpec n f xs z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "compute_umin'", "text": "Lemma compute_umin' (EXISTENCE : exists x, umin' x) : { x : nat | umin' x }.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "umin_incl_Pre_umin", "text": "Lemma umin_incl_Pre_umin (s : nat) : umin s \\subseteq Pre_umin s.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "Pre_umin_Dumin", "text": "Lemma Pre_umin_Dumin {s : nat} (EXISTENCE : exists n, Pre_umin s n) : Dumin s.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "PQ_absurd", "text": "Lemma PQ_absurd (n : nat) : P n -> Q n -> False.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "Between_next", "text": "Lemma Between_next (n : nat) : forall m, Between n m -> P m -> Between n (S m).", "decomposition": ["wBetween_next"], "retrieval": [], "remove_type": "abort"}, {"name": "Between_refl", "text": "Lemma Between_refl (n : nat) : Between n n.", "decomposition": ["wBetween_refl"], "retrieval": [], "remove_type": "admit"}, {"name": "wBetween_next", "text": "Lemma wBetween_next (n : nat) : forall m, wBetween n m -> P m -> wBetween n (S m).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wBetween_refl", "text": "Lemma wBetween_refl (n : nat) : wBetween n n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Math/DomainTheory.v": [{"name": "paco_init", "text": "Theorem paco_init (F : D -> D) (F_monotonic : isMonotonic1 F) : paco F bot_lattice == proj1_sig (nu (@exist (D -> D) isMonotonic1 F F_monotonic)).", "decomposition": [], "retrieval": ["initPaco"], "remove_type": "abort"}, {"name": "initPaco", "text": "Lemma initPaco (f : `[D -> D]) : proj1_sig (nu f) == proj1_sig (Paco f) bot_lattice.", "decomposition": [], "retrieval": ["le_join_lattice_intror", "nu_f_is_gfpOf_f", "paco_unfold", "paco_fold", "nu_is_supremum_of_postfixedpointsOf", "join_lattice_le_intro"], "remove_type": "abort"}, {"name": "unions_is_supremum", "text": "Lemma unions_is_supremum (Xs : ensemble D) : is_supremum_of (E.unions Xs) Xs.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "inv_paco'", "text": "Lemma inv_paco' {paco_F : D -> D} {F : D -> D} {Y : D} {z : A} (H_paco' : z \\in paco' (paco_F := paco_F) F Y) : exists X, X \\subseteq join_lattice Y (paco_F Y) /\\ z \\in F X.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "empty_bot_lattice_spec", "text": "Lemma empty_bot_lattice_spec : is_supremum_of (@E.empty A) E.empty.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "union_join_lattice_spec", "text": "Lemma union_join_lattice_spec (X1 : ensemble A) (X2 : ensemble A) : is_supremum_of (@E.union A X1 X2) (E.fromList [X1; X2]).", "decomposition": [], "retrieval": ["in_union_iff"], "remove_type": "admit"}, {"name": "G_specification", "text": "Theorem G_specification (f : `[D -> D]) : paco_spec f (proj1_sig G f).", "decomposition": [], "retrieval": ["nu_f_is_gfpOf_f", "G0_isMonotonic1", "postfixedpoint_le_gfpOf", "nu_is_supremum_of_postfixedpointsOf", "join_lattice_le_intro"], "remove_type": "abort"}, {"name": "G_aux0_isMonotionicMap", "text": "Lemma G_aux0_isMonotionicMap {UPPER_LATTICE : isUpperSemilattice D} (f : `[D -> D]) (x : D) : isMonotonic1 (G_aux0 f x).", "decomposition": [], "retrieval": ["le_join_lattice_introl", "le_join_lattice_intror", "join_lattice_le_intro"], "remove_type": "admit"}, {"name": "strong_coinduction", "text": "Lemma strong_coinduction {COLA : isCola D} {UPPER_LATTICE : isUpperSemilattice D} (f : `[D -> D]) (x : D) : x =< proj1_sig (nu f) <-> x =< proj1_sig f (join_lattice x (proj1_sig (nu f))).", "decomposition": [], "retrieval": ["le_join_lattice_intror", "join_lattice_le_intro", "postfixedpoint_le_gfpOf"], "remove_type": "abort"}], "theories/Math/OrderTheory.v": [{"name": "meet_lattice_is_infimum", "text": "Lemma meet_lattice_is_infimum (x1 : D) (x2 : D) : is_infimum_of (meet_lattice x1 x2) (E.fromList [x1; x2]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bot_lattice_le_intro", "text": "Lemma bot_lattice_le_intro : forall x : D, bot_lattice =< x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "join_lattice_le_intro", "text": "Lemma join_lattice_le_intro (x1 : D) (x2 : D) : forall x : D, x1 =< x -> x2 =< x -> join_lattice x1 x2 =< x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "join_lattice_le_elim_r", "text": "Lemma join_lattice_le_elim_r (x1 : D) (x2 : D) : forall x : D, join_lattice x1 x2 =< x -> x2 =< x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "join_lattice_le_elim_l", "text": "Lemma join_lattice_le_elim_l (x1 : D) (x2 : D) : forall x : D, join_lattice x1 x2 =< x -> x1 =< x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "le_join_lattice_intror", "text": "Lemma le_join_lattice_intror (x1 : D) (x2 : D) : forall x : D, x =< x2 -> x =< join_lattice x1 x2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "le_join_lattice_introl", "text": "Lemma le_join_lattice_introl (x1 : D) (x2 : D) : forall x : D, x =< x1 -> x =< join_lattice x1 x2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Prelude/Prelude.v": [{"name": "in_remove_iff", "text": "Lemma in_remove_iff (A : Type) `(EQ_DEC : hasEqDec A) (x1 : A) (xs2 : list A) : forall z, In z (remove Prelude.eq_dec x1 xs2) <-> (In z xs2 /\\ z <> x1).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "insert_monotonic", "text": "Lemma insert_monotonic {A : Type} (x1 : A) (X2 : E.t A) (X2' : E.t A) (SUBSET : X2 \\subseteq X2') : E.insert x1 X2 \\subseteq E.insert x1 X2'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "67e2ef44d578db93b6625083e42161422ce055a3": {"theories/Math/OrderTheory.v": [{"name": "preservesDirectedness_if_isMonotonic", "text": "Lemma preservesDirectedness_if_isMonotonic {A : Type} {B : Type} {A_isPoset : isPoset A} {B_isPoset : isPoset B} (f : A -> B) (MONOTONIC : isMonotonic1 f) : forall X, isDirected X -> isDirected (E.image f X).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "isDirected_iff", "text": "Lemma isDirected_iff {D : Type} `{POSET : isPoset D} (X : ensemble D) : isDirected X <-> (forall xs, L.is_finsubset_of xs X -> exists y, y \\in X /\\ (forall x, In x xs -> x =< y)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "supremum_unique", "text": "Lemma supremum_unique sup_X1 sup_X2 X1 X2 (SUPREMUM1 : is_supremum_of sup_X1 X1) (SUPREMUM2 : is_supremum_of sup_X2 X2) (EQ : X1 == X2) : sup_X1 == sup_X2.", "decomposition": ["supremum_monotonic"], "retrieval": [], "remove_type": "admit"}, {"name": "supremum_monotonic", "text": "Lemma supremum_monotonic sup_X1 sup_X2 X1 X2 (SUPREMUM1 : is_supremum_of sup_X1 X1) (SUPREMUM2 : is_supremum_of sup_X2 X2) (SUBSET : X1 \\subseteq X2) : sup_X1 =< sup_X2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "supremum_is_infimum_of_its_upperbounds", "text": "Lemma supremum_is_infimum_of_its_upperbounds X sup_X (SUPREMUM : is_supremum_of sup_X X) : is_infimum_of sup_X (E.singleton sup_X).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leProp_unfold", "text": "Lemma leProp_unfold {A : Type} `{POSET : isPoset A} (x : A) (y : A) : x =< y <-> (forall z, z =< x -> z =< y).", "decomposition": [], "retrieval": ["PreOrder_iff"], "remove_type": "abort"}], "theories/Data/Vector.v": [{"name": "caseS", "text": "Lemma caseS {n' : nat} (phi : vec (S n') -> Type) (phiVCons : forall x' : A, forall xs' : vec n', phi (x' :: xs')) : forall xs, phi xs.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "runFin_getFin_id", "text": "Lemma runFin_getFin_id {m : nat} {n : nat} (hyp_lt : m < n) : runFin (getFin m hyp_lt) = @exist nat (gt n) m hyp_lt.", "decomposition": [], "retrieval": ["le_pirrel"], "remove_type": "abort"}], "theories/Prelude/Prelude.v": [{"name": "Kuratowski_cl_op_good", "text": "Theorem Kuratowski_cl_op_good {A : Type} (cl : ensemble A -> ensemble A) (cl_isClosureOperator : isClosureOperator cl) (cl_subadditive : forall X, forall Y, cl (E.union X Y) \\subseteq E.union (cl X) (cl Y)) (cl_classic : forall X, cl (E.complement (E.complement X)) == E.complement (E.complement (cl X))) : AxiomsForTopology A (Kuratowski_cl_op cl).", "decomposition": [], "retrieval": ["in_unions_iff"], "remove_type": "abort"}, {"name": "empty_isOpen", "text": "Lemma empty_isOpen {X : Type} {T : ensemble (ensemble X)} `{TOPOLOGY : AxiomsForTopology X T} : E.empty \\in T.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unfold_ensemble_eqProp", "text": "Lemma unfold_ensemble_eqProp (A : Type) (X1 : ensemble A) (X2 : ensemble A) : X1 == X2 <-> (X1 \\subseteq X2 /\\ X2 \\subseteq X1).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "in_intersections_iff", "text": "Lemma in_intersections_iff (A : Type) Xs : forall z, z \\in @intersections A Xs <-> (forall X, X \\in Xs -> z \\in X).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "in_complement_iff", "text": "Lemma in_complement_iff (A : Type) X : forall z, z \\in @complement A X <-> (~ z \\in X).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "in_insert_iff", "text": "Lemma in_insert_iff (A : Type) x1 X2 : forall z, z \\in @insert A x1 X2 <-> (z = x1 \\/ z \\in X2).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "in_preimage_iff", "text": "Lemma in_preimage_iff (A : Type) (B : Type) f Y : forall z, z \\in @preimage A B f Y <-> (exists y, y = f z /\\ y \\in Y).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "in_image_iff", "text": "Lemma in_image_iff (A : Type) (B : Type) f X : forall z, z \\in @image A B f X <-> (exists x, z = f x /\\ x \\in X).", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "e65d27b42d8d06005360a4c0d70b69bf5a41888c": {"theories/Prelude/Prelude.v": [{"name": "eqProp_cl_isCompatibleWith_eqProp", "text": "Lemma eqProp_cl_isCompatibleWith_eqProp {A : Type} `{SETOID : isSetoid A} (X : ensemble A) : isCompatibleWith_eqProp (eqProp_cl X).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "liftM2_spec", "text": "Lemma liftM2_spec {A : Type} {B : Type} {C : Type} (f : A -> B -> C) (X : E.t A) (Y : E.t B) : forall z, z \\in liftM2 f X Y <-> exists x, x \\in X /\\ exists y, y \\in Y /\\ z = f x y.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "mkFunctorFromMonad_good", "text": "Lemma mkFunctorFromMonad_good {M : Type -> Type} `{SETOID1 : isSetoid1 M} `{MONAD : isMonad M} `(MONAD_LAWS : @MonadLaws M SETOID1 MONAD) : @FunctorLaws M SETOID1 (mkFunctorFromMonad MONAD).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "isClosureOperator_iff", "text": "Lemma isClosureOperator_iff {A : Type} `{POSET : isPoset A} (cl : A -> A) : isClosureOperator cl <-> (forall x, forall y, x =< cl y <-> cl x =< cl y).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Data/Aczel.v": [{"name": "AxiomOfChoice_implies_StrongCollection", "text": "Theorem AxiomOfChoice_implies_StrongCollection (P : Tree -> Tree -> Prop) (COMPAT1 : forall y, isCompatibleWith_eqProp (fun x => P x y)) (COMPAT2 : forall x, isCompatibleWith_eqProp (fun y => P x y)) : forall X, (forall x, x \\in X -> exists y, P x y) -> exists Y, (forall x, x \\in X -> exists y, y \\in Y /\\ P x y) /\\ (forall y, y \\in Y -> exists x, x \\in X /\\ P x y).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "singleton_spec", "text": "Theorem singleton_spec x : forall z, z \\in singleton x <-> z == x.", "decomposition": ["upair_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "union_spec", "text": "Theorem union_spec x1 x2 : forall z, z \\in union x1 x2 <-> z \\in x1 \\/ z \\in x2.", "decomposition": ["bigcup_spec", "upair_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "upair_spec", "text": "Theorem upair_spec x1 x2 : forall z, z \\in upair x1 x2 <-> z == x1 \\/ z == x2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "empty_spec", "text": "Theorem empty_spec : forall z, z \\in empty <-> False.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bigcup_spec", "text": "Theorem bigcup_spec x : forall z, z \\in bigcup x <-> exists y, z \\in y /\\ y \\in x.", "decomposition": ["indexed_union_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "indexed_union_spec", "text": "Theorem indexed_union_spec I x_i : forall z, z \\in indexed_union I x_i <-> exists i, z \\in x_i i.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "power_spec", "text": "Theorem power_spec x : forall z, z \\in power x <-> z \\subseteq x.", "decomposition": ["subset_filterc"], "retrieval": [], "remove_type": "abort"}, {"name": "filter_good", "text": "Corollary filter_good P x (COMPAT : isCompatibleWith_eqProp P) : forall z, z \\in filter P x <-> z \\in x /\\ P z.", "decomposition": ["member_intro", "filter_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "filter_spec", "text": "Theorem filter_spec P x : forall z, z \\in filter P x <-> exists c, P (childnodes x c) /\\ z == childnodes x c.", "decomposition": ["filterc_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "subset_filterc", "text": "Corollary subset_filterc x : forall z, z \\subseteq x <-> exists P, z == filterc x P.", "decomposition": ["member_intro", "eqTree_intro", "filterc_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "filterc_spec", "text": "Theorem filterc_spec x P : forall z, z \\in filterc x P <-> exists cx : children x, z == childnodes x cx /\\ P cx.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eqTree_intro", "text": "Lemma eqTree_intro (lhs : Tree) (rhs : Tree) (SUBSET : lhs \\subseteq rhs) (SUBSET' : rhs \\subseteq lhs) : lhs == rhs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "extenesionality", "text": "Theorem extenesionality x y (EXT_EQ : forall z, z \\in x <-> z \\in y) : x == y.", "decomposition": ["member_intro"], "retrieval": [], "remove_type": "abort"}, {"name": "member_intro", "text": "Lemma member_intro cs ts c : ts c \\in mkNode cs ts.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "5e78535172999488ae703e01412f95b0c3dcf92f": {"theories/Math/DomainTheory.v": [{"name": "supOfMonotonicMaps_is_supremum", "text": "Lemma supOfMonotonicMaps_is_supremum {D : Type} {D' : Type} {PROSET : isProset D} {PROSET' : isProset D'} {COLA : isCola D} {COLA' : isCola D'} : forall F : ensemble `[D -> D'], is_supremum_of (supOfMonotonicMaps F) F.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "supremum_of_monotonic_maps_isMonotonic", "text": "Lemma supremum_of_monotonic_maps_isMonotonic {D : Type} {D' : Type} {PROSET : isProset D} {PROSET' : isProset D'} {COLA : isCola D} {COLA' : isCola D'} (F : ensemble `[D -> D']) : isMonotonic1 (proj1_sig (supremum_of_monotonic_maps F)).", "decomposition": [], "retrieval": ["in_image_iff"], "remove_type": "admit"}], "theories/Math/OrderTheory.v": [{"name": "lex_le_flip_iff", "text": "Corollary lex_le_flip_iff lhs rhs OBS : lex_compare lhs rhs = OBS <-> match OBS with | Lt => lex_compare rhs lhs = Gt | Eq => lex_compare rhs lhs = Eq | Gt => lex_compare rhs lhs = Lt end.", "decomposition": [], "retrieval": ["lex_le_flip_spec"], "remove_type": "abort"}, {"name": "lex_le_flip_spec", "text": "Lemma lex_le_flip_spec lhs rhs : match lex_compare lhs rhs with | Lt => lex_compare rhs lhs = Gt | Eq => lex_compare rhs lhs = Eq | Gt => lex_compare rhs lhs = Lt end.", "decomposition": [], "retrieval": ["compare_spec"], "remove_type": "admit"}, {"name": "compare_spec", "text": "Lemma compare_spec {A : Type} {PROSET : isProset A} {ORD : hsOrd A (PROSET := PROSET)} (lhs : A) (rhs : A) : match compare lhs rhs with | Lt => lhs =< rhs /\\ ~ lhs == rhs | Eq => lhs == rhs | Gt => rhs =< lhs /\\ ~ lhs == rhs end.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "preservesDirectedness_if_isMonotonic", "text": "Lemma preservesDirectedness_if_isMonotonic {A : Type} {B : Type} {A_isProset : isProset A} {B_isProset : isProset B} (f : A -> B) (MONOTONIC : isMonotonic1 f) : forall X, isDirected X -> isDirected (E.image f X).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "isDirected_iff", "text": "Lemma isDirected_iff {D : Type} `{PROSET : isProset D} (X : ensemble D) : isDirected X <-> (forall xs, L.is_finsubset_of xs X -> exists y, y \\in X /\\ (forall x, L.In x xs -> x =< y)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "infimum_monotonic", "text": "Lemma infimum_monotonic (X1 : ensemble D) (X2 : ensemble D) (inf_X1 : D) (inf_X2 : D) (INFIMUM1 : is_infimum_of inf_X1 X1) (INFIMUM2 : is_infimum_of inf_X2 X2) (SUBSETEQ : X1 \\subseteq X2) : inf_X2 =< inf_X1.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "supremum_of_lowerbounds_is_infimum", "text": "Theorem supremum_of_lowerbounds_is_infimum (inf_X : D) (X : ensemble D) : is_infimum_of inf_X X <-> is_supremum_of inf_X (lowerboundsOf X).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "supremum_monotonic", "text": "Lemma supremum_monotonic sup_X1 sup_X2 X1 X2 (SUPREMUM1 : is_supremum_of sup_X1 X1) (SUPREMUM2 : is_supremum_of sup_X2 X2) (SUBSET : X1 \\subseteq X2) : sup_X1 =< sup_X2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "supremum_is_infimum_of_its_upperbounds", "text": "Lemma supremum_is_infimum_of_its_upperbounds X sup_X (SUPREMUM : is_supremum_of sup_X X) : is_infimum_of sup_X (E.singleton sup_X).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "postfixedpointsOf_increasing", "text": "Lemma postfixedpointsOf_increasing (f1 : D -> D) (f2 : D -> D) (LE : f1 =< f2) : postfixedpointsOf f1 =< postfixedpointsOf f2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "prefixedpointsOf_decreasing", "text": "Lemma prefixedpointsOf_decreasing (f1 : D -> D) (f2 : D -> D) (LE : f1 =< f2) : prefixedpointsOf f1 >= prefixedpointsOf f2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Prelude/Prelude.v": [{"name": "Kuratowski_cl_op_good", "text": "Theorem Kuratowski_cl_op_good {A : Type} (cl : ensemble A -> ensemble A) (cl_isClosureOperator : isClosureOperator cl) (cl_preserves_empty : cl E.empty == E.empty) (cl_subadditive : forall X, forall Y, cl (E.union X Y) \\subseteq E.union (cl X) (cl Y)) (cl_classic : forall X, cl (E.complement (E.complement X)) == E.complement (E.complement (cl X))) : AxiomsForTopology A (Kuratowski_cl_op cl).", "decomposition": [], "retrieval": ["in_unions_iff"], "remove_type": "abort"}]}, "1189ecb6724c768531d3cca1bf1f5f2f7452fe4e": {"theories/Math/DomainTheory.v": [{"name": "paco_compositionality", "text": "Corollary paco_compositionality (F : D -> D) (r : D) (r1 : D) (r2 : D) (g1 : D) (g2 : D) (F_monotonic : isMonotonic1 F) (g1_le_G_f_r1 : g1 =< paco F r1) (g2_le_G_f_r2 : g2 =< paco F r2) (r1_le : r1 =< join_lattice r g2) (r2_le : r2 =< join_lattice r g1) : join_lattice g1 g2 =< paco F r.", "decomposition": ["G_compositionality", "paco_eq_G"], "retrieval": [], "remove_type": "abort"}, {"name": "Paco_isMonotonic1", "text": "Corollary Paco_isMonotonic1 : isMonotonic1 Paco.", "decomposition": ["Paco_eq_G", "G1_isMonotonic1"], "retrieval": [], "remove_type": "abort"}, {"name": "paco_eq_G", "text": "Corollary paco_eq_G (F : D -> D) (F_monotonic : isMonotonic1 F) : forall X : D, paco F X == proj1_sig (proj1_sig G (@exist (D -> D) isMonotonic1 F F_monotonic)) X.", "decomposition": ["Paco_eq_G"], "retrieval": [], "remove_type": "abort"}, {"name": "Paco_eq_G", "text": "Corollary Paco_eq_G (f : `[D -> D]) : Paco f == proj1_sig G f.", "decomposition": ["G_characterization", "Paco_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "Paco_spec", "text": "Corollary Paco_spec (f : `[D -> D]) : paco_spec f (Paco f).", "decomposition": ["accumPaco", "initPaco", "unfoldPaco"], "retrieval": [], "remove_type": "abort"}, {"name": "paco_accum", "text": "Theorem paco_accum (F : D -> D) (X : D) (Y : D) (F_monotonic : isMonotonic1 F) : Y =< paco F X <-> Y =< paco F (join_lattice X Y).", "decomposition": ["accumPaco"], "retrieval": [], "remove_type": "abort"}, {"name": "accumPaco", "text": "Lemma accumPaco (f : `[D -> D]) : forall X : D, forall Y : D, Y =< proj1_sig (Paco f) X <-> Y =< proj1_sig (Paco f) (join_lattice X Y).", "decomposition": ["le_join_lattice_intror", "paco_preserves_monotonicity", "paco_unfold", "G_aux0_isMonotionicMap", "postfixedpoint_le_gfpOf", "le_join_lattice_introl", "nu_is_supremum_of_postfixedpointsOf", "join_lattice_le_intro"], "retrieval": ["postfixedpoint_is_gfpOf"], "remove_type": "abort"}, {"name": "unfoldPaco", "text": "Lemma unfoldPaco (f : `[D -> D]) : forall X : D, proj1_sig (Paco f) X == proj1_sig f (join_lattice X (proj1_sig (Paco f) X)).", "decomposition": ["paco_unfold", "paco_fold"], "retrieval": [], "remove_type": "abort"}, {"name": "paco_init", "text": "Theorem paco_init (F : D -> D) (F_monotonic : isMonotonic1 F) : paco F bottom_lattice == proj1_sig (nu (@exist (D -> D) isMonotonic1 F F_monotonic)).", "decomposition": ["initPaco"], "retrieval": [], "remove_type": "abort"}, {"name": "initPaco", "text": "Lemma initPaco (f : `[D -> D]) : proj1_sig (nu f) == proj1_sig (Paco f) bottom_lattice.", "decomposition": ["le_join_lattice_intror", "nu_f_is_gfpOf_f", "paco_unfold", "paco_fold", "nu_is_supremum_of_postfixedpointsOf", "join_lattice_le_intro"], "retrieval": [], "remove_type": "abort"}, {"name": "paco_preserves_monotonicity", "text": "Lemma paco_preserves_monotonicity (F : D -> D) (F_monotonic : isMonotonic1 F) : isMonotonic1 (paco F).", "decomposition": ["paco_unfold"], "retrieval": [], "remove_type": "admit"}, {"name": "paco_unfold", "text": "Theorem paco_unfold (F : D -> D) (Y : D) (F_monotonic : isMonotonic1 F) : paco F Y \\subseteq F (join_lattice Y (paco F Y)).", "decomposition": ["inv_paco'"], "retrieval": [], "remove_type": "abort"}, {"name": "paco_fold", "text": "Theorem paco_fold (F : D -> D) (Y : D) : F (join_lattice Y (paco F Y)) \\subseteq paco F Y.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unions_is_supremum", "text": "Lemma unions_is_supremum (Xs : ensemble D) : is_supremum_of (E.unions Xs) Xs.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "inv_paco'", "text": "Lemma inv_paco' {paco_F : D -> D} {F : D -> D} {Y : D} {z : A} (H_paco' : z \\in paco' (paco_F := paco_F) F Y) : exists X, X \\subseteq join_lattice Y (paco_F Y) /\\ z \\in F X.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bottom_lattice_spec_forEnsembles", "text": "Lemma bottom_lattice_spec_forEnsembles : is_supremum_of (@E.empty A) E.empty.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "join_lattice_spec_forEnsembles", "text": "Lemma join_lattice_spec_forEnsembles (X1 : ensemble A) (X2 : ensemble A) : is_supremum_of (@E.union A X1 X2) (E.fromList [X1; X2]).", "decomposition": [], "retrieval": ["in_union_iff"], "remove_type": "admit"}, {"name": "G_characterization", "text": "Theorem G_characterization (f : `[D -> D]) (G_f : `[D -> D]) (G_f_spec : paco_spec f G_f) : G_f == proj1_sig G f.", "decomposition": ["join_lattice_le_intro", "G_specification", "postfixedpoint_le_gfpOf"], "retrieval": [], "remove_type": "abort"}, {"name": "G_compositionality", "text": "Theorem G_compositionality (f : `[D -> D]) (r : D) (r1 : D) (r2 : D) (g1 : D) (g2 : D) (g1_le_G_f_r1 : g1 =< proj1_sig (proj1_sig G f) r1) (g2_le_G_f_r2 : g2 =< proj1_sig (proj1_sig G f) r2) (r1_le : r1 =< join_lattice r g2) (r2_le : r2 =< join_lattice r g1) : join_lattice g1 g2 =< proj1_sig (proj1_sig G f) r.", "decomposition": ["join_lattice_le_intro", "G0_isMonotonic1", "G_specification"], "retrieval": [], "remove_type": "abort"}, {"name": "G_specification", "text": "Theorem G_specification (f : `[D -> D]) : paco_spec f (proj1_sig G f).", "decomposition": ["nu_f_is_gfpOf_f", "G0_isMonotonic1", "postfixedpoint_le_gfpOf", "nu_is_supremum_of_postfixedpointsOf", "join_lattice_le_intro"], "retrieval": [], "remove_type": "abort"}, {"name": "G1_isMonotonic1", "text": "Lemma G1_isMonotonic1 : isMonotonic1 G1.", "decomposition": ["nu_is_supremum_of_postfixedpointsOf"], "retrieval": [], "remove_type": "admit"}, {"name": "G0_isMonotonic1", "text": "Lemma G0_isMonotonic1 (f : `[D -> D]) : isMonotonic1 (G0 f).", "decomposition": ["le_join_lattice_introl", "le_join_lattice_intror", "strong_coinduction", "join_lattice_le_intro"], "retrieval": [], "remove_type": "admit"}, {"name": "G_aux0_isMonotionicMap", "text": "Lemma G_aux0_isMonotionicMap {UPPER_LATTICE : isUpperLattice D} (f : `[D -> D]) (x : D) : isMonotonic1 (G_aux0 f x).", "decomposition": ["le_join_lattice_introl", "le_join_lattice_intror", "join_lattice_le_intro"], "retrieval": [], "remove_type": "admit"}, {"name": "strong_coinduction", "text": "Lemma strong_coinduction {COLA : isCola D} {UPPER_LATTICE : isUpperLattice D} (f : `[D -> D]) (x : D) : x =< proj1_sig (nu f) <-> x =< proj1_sig f (join_lattice x (proj1_sig (nu f))).", "decomposition": ["le_join_lattice_intror", "join_lattice_le_intro", "postfixedpoint_le_gfpOf"], "retrieval": [], "remove_type": "abort"}, {"name": "bottom_lattice_le_intro", "text": "Lemma bottom_lattice_le_intro {UPPER_LATTICE : isUpperLattice D} : forall x : D, bottom_lattice =< x.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "join_lattice_le_intro", "text": "Lemma join_lattice_le_intro {UPPER_LATTICE : isUpperLattice D} (x1 : D) (x2 : D) : forall x : D, x1 =< x -> x2 =< x -> join_lattice x1 x2 =< x.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "join_lattice_le_elim_r", "text": "Lemma join_lattice_le_elim_r {UPPER_LATTICE : isUpperLattice D} (x1 : D) (x2 : D) : forall x : D, join_lattice x1 x2 =< x -> x2 =< x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "join_lattice_le_elim_l", "text": "Lemma join_lattice_le_elim_l {UPPER_LATTICE : isUpperLattice D} (x1 : D) (x2 : D) : forall x : D, join_lattice x1 x2 =< x -> x1 =< x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "le_join_lattice_intror", "text": "Lemma le_join_lattice_intror {UPPER_LATTICE : isUpperLattice D} (x1 : D) (x2 : D) : forall x : D, x =< x2 -> x =< join_lattice x1 x2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "le_join_lattice_introl", "text": "Lemma le_join_lattice_introl {UPPER_LATTICE : isUpperLattice D} (x1 : D) (x2 : D) : forall x : D, x =< x1 -> x =< join_lattice x1 x2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "postfixedpoint_le_gfpOf", "text": "Lemma postfixedpoint_le_gfpOf (f : `[D -> D]) (x : D) (POSTFIXEDPOINT : x =< proj1_sig f x) : x =< proj1_sig (nu f).", "decomposition": ["nu_is_supremum_of_postfixedpointsOf"], "retrieval": [], "remove_type": "abort"}, {"name": "coinduction_principle", "text": "Lemma coinduction_principle (b : `[D -> D]) : forall x, x =< proj1_sig (nu b) <-> (exists y : D, x =< y /\\ y =< proj1_sig b y).", "decomposition": ["nu_f_is_gfpOf_f", "nu_is_supremum_of_postfixedpointsOf"], "retrieval": [], "remove_type": "abort"}, {"name": "nu_f_is_gfpOf_f", "text": "Corollary nu_f_is_gfpOf_f (f : `[D -> D]) : is_gfpOf (proj1_sig (nu f)) (proj1_sig f).", "decomposition": ["nu_is_supremum_of_postfixedpointsOf"], "retrieval": ["postfixedpoint_is_gfpOf"], "remove_type": "abort"}, {"name": "nu_is_supremum_of_postfixedpointsOf", "text": "Corollary nu_is_supremum_of_postfixedpointsOf (f : `[D -> D]) : is_supremum_of (proj1_sig (nu f)) (postfixedpointsOf (proj1_sig f)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fixedpointsOf_asCoLa", "text": "Corollary fixedpointsOf_asCoLa (f : `[D -> D]) : isCola (@sig D (fixedpointsOf (proj1_sig f))) (PROSET := @subProset D PROSET (fixedpointsOf (proj1_sig f))).", "decomposition": [], "retrieval": ["KnasterTarski_3rd", "in_image_iff", "is_supremum_in_iff"], "remove_type": "abort"}, {"name": "KnasterTarski_3rd", "text": "Theorem KnasterTarski_3rd (f : D -> D) (W : ensemble D) (f_isMonotonic : isMonotonic1 f) (W_is_a_set_of_fixed_points_of_f : W \\subseteq fixedpointsOf f) : {fix_f : D | is_supremum_in fix_f W (fixedpointsOf f)}.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "ca797c689c4d05b0ea806a9598cad84cadf58c72": {"theories/Math/BooleanAlgebra.v": [{"name": "inconsistent_compatWith_isSubsetOf", "text": "Lemma inconsistent_compatWith_isSubsetOf X X' (INCONSISTENT : inconsistent X) (SUBSET : X \\subseteq X') : inconsistent X'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "isFilter_compatWith_eqProp", "text": "Lemma isFilter_compatWith_eqProp F F' (F_isFilter : isFilter F) (F_eq_F' : F == F') : isFilter F'.", "decomposition": ["isFilter_intro", "andsB_two"], "retrieval": [], "remove_type": "abort"}, {"name": "isFilter_intro", "text": "Lemma isFilter_intro F (NONEMPTY : exists x0, x0 \\in F) (CLOSED_MEET : forall x1, forall x2, x1 \\in F -> x2 \\in F -> andB x1 x2 \\in F) (CLOSED_UPWARD : forall x, x \\in F -> forall x', x =< x' -> x' \\in F) : isFilter F.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "andsB_le_In", "text": "Lemma andsB_le_In xs x (x_in_xs : In x xs) : andsB xs =< x.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "falseB_isBottom", "text": "Lemma falseB_isBottom x : falseB =< x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "andsB_two", "text": "Lemma andsB_two x1 x2 : andsB [x1; x2] == andB x1 x2.", "decomposition": ["andsB_app", "andsB_one"], "retrieval": [], "remove_type": "abort"}, {"name": "andsB_one", "text": "Lemma andsB_one x1 : andsB [x1] == x1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "andsB_zero", "text": "Lemma andsB_zero : andsB [] == trueB.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "andsB_app", "text": "Lemma andsB_app xs1 xs2 : andsB (xs1 ++ xs2) == andB (andsB xs1) (andsB xs2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "andB_le_intro_r", "text": "Lemma andB_le_intro_r x1 x2 : andB x1 x2 =< x2.", "decomposition": ["andB_le_intro_l"], "retrieval": [], "remove_type": "abort"}, {"name": "andB_le_intro_l", "text": "Lemma andB_le_intro_l x1 x2 : andB x1 x2 =< x1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "0f810f4da4e5512ca95aeeaeef3c6389b17a0447": {"theories/Data/Aczel.v": [{"name": "fromAcc_rLt_fromAcc_intro", "text": "Corollary fromAcc_rLt_fromAcc_intro (A : Type@{Set_u}) (R : A -> A -> Prop) (x : A) (x' : A) (ACC : Acc R x) (ACC' : Acc R x') (R_x_x' : R x x') : fromAcc x ACC <\u1d63 fromAcc x' ACC'.", "decomposition": ["member_implies_rLt", "fromAcc_member_fromAcc_intro"], "retrieval": [], "remove_type": "abort"}, {"name": "fromAcc_member_fromAcc_intro", "text": "Lemma fromAcc_member_fromAcc_intro (A : Type@{Set_u}) (R : A -> A -> Prop) (x : A) (x' : A) (ACC : Acc R x) (ACC' : Acc R x') (R_x_x' : R x x') : fromAcc x ACC \\in fromAcc x' ACC'.", "decomposition": ["fromAcc_unfold"], "retrieval": [], "remove_type": "abort"}, {"name": "fromAcc_unfold", "text": "Lemma fromAcc_unfold {A : Type@{Set_u}} {R : A -> A -> Prop} x ACC : forall z, z \\in @fromAcc A R x ACC <-> exists c : { y : A | R y x }, z == fromAcc (proj1_sig c) (Acc_inv ACC (proj2_sig c)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rLt_wf", "text": "Theorem rLt_wf : well_founded rLt.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rLt_rLe_rLt", "text": "Lemma rLt_rLe_rLt x y z (x_rLt_y : x <\u1d63 y) (y_rLe_z : y \u2266\u1d63 z) : x <\u1d63 z.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "rLe_rLt_rLt", "text": "Lemma rLe_rLt_rLt x y z (x_rLe_y : x \u2266\u1d63 y) (y_rLt_z : y <\u1d63 z) : x <\u1d63 z.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "member_implies_rLt", "text": "Lemma member_implies_rLt x y (IN : x \\in y) : x <\u1d63 y.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rLt_implies_rLe", "text": "Lemma rLt_implies_rLe lhs rhs (H_rLt : lhs <\u1d63 rhs) : lhs \u2266\u1d63 rhs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eqTree_rLe_rLe", "text": "Lemma eqTree_rLe_rLe x y z (EQ : x == y) (H_rLe : y \u2266\u1d63 z) : x \u2266\u1d63 z.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "rLe_eqTree_rLe", "text": "Lemma rLe_eqTree_rLe x y z (H_rLe : x \u2266\u1d63 y) (EQ : y == z) : x \u2266\u1d63 z.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "rLe_trans", "text": "Lemma rLe_trans x y z (LE1 : x \u2266\u1d63 y) (LE2 : y \u2266\u1d63 z) : x \u2266\u1d63 z.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "rLe_refl", "text": "Lemma rLe_refl x : x \u2266\u1d63 x.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "AxiomOfChoice_implies_StrongCollection", "text": "Theorem AxiomOfChoice_implies_StrongCollection (P : Tree -> Tree -> Prop) (COMPAT1 : forall y, isCompatibleWith_eqProp (fun x => P x y)) (COMPAT2 : forall x, isCompatibleWith_eqProp (fun y => P x y)) : forall X, (forall x, x \\in X -> exists y, P x y) -> exists Y, (forall x, x \\in X -> exists y, y \\in Y /\\ P x y) /\\ (forall y, y \\in Y -> exists x, x \\in X /\\ P x y).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "snd_pair", "text": "Corollary snd_pair x y : snd (pair x y) == y.", "decomposition": ["destruct_pair", "pair_inv"], "retrieval": [], "remove_type": "abort"}, {"name": "fst_pair", "text": "Corollary fst_pair x y : fst (pair x y) == x.", "decomposition": ["destruct_pair", "pair_inv"], "retrieval": [], "remove_type": "abort"}, {"name": "destruct_pair", "text": "Theorem destruct_pair (t : Tree) (EQ : exists x, exists y, t == pair x y) : t == pair (fst t) (snd t).", "decomposition": ["singlton_inj", "pair_inv", "singleton_eq_upair_implies", "singlton_spec", "unions_spec"], "retrieval": ["filter_good", "eqTree_intro", "upair_spec"], "remove_type": "abort"}, {"name": "pair_inv", "text": "Theorem pair_inv x1 x2 y1 y2 (EQ : pair x1 y1 == pair x2 y2) : x1 == x2 /\\ y1 == y2.", "decomposition": ["singlton_inj", "upair_eq_upair_implies", "singleton_eq_upair_implies"], "retrieval": [], "remove_type": "abort"}, {"name": "singleton_eq_upair_implies", "text": "Lemma singleton_eq_upair_implies x y z (EQ : singlton x == upair y z) : x == y /\\ y == z.", "decomposition": ["upair_eq_upair_implies"], "retrieval": [], "remove_type": "abort"}, {"name": "upair_eq_upair_implies", "text": "Lemma upair_eq_upair_implies x1 y1 x2 y2 (EQ : upair x1 y1 == upair x2 y2) : (x1 == x2 /\\ y1 == y2) \\/ (x1 == y2 /\\ x2 == y1).", "decomposition": ["singlton_spec"], "retrieval": ["upair_spec"], "remove_type": "abort"}, {"name": "singlton_inj", "text": "Corollary singlton_inj x y (EQ : singlton x == singlton y) : x == y.", "decomposition": ["singlton_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "singlton_spec", "text": "Theorem singlton_spec x : forall z, z \\in singlton x <-> z == x.", "decomposition": [], "retrieval": ["upair_spec"], "remove_type": "abort"}, {"name": "union_spec", "text": "Theorem union_spec x1 x2 : forall z, z \\in union x1 x2 <-> z \\in x1 \\/ z \\in x2.", "decomposition": ["unions_spec"], "retrieval": ["upair_spec"], "remove_type": "abort"}, {"name": "unions_spec", "text": "Theorem unions_spec x : forall z, z \\in unions x <-> exists y, z \\in y /\\ y \\in x.", "decomposition": [], "retrieval": ["indexed_union_spec"], "remove_type": "abort"}], "theories/Prelude/Prelude.v": [{"name": "mkFunctorFromMonad_good", "text": "Lemma mkFunctorFromMonad_good {M : Type -> Type} `{SETOID1 : isSetoid1 M} `{MONAD : isMonad M} `(MONAD_LAWS : @MonadLaws M SETOID1 MONAD) : @FunctorLaws M SETOID1 (mkFunctorFromMonad MONAD).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "7ccc112bc800b0ad1d7fc64f606f6094de235e8c": {}, "a90bd4c785f86aa4bc5b4a37568c0a0bdf6aa804": {}, "4f4049fdbc43959d6134d366ddcfad3ae91bbe01": {"theories/Data/Aczel.v": [{"name": "unions_isOrdinal", "text": "Lemma unions_isOrdinal x (ORDINAL : isOrdinal x) : isOrdinal (unions x).", "decomposition": ["sup_C_isOrdinal"], "retrieval": [], "remove_type": "abort"}, {"name": "succ_spec", "text": "Theorem succ_spec x : forall z, z \\in succ x <-> (z \\in x \\/ z == x).", "decomposition": [], "retrieval": ["singlton_spec", "union_spec"], "remove_type": "abort"}, {"name": "inf_C_isOrdinal", "text": "Lemma inf_C_isOrdinal C inf_C (NONEMPTY : exists d, d \\in C) (ORDINAL : forall alpha, alpha \\in C -> isOrdinal alpha) (SPEC : forall z, z \\in inf_C <-> (forall alpha, alpha \\in C -> z \\in alpha)) : isOrdinal inf_C.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sup_C_isOrdinal", "text": "Lemma sup_C_isOrdinal C (ORDINAL : forall alpha, alpha \\in C -> isOrdinal alpha) : isOrdinal (unions C).", "decomposition": [], "retrieval": ["unions_spec"], "remove_type": "abort"}, {"name": "fromWf_isOrdinal", "text": "Lemma fromWf_isOrdinal {A : Type@{Set_u}} `{WOSET : isWellOrderedSet A} : isOrdinal (fromWf wltProp_well_founded).", "decomposition": [], "retrieval": ["fromAcc_unfold", "member_intro", "fromAcc_member_fromAcc_intro"], "remove_type": "abort"}, {"name": "fromAcc_unfold", "text": "Lemma fromAcc_unfold {A : Type@{Set_u}} {R : A -> A -> Prop} x ACC : forall z, z \\in @fromAcc A R x ACC <-> (exists c : { y : A | R y x }, z == fromAcc (proj1_sig c) (Acc_inv ACC (proj2_sig c))).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "intersection_spec", "text": "Theorem intersection_spec x y : forall z, z \\in intersection x y <-> (z \\in x /\\ z \\in y).", "decomposition": [], "retrieval": ["filter_good"], "remove_type": "abort"}, {"name": "union_spec", "text": "Theorem union_spec x1 x2 : forall z, z \\in union x1 x2 <-> (z \\in x1 \\/ z \\in x2).", "decomposition": [], "retrieval": ["upair_spec", "unions_spec"], "remove_type": "abort"}, {"name": "upair_spec", "text": "Theorem upair_spec x1 x2 : forall z, z \\in upair x1 x2 <-> (z == x1 \\/ z == x2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unions_spec", "text": "Theorem unions_spec x : forall z, z \\in unions x <-> (exists y, z \\in y /\\ y \\in x).", "decomposition": [], "retrieval": ["indexed_union_spec"], "remove_type": "abort"}, {"name": "indexed_union_spec", "text": "Theorem indexed_union_spec I x_i : forall z, z \\in indexed_union I x_i <-> (exists i, z \\in x_i i).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "filter_good", "text": "Corollary filter_good P x (COMPAT : isCompatibleWith_eqProp P) : forall z, z \\in filter P x <-> (z \\in x /\\ P z).", "decomposition": [], "retrieval": ["member_intro", "filter_spec"], "remove_type": "abort"}, {"name": "filter_spec", "text": "Theorem filter_spec P x : forall z, z \\in filter P x <-> (exists c, P (childnodes x c) /\\ z == childnodes x c).", "decomposition": [], "retrieval": ["filterc_spec"], "remove_type": "abort"}, {"name": "subset_filterc", "text": "Corollary subset_filterc x : forall z, z \\subseteq x <-> (exists P, z == filterc x P).", "decomposition": [], "retrieval": ["member_intro", "eqTree_intro", "filterc_spec"], "remove_type": "abort"}, {"name": "filterc_spec", "text": "Theorem filterc_spec x P : forall z, z \\in filterc x P <-> (exists cx : children x, z == childnodes x cx /\\ P cx).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Prelude/Prelude.v": [{"name": "isClosureOperator_iff", "text": "Lemma isClosureOperator_iff {A : Type} `{POSET : isPoset A} (cl : A -> A) : isClosureOperator cl <-> (forall x, forall y, x =< cl y <-> cl x =< cl y).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "7eb81fc624ba9a721a5b30cdc00326b51da9db48": {}, "44cce8fcd9401405ab2021fd1c8d9779cc6250e8": {}, "7f205f9994b1a66af5119acb7a7a8b89728ab643": {"theories/Math/ThN.v": [{"name": "le_unfold", "text": "Lemma le_unfold {n : nat} {m : nat} : n <= m <-> match m with | O => n = 0 | S m' => n = S m' \\/ n <= m' end.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eq_by_lt_ext", "text": "Lemma eq_by_lt_ext (x : nat) (y : nat) (LT_EXT : forall z, z < x <-> z < y) : x = y.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "maxs_sim", "text": "Lemma maxs_sim ns1 ns2 (SIM : forall n, In n ns1 -> exists n', In n' ns2 /\\ n <= n') : maxs ns1 <= maxs ns2.", "decomposition": ["in_maxs_ge"], "retrieval": [], "remove_type": "abort"}, {"name": "maxs_ext", "text": "Lemma maxs_ext (ns1 : list nat) (ns2 : list nat) (H_EXT_EQ : forall n, In n ns1 <-> In n ns2) : maxs ns1 = maxs ns2.", "decomposition": ["maxs_subset"], "retrieval": [], "remove_type": "abort"}, {"name": "maxs_subset", "text": "Lemma maxs_subset (ns1 : list nat) (ns2 : list nat) (H_SUBSET : forall n, In n ns1 -> In n ns2) : maxs ns1 <= maxs ns2.", "decomposition": ["in_maxs_ge"], "retrieval": [], "remove_type": "abort"}, {"name": "maxs_lt_iff", "text": "Lemma maxs_lt_iff (ns : list nat) : forall z, maxs ns > z <-> exists i, In i ns /\\ i > z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "maxs_ind", "text": "Lemma maxs_ind (phi : nat -> Prop) (ns : list nat) (phi_dec : forall i, {phi i} + {~ phi i}) (phi_in : forall i, phi i -> In i ns) : forall n, phi n -> maxs ns >= n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "maxs_app", "text": "Lemma maxs_app (ns1 : list nat) (ns2 : list nat) : maxs (ns1 ++ ns2) = max (maxs ns1) (maxs ns2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "in_maxs_ge", "text": "Lemma in_maxs_ge (ns : list nat) (n : nat) (H_IN : In n ns) : maxs ns >= n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "positive_even", "text": "Lemma positive_even (n_even : nat) n : (n_even = 2 * n + 2)%nat <-> (n = (n_even - 2) / 2 /\\ n_even mod 2 = 0 /\\ n_even > 0)%nat.", "decomposition": ["mod_add", "div_mod_inv"], "retrieval": [], "remove_type": "abort"}, {"name": "positive_odd", "text": "Lemma positive_odd (n_odd : nat) n : (n_odd = 2 * n + 1)%nat <-> (n = (n_odd - 1) / 2 /\\ n_odd mod 2 = 1 /\\ n_odd > 0)%nat.", "decomposition": ["div_mod_inv"], "retrieval": [], "remove_type": "abort"}, {"name": "plus_a_b_divmod_b", "text": "Lemma plus_a_b_divmod_b a b (b_ne_0 : b <> 0) : ((a + b) / b = (a / b) + 1)%nat /\\ ((a + b) mod b = a mod b)%nat.", "decomposition": ["div_mod_uniqueness"], "retrieval": [], "remove_type": "abort"}, {"name": "mod_add", "text": "Lemma mod_add (a : nat) (b : nat) (c : nat) (c_ne_0 : c <> 0) : (a + b * c) mod c = a mod c.", "decomposition": ["mod_congruence_r"], "retrieval": [], "remove_type": "abort"}, {"name": "mod_eq_elim", "text": "Lemma mod_eq_elim (a1 : nat) (a2 : nat) (b : nat) (b_ne_0 : b <> 0) (H_mod_eq : a1 mod b = a2 mod b) : exists q1, exists q2, a1 + b * q1 = a2 + b * q2.", "decomposition": ["n_mod_b_le_n"], "retrieval": [], "remove_type": "abort"}, {"name": "n_mod_b_le_n", "text": "Lemma n_mod_b_le_n (n : nat) (b : nat) (b_ne_0 : b <> 0) : n mod b <= n.", "decomposition": ["mod_congruence_r"], "retrieval": [], "remove_type": "abort"}, {"name": "mod_eq_intro", "text": "Corollary mod_eq_intro (a1 : nat) (a2 : nat) (b : nat) q1 q2 (b_ne_0 : b <> 0) (a_b_q : a1 + b * q1 = a2 + b * q2) : a1 mod b = a2 mod b.", "decomposition": ["mod_congruence_r"], "retrieval": [], "remove_type": "abort"}, {"name": "mod_congruence_r", "text": "Theorem mod_congruence_r (a : nat) (b : nat) (q : nat) (r : nat) (b_ne_0 : b <> 0) (a_b_q_r : a = b * q + r) : a mod b = r mod b.", "decomposition": ["div_mod_inv"], "retrieval": [], "remove_type": "abort"}, {"name": "sqrt2irrat", "text": "Theorem sqrt2irrat (p : nat) (q : nat) : (p = 0 /\\ q = 0) <-> (p * p = 2 * q * q).", "decomposition": ["div_mod_uniqueness"], "retrieval": [], "remove_type": "abort"}, {"name": "div_mod_inv", "text": "Theorem div_mod_inv a b q r (b_ne_0 : b <> 0) : (a = b * q + r /\\ r < b)%nat <-> (q = (a - r) / b /\\ r = a mod b /\\ a >= r)%nat.", "decomposition": ["greater_than_iff"], "retrieval": [], "remove_type": "abort"}, {"name": "div_mod_uniqueness", "text": "Lemma div_mod_uniqueness a b q r (H_DIVISION : a = b * q + r) (r_lt_b : r < b) : (a / b = q /\\ a mod b = r)%nat.", "decomposition": ["greater_than_iff"], "retrieval": [], "remove_type": "abort"}, {"name": "cpInv_inj2", "text": "Corollary cpInv_inj2 {x1 : nat} {x2 : nat} {y1 : nat} {y2 : nat} (EQ : cpInv x1 y1 = cpInv x2 y2) : y1 = y2.", "decomposition": ["cpInv_inj"], "retrieval": [], "remove_type": "abort"}, {"name": "cpInv_inj1", "text": "Corollary cpInv_inj1 {x1 : nat} {x2 : nat} {y1 : nat} {y2 : nat} (EQ : cpInv x1 y1 = cpInv x2 y2) : x1 = x2.", "decomposition": ["cpInv_inj"], "retrieval": [], "remove_type": "abort"}, {"name": "cpInv_inj", "text": "Lemma cpInv_inj (x1 : nat) (x2 : nat) (y1 : nat) (y2 : nat) (EQ : cpInv x1 y1 = cpInv x2 y2) : x1 = x2 /\\ y1 = y2.", "decomposition": ["cp_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "snd_cp_le", "text": "Lemma snd_cp_le (n : nat) : snd (cp n) <= n.", "decomposition": ["cp_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "fst_cp_le", "text": "Lemma fst_cp_le (n : nat) : fst (cp n) <= n.", "decomposition": ["cp_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "cp_spec", "text": "Theorem cp_spec (n : nat) (x : nat) (y : nat) : cp n = (x, y) <-> n = cpInv x y.", "decomposition": ["cpInv_leftInv", "cpInv_rightInv"], "retrieval": [], "remove_type": "abort"}, {"name": "cpInv_rightInv", "text": "Lemma cpInv_rightInv (x : nat) (y : nat) : cp (cpInv x y) = (x, y).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "cpInv_leftInv", "text": "Lemma cpInv_leftInv (n : nat) : cpInv (fst (cp n)) (snd (cp n)) = n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sum_from_0_to_spec", "text": "Lemma sum_from_0_to_spec (n : nat) : 2 * sum_from_0_to n = n * (S n).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "greater_than_iff", "text": "Lemma greater_than_iff (x : nat) (y : nat) : x > y <-> (exists z : nat, x = S (y + z)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "le_pirrel", "text": "Theorem le_pirrel (n : nat) (m : nat) (H_le1 : n <= m) (H_le2 : n <= m) : H_le1 = H_le2.", "decomposition": ["le_case_lt", "le_case_eq"], "retrieval": [], "remove_type": "abort"}, {"name": "le_case_lt", "text": "Lemma le_case_lt {n : nat} {m : nat} (H_le : m <= n) (phi : m <= S n -> Prop) (phi_lt: forall H_le' : m <= n, phi (@le_S m n H_le')) : forall H_lt : m <= S n, phi H_lt.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "le_case_eq", "text": "Lemma le_case_eq {n : nat} (phi : n <= n -> Prop) (phi_eq : phi (@le_n n)) : forall H_le : n <= n, phi H_le.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Data/Vector.v": [{"name": "to_list_rev", "text": "Lemma to_list_rev {A : Type} {n : nat} (xs : Vector.t A n) : to_list (rev xs) = L.rev (to_list xs).", "decomposition": ["to_list_snoc"], "retrieval": [], "remove_type": "abort"}, {"name": "to_list_snoc", "text": "Lemma to_list_snoc {A : Type} {n : nat} (xs : Vector.t A n) (x : A) : to_list (snoc xs x) = L.app (to_list xs) (L.cons x L.nil).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "heq_congruence", "text": "Theorem heq_congruence (P : forall n : nat, Vector.t A n -> Prop) (n : nat) (n' : nat) (xs : Vector.t A n) (xs' : Vector.t A n') (HEQ : xs =~= xs') : P n xs <-> P n' xs'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "heq_iff", "text": "Lemma heq_iff (n : nat) (m : nat) (xs : Vector.t A n) (xs' : Vector.t A m) : xs =~= xs' <-> to_list xs = to_list xs'.", "decomposition": ["heq_trans", "heq_sym", "from_list_to_list"], "retrieval": [], "remove_type": "abort"}, {"name": "heq_trans", "text": "Lemma heq_trans (n1 : nat) (n2 : nat) (n3 : nat) (xs1 : Vector.t A n1) (xs2 : Vector.t A n2) (xs3 : Vector.t A n3) (EQ : xs1 =~= xs2) (EQ' : xs2 =~= xs3) : xs1 =~= xs3.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "heq_sym", "text": "Lemma heq_sym (n1 : nat) (n2 : nat) (xs1 : Vector.t A n1) (xs2 : Vector.t A n2) (EQ : xs1 =~= xs2) : xs2 =~= xs1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "heq_refl", "text": "Lemma heq_refl (n1 : nat) (xs1 : Vector.t A n1) : xs1 =~= xs1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "from_list_to_list", "text": "Lemma from_list_to_list (n : nat) (xs : Vector.t A n) : from_list (to_list xs) =~= xs.", "decomposition": ["to_list_from_list"], "retrieval": [], "remove_type": "abort"}, {"name": "to_list_from_list", "text": "Lemma to_list_from_list (xs : list A) : to_list (from_list xs) = xs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "to_list_inj", "text": "Lemma to_list_inj {n : nat} (xs1 : Vector.t A n) (xs2 : Vector.t A n) (EXT_EQ : to_list xs1 = to_list xs2) : xs1 = xs2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "gen_nat_vec_linv_left_inverse", "text": "Lemma gen_nat_vec_linv_left_inverse n (xs : Vector.t nat n) : gen_nat_vec n (gen_nat_vec_linv xs) = xs.", "decomposition": ["cp_spec", "cpInv_inj"], "retrieval": [], "remove_type": "abort"}, {"name": "zipWith_spec", "text": "Lemma zipWith_spec {n : nat} {A : Type} {B : Type} {C : Type} (f : A -> B -> C) (xs : Vector.t A n) (ys : Vector.t B n) : forall i, f (xs !! i) (ys !! i) = zipWith f xs ys !! i.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "diagonal_spec", "text": "Lemma diagonal_spec {A : Type} {n : nat} (xss: Vector.t (Vector.t A n) n) : forall i : Fin.t n, xss !! i !! i = diagonal xss !! i.", "decomposition": ["caseS", "map_spec", "nth_unfold", "case0"], "retrieval": [], "remove_type": "admit"}, {"name": "replicate_spec", "text": "Lemma replicate_spec {A : Type} {n : nat} (x: A) : forall i : Fin.t n, x = replicate x !! i.", "decomposition": ["caseS", "case0"], "retrieval": [], "remove_type": "admit"}, {"name": "map_spec", "text": "Lemma map_spec {A : Type} {B : Type} {n : nat} (f : A -> B) (xs : Vector.t A n) : forall i : Fin.t n, f (xs !! i) = map f xs !! i.", "decomposition": ["caseS", "case0"], "retrieval": [], "remove_type": "admit"}, {"name": "vec_ext_eq", "text": "Theorem vec_ext_eq {A : Type} {n : nat} (lhs : Vector.t A n) (rhs : Vector.t A n) : lhs = rhs <-> forall i, lhs !! i = rhs !! i.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "nth_unfold", "text": "Lemma nth_unfold {A : Type} {n : nat} (xs : Vector.t A n) (i : Fin.t n) : xs !! i = (match i in Fin.t m return Vector.t A m -> A with FZ => fun v => head v | FS i' => fun v => tail v !! i' end) xs.", "decomposition": ["caseS", "case0"], "retrieval": [], "remove_type": "abort"}, {"name": "caseS", "text": "Lemma caseS {n' : nat} (phi : vec (S n') -> Type) (phiVCons: forall x' : A, forall xs' : vec n', phi (x' :: xs')) : forall xs, phi xs.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "case0", "text": "Lemma case0 (phi : vec O -> Type) (phiVNil : phi []) : forall xs, phi xs.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "incrFin_spec", "text": "Lemma incrFin_spec {m : nat} (n : nat) (i : Fin.t m) : evalFin (incrFin n i) = n + evalFin i.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "evalFin_inj", "text": "Lemma evalFin_inj {n : nat} (i1 : Fin.t n) (i2 : Fin.t n) (hyp_eq : evalFin i1 = evalFin i2) : i1 = i2.", "decomposition": ["le_pirrel", "getFin_runFin_id"], "retrieval": [], "remove_type": "abort"}, {"name": "getFin_runFin_id", "text": "Lemma getFin_runFin_id {n : nat} (i : Fin.t n) : getFin (proj1_sig (runFin i)) (proj2_sig (runFin i)) = i.", "decomposition": ["le_pirrel"], "retrieval": [], "remove_type": "abort"}, {"name": "runFin_getFin_id", "text": "Lemma runFin_getFin_id {m : nat} {n : nat} (hyp_lt : m < n) : runFin (getFin m hyp_lt) = exist (gt n) m hyp_lt.", "decomposition": ["le_pirrel"], "retrieval": [], "remove_type": "abort"}]}, "5f260864e53f75569f7df5b7b10f2b870d4f58bd": {}, "9a6cab82964429b1900fee20a144afd733cead76": {}, "f43a991c1a004d5a08974973c4dbbfa9d0d2778f": {}, "9ebe92e721a13c6a742cc1bad884a6a5ec78bbe9": {}, "3a2ad392e465772f4709346809f8310fedc488f0": {}, "68863be5b7adbeecfefb7e457e321563ab997da3": {"theories/Logic/ClassicalPropositionalLogic.v": [{"name": "the_propositional_compactness_theorem", "text": "Corollary the_propositional_compactness_theorem (Gamma : ensemble formula) (C : formula) : Gamma \u22a8 C <-> << FINITE_ENTAILS : exists xs, exists X, L.is_finsubset_of xs Gamma /\\ L.is_listrep_of xs X /\\ X \u22a8 C >>.", "decomposition": ["the_propositional_soundness_theorem", "the_propositional_completeness_theorem"], "retrieval": ["inference_is_finite", "extend_entails"], "remove_type": "abort"}, {"name": "the_propositional_completeness_theorem", "text": "Theorem the_propositional_completeness_theorem (Gamma : ensemble formula) (C : formula) (ENTAILS : Gamma \u22a8 C) : Gamma \u22a2 C.", "decomposition": ["hasModel_ifConsistent"], "retrieval": ["isFilter_compatWith_eqProp", "theorem_of_1_3_10", "completeness_theorem_prototype", "lemma1_of_1_3_8"], "remove_type": "abort"}, {"name": "hasModel_ifConsistent", "text": "Lemma hasModel_ifConsistent (X : ensemble formula) (CONSISTENT : X \u22ac ContradictionF) : X \\subseteq MaximalConsistentSet X /\\ is_structure (MaximalConsistentSet X).", "decomposition": [], "retrieval": ["cl_isSubsetOf_Th", "extend_infers", "theorem_of_1_3_10", "inconsistent_cl_iff", "Th_isSubsetOf_cl", "filters_is_inconsistent_iff", "cl_eq_Th", "lemma1_of_1_3_8"], "remove_type": "abort"}, {"name": "the_propositional_soundness_theorem", "text": "Theorem the_propositional_soundness_theorem (X : ensemble formula) (b : formula) (INFERS : X \u22a2 b) : X \u22a8 b.", "decomposition": ["DisjunctionI1_preserves", "NegationE_preserves", "ByAssumption_preserves", "BiconditionalE2_preserves", "ConjunctionI_preserves", "ImplicationI_preserves", "ImplicationE_preserves", "NegationI_preserves", "ContradictionI_preserves", "BiconditionalE1_preserves", "ConjunctionE1_preserves", "BiconditionalI_preserves", "ContradictionE_preserves", "DisjunctionI2_preserves", "DisjunctionE_preserves", "ConjunctionE2_preserves"], "retrieval": [], "remove_type": "abort"}, {"name": "BiconditionalE2_preserves", "text": "Lemma BiconditionalE2_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 BiconditionalF A B) (ENTAILS2 : Gamma \u22a8 B) : Gamma \u22a8 A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "BiconditionalE1_preserves", "text": "Lemma BiconditionalE1_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 BiconditionalF A B) (ENTAILS2 : Gamma \u22a8 A) : Gamma \u22a8 B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "BiconditionalI_preserves", "text": "Lemma BiconditionalI_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : E.insert A Gamma \u22a8 B) (ENTAILS2 : E.insert B Gamma \u22a8 A) : Gamma \u22a8 BiconditionalF A B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ImplicationE_preserves", "text": "Lemma ImplicationE_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 ImplicationF A B) (ENTAILS2 : Gamma \u22a8 A) : Gamma \u22a8 B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ImplicationI_preserves", "text": "Lemma ImplicationI_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : E.insert A Gamma \u22a8 B) : Gamma \u22a8 ImplicationF A B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "DisjunctionE_preserves", "text": "Lemma DisjunctionE_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (C : formula) (ENTAILS1 : Gamma \u22a8 DisjunctionF A B) (ENTAILS2 : E.insert A Gamma \u22a8 C) (ENTAILS3 : E.insert B Gamma \u22a8 C) : Gamma \u22a8 C.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "DisjunctionI2_preserves", "text": "Lemma DisjunctionI2_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 B) : Gamma \u22a8 DisjunctionF A B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "DisjunctionI1_preserves", "text": "Lemma DisjunctionI1_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 A) : Gamma \u22a8 DisjunctionF A B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ConjunctionE2_preserves", "text": "Lemma ConjunctionE2_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 ConjunctionF A B) : Gamma \u22a8 B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ConjunctionE1_preserves", "text": "Lemma ConjunctionE1_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 ConjunctionF A B) : Gamma \u22a8 A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ConjunctionI_preserves", "text": "Lemma ConjunctionI_preserves (Gamma : ensemble formula) (A : formula) (B : formula) (ENTAILS1 : Gamma \u22a8 A) (ENTAILS2 : Gamma \u22a8 B) : Gamma \u22a8 ConjunctionF A B.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "NegationE_preserves", "text": "Lemma NegationE_preserves (Gamma : ensemble formula) (A : formula) (ENTAILS1 : E.insert (NegationF A) Gamma \u22a8 ContradictionF) : Gamma \u22a8 A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "NegationI_preserves", "text": "Lemma NegationI_preserves (Gamma : ensemble formula) (A : formula) (ENTAILS1 : E.insert A Gamma \u22a8 ContradictionF) : Gamma \u22a8 NegationF A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ContradictionE_preserves", "text": "Lemma ContradictionE_preserves (Gamma : ensemble formula) (A : formula) (ENTAILS1 : Gamma \u22a8 ContradictionF) : Gamma \u22a8 A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ContradictionI_preserves", "text": "Lemma ContradictionI_preserves (Gamma : ensemble formula) (A : formula) (ENTAILS1 : Gamma \u22a8 A) (ENTAILS2 : Gamma \u22a8 NegationF A) : Gamma \u22a8 ContradictionF.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ByAssumption_preserves", "text": "Lemma ByAssumption_preserves (Gamma : ensemble formula) (C : formula) (ELEM : C \\in Gamma) : Gamma \u22a8 C.", "decomposition": [], "retrieval": ["extend_entails"], "remove_type": "abort"}]}, "3d264dcd8aad2c595d71bd332d80d418207dda07": {}, "696724115506bc17bfbef83d206d00bad2ab1d48": {}, "95108cdb88eaef0c06964d14b39a22a32d6331d7": {}, "e09ee009ae7a2490a906788cb85361c33ac33797": {}, "f5c6cf773b211d15490c6b5d9d8e8171128d3f60": {}, "ecd2e12f3ede6ddd787cfd7d3ae155b6477d6929": {}, "38c6e3f3722c35179603d39e32aa9d1a677fae59": {"theories/Logic/BasicFol2.v": [{"name": "frm_corr_twilight_frm'", "text": "Lemma frm_corr_twilight_frm' (p' : frm L') : frm_corr (twilight_frm' p') p'.", "decomposition": ["twilight_trm_decomposition", "twilight_trm_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "frm_corr_unique", "text": "Lemma frm_corr_unique (p' : frm L') (p1 : frm L) (p2 : frm L) (SIM1 : frm_corr p1 p') (SIM2 : frm_corr p2 p') : p1 = p2.", "decomposition": ["embed_frm_inj"], "retrieval": [], "remove_type": "abort"}, {"name": "unembed_frm_one_subst", "text": "Lemma unembed_frm_one_subst x t p (t_HC_free : forall c, HC_occurs_in_trm c t = false) (p_HC_free : forall c, HC_occurs_in_frm c p = false) : unembed_frm (subst_frm (one_subst x t) p) = subst_frm (one_subst x (unembed_trm t)) (unembed_frm p).", "decomposition": ["unembed_trm_fvs", "unembed_frm_subst"], "retrieval": ["equiv_subst_in_frm_implies_subst_frm_same"], "remove_type": "abort"}, {"name": "unembed_frm_subst", "text": "Lemma unembed_frm_subst s (p : frm L') (s_HC_free : forall z, forall u, is_free_in_trm z (unembed_trm (s u)) = is_free_in_trm z (s u)) (HC_free : forall c, HC_occurs_in_frm c p = false) : unembed_frm (subst_frm s p) = subst_frm (unembed_trm \u2218 s)%prg (unembed_frm p).", "decomposition": ["unembed_frm_fvs", "embed_fvs_trm", "unembed_trm_subst", "unembed_chi_frm"], "retrieval": ["equiv_subst_in_frm_implies_subst_frm_same", "fv_is_free_in_trm", "maxs_ext", "fv_is_free_in_frm", "chi_frm_ext"], "remove_type": "abort"}, {"name": "unembed_trm_subst", "text": "Lemma unembed_trm_subst s (t : trm L') (HC_free : forall c, HC_occurs_in_trm c t = false) : unembed_trm (subst_trm s t) = subst_trm (unembed_trm \u2218 s)%prg (unembed_trm t) with unembed_trms_subst n s (ts : trms L' n) (HC_free : forall c, HC_occurs_in_trms c ts = false) : unembed_trms (subst_trms s ts) = subst_trms (unembed_trm \u2218 s)%prg (unembed_trms ts).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unembed_chi_frm", "text": "Lemma unembed_chi_frm s (p : frm L') (HC_free : forall c, HC_occurs_in_frm c p = false) : chi_frm (embed_trm \u2218 s)%prg p = chi_frm s (unembed_frm p).", "decomposition": ["unembed_frm_fvs", "embed_fvs_trm"], "retrieval": ["fv_is_free_in_trm", "maxs_ext", "fv_is_free_in_frm"], "remove_type": "abort"}, {"name": "unembed_frm_fvs", "text": "Lemma unembed_frm_fvs z (p : frm L') (HC_free : forall c, HC_occurs_in_frm c p = false) : is_free_in_frm z p = is_free_in_frm z (unembed_frm p).", "decomposition": ["unembed_trm_fvs"], "retrieval": [], "remove_type": "abort"}, {"name": "unembed_trm_fvs", "text": "Lemma unembed_trm_fvs z (t : trm L') (HC_free : forall c, HC_occurs_in_trm c t = false) : is_free_in_trm z t = is_free_in_trm z (unembed_trm t) with unembed_trms_fvs n z (ts : trms L' n) (HC_free : forall c, HC_occurs_in_trms c ts = false) : is_free_in_trms z ts = is_free_in_trms z (unembed_trms ts).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unembed_frm_lemma", "text": "Lemma unembed_frm_lemma (p : frm L) : unembed_frm (embed_frm p) = p.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unembed_trm_lemma", "text": "Lemma unembed_trm_lemma (t : trm L) : unembed_trm (embed_trm t) = t with unembed_trms_lemma n (ts : trms L n) : unembed_trms (embed_trms ts) = ts.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "unembed_trms_unfold", "text": "Lemma unembed_trms_unfold n (ts : trms L' n) : unembed_trms ts = match ts with | O_trms => @O_trms L | S_trms n t ts => @S_trms L n (unembed_trm t) (unembed_trms ts) end.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unembed_trm_unfold", "text": "Lemma unembed_trm_unfold (t : trm L') : unembed_trm t = match t with | Var_trm x => @Var_trm L x | Fun_trm f ts => @Fun_trm L f (unembed_trms ts) | Con_trm c => match c with | inl cc => @Con_trm L cc | inr hc => @Var_trm L hc end end.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "twilight_frm'_embed", "text": "Lemma twilight_frm'_embed (p : frm L) : twilight_frm' (embed_frm p) \u2261 subst_frm (fun z : ivar => Var_trm (z * 2)) p.", "decomposition": ["embed_frm_alpha", "embed_frm_HC_free", "twilight_frm_decomposition", "twilight_frm_spec", "embed_subst_frm"], "retrieval": ["in_accum_hatom_in_frm_iff_HC_occurs_in_frm", "occurs_free_in_frm_iff", "subst_hsubst_compat_in_frm", "alpha_equiv_eq_intro", "equiv_hsubst_in_frm_implies_hsubst_frm_same"], "remove_type": "abort"}, {"name": "twilight_frm_decomposition", "text": "Lemma twilight_frm_decomposition (p : frm L') : twilight_frm p = embed_frm (twilight_frm' p).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "twilight_trm_decomposition", "text": "Lemma twilight_trm_decomposition (t : trm L') : twilight_trm t = embed_trm (twilight_trm' t) with twilight_trms_decomposition n (ts : trms L' n) : twilight_trms ts = embed_trms (twilight_trms' ts).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "embed_frm_alpha", "text": "Lemma embed_frm_alpha p1 p2 : p1 \u2261 p2 <-> embed_frm p1 \u2261 embed_frm p2.", "decomposition": ["embed_fvs_frm", "embed_frm_inj", "embed_subst_frm"], "retrieval": ["equiv_subst_in_frm_implies_subst_frm_same", "alpha_equiv_eq_intro"], "remove_type": "abort"}, {"name": "embed_frm_inv", "text": "Lemma embed_frm_inv (p' : frm L') (HC_free : forall c, HC_occurs_in_frm c p' = false) : exists p, embed_frm p = p'.", "decomposition": ["embed_trm_inv"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_inv", "text": "Lemma embed_trm_inv (t' : trm L') (HC_free : forall c, HC_occurs_in_trm c t' = false) : exists t, embed_trm t = t' with embed_trms_inv (n : nat) (ts' : trms L' n) (HC_free : forall c, HC_occurs_in_trms c ts' = false) : exists ts, embed_trms ts = ts'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "embed_frm_HC_free", "text": "Lemma embed_frm_HC_free (p : frm L) : forall c : Henkin_constants, HC_occurs_in_frm c (embed_frm p) = false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_HC_free", "text": "Lemma embed_trm_HC_free (t : trm L) : forall c : Henkin_constants, HC_occurs_in_trm c (embed_trm t) = false with embed_trms_HC_free n (ts : trms L n) : forall c : Henkin_constants, HC_occurs_in_trms c (embed_trms ts) = false.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "embed_subst_frm", "text": "Lemma embed_subst_frm (s : subst L) (p : frm L) : embed_frm (subst_frm s p) = subst_frm (embed_trm \u2218 s)%prg (embed_frm p).", "decomposition": ["embed_chi_frm"], "retrieval": ["equiv_subst_in_frm_implies_subst_frm_same"], "remove_type": "abort"}, {"name": "embed_chi_frm", "text": "Lemma embed_chi_frm (s : subst L) (p : frm L) : chi_frm s p = chi_frm (embed_trm \u2218 s)%prg (embed_frm p).", "decomposition": ["embed_fvs_trm"], "retrieval": ["fv_is_free_in_trm", "maxs_ext"], "remove_type": "admit"}, {"name": "embed_subst_trm", "text": "Lemma embed_subst_trm (s : subst L) (t : trm L) : embed_trm (subst_trm s t) = subst_trm (embed_trm \u2218 s)%prg (embed_trm t) with embed_subst_trms n (s : subst L) (ts : trms L n) : embed_trms (subst_trms s ts) = subst_trms (embed_trm \u2218 s)%prg (embed_trms ts).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "embed_fvs_frm", "text": "Lemma embed_fvs_frm (p : frm L) : forall z, is_free_in_frm z (embed_frm p) = is_free_in_frm z p.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "embed_fvs_trm", "text": "Lemma embed_fvs_trm (t : trm L) : forall z, is_free_in_trm z (embed_trm t) = is_free_in_trm z t with embed_fvs_trms n (ts : trms L n) : forall z, is_free_in_trms z (embed_trms ts) = is_free_in_trms z ts.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "embed_frm_inj", "text": "Theorem embed_frm_inj (p1 : frm L) (p2 : frm L) (EQ : embed_frm p1 = embed_frm p2) : p1 = p2.", "decomposition": ["embed_frm_inj_aux", "embed_frm_graph_complete", "embed_frm_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trms_inj", "text": "Theorem embed_trms_inj n (ts1 : trms L n) (ts2 : trms L n) (EQ : embed_trms ts1 = embed_trms ts2) : ts1 = ts2.", "decomposition": ["embed_trms_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_inj", "text": "Theorem embed_trm_inj (t1 : trm L) (t2 : trm L) (EQ : embed_trm t1 = embed_trm t2) : t1 = t2.", "decomposition": ["embed_trm_inj_aux", "embed_trm_graph_complete", "embed_trm_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_frm_inj_aux", "text": "Lemma embed_frm_inj_aux (p : frm L) p' (GRAPH : embed_frm_graph (embed_frm p') p) : p' = p.", "decomposition": ["embed_trm_inj_aux"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_inj_aux", "text": "Lemma embed_trm_inj_aux (t : trm L) t' (GRAPH : embed_trm_graph (embed_trm t') t) : t' = t with embed_trms_inj_aux n (ts : trms L n) ts' (GRAPH : embed_trms_graph (embed_trms ts') ts) : ts' = ts.", "decomposition": [], "retrieval": ["trms_caseS"], "remove_type": "abort"}, {"name": "embed_frm_graph_complete", "text": "Lemma embed_frm_graph_complete (p : frm L) p' (SIM : p =~= p') : embed_frm_graph p' p.", "decomposition": ["embed_trm_graph_complete"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_frm_graph_sound", "text": "Lemma embed_frm_graph_sound (p : frm L) p' (GRAPH : embed_frm_graph p' p) : p =~= p'.", "decomposition": ["embed_trm_graph_sound"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_graph_complete", "text": "Lemma embed_trm_graph_complete (t : trm L) t' (SIM : t =~= t') : embed_trm_graph t' t with embed_trms_graph_complete n (ts : trms L n) ts' (SIM : ts =~= ts') : embed_trms_graph ts' ts.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_graph_sound", "text": "Lemma embed_trm_graph_sound t' (t : trm L) (GRAPH : embed_trm_graph t' t) : t =~= t' with embed_trms_graph_sound n ts' (ts : trms L n) (GRAPH : embed_trms_graph ts' ts) : ts =~= ts'.", "decomposition": [], "retrieval": ["trms_caseS"], "remove_type": "abort"}, {"name": "embed_frms_spec", "text": "Theorem embed_frms_spec (Gamma : ensemble (frm L)) (Gamma' : ensemble (frm L')) : E.image embed_frm Gamma == Gamma' <-> Gamma =~= Gamma'.", "decomposition": ["embed_frm_from", "embed_frm_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_frm_spec", "text": "Theorem embed_frm_spec (p : frm L) (p' : frm L') : embed_frm p = p' <-> p =~= p'.", "decomposition": ["embed_frm_from", "embed_frm_to"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trms_spec", "text": "Theorem embed_trms_spec n (ts : trms L n) (ts' : trms L' n) : embed_trms ts = ts' <-> ts =~= ts'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_spec", "text": "Theorem embed_trm_spec (t : trm L) (t' : trm L') : embed_trm t = t' <-> t =~= t'.", "decomposition": ["embed_trm_from", "embed_trm_to"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_frm_to", "text": "Lemma embed_frm_to (p : frm L) (p' : frm L') (SIM : p =~= p') : embed_frm p = p'.", "decomposition": ["embed_trm_to"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_frm_from", "text": "Lemma embed_frm_from (p : frm L) : p =~= embed_frm p.", "decomposition": ["embed_trm_from"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_to", "text": "Lemma embed_trm_to (t : trm L) (t' : trm L') (SIM : t =~= t') : embed_trm t = t' with embed_trms_to n (ts : trms L n) (ts' : trms L' n) (SIM : ts =~= ts') : embed_trms ts = ts'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "embed_trm_from", "text": "Lemma embed_trm_from (t : trm L) : t =~= embed_trm t with embed_trms_from n (ts : trms L n) : ts =~= embed_trms ts.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "twilight_frm_one_hsubst", "text": "Lemma twilight_frm_one_hsubst (x : ivar) (t : trm L') (p : frm L') : twilight_frm (hsubst_frm (one_hsubst (inl x) t) p) \u2261 subst_frm (one_subst (2 * x) (twilight_trm t)) (twilight_frm p).", "decomposition": ["twilight_trm_spec", "twilight_frm_spec"], "retrieval": ["alpha_equiv_eq_intro", "eqb_spec", "subst_hsubst_compat_in_frm", "hsubst_compose_frm_spec", "equiv_hsubst_in_frm_implies_hsubst_frm_same"], "remove_type": "abort"}, {"name": "twilight_frm_spec", "text": "Lemma twilight_frm_spec (p : frm L') : twilight_frm p \u2261 hsubst_frm (fun z : hatom => match z with inl x => Var_trm (x * 2) | inr hc => Var_trm (hc * 2 + 1) end) p.", "decomposition": [], "retrieval": ["hchi_frm_not_free", "eqb_neq", "frm_is_fresh_in_hsubst_iff", "alpha_equiv_eq_intro", "subst_nil_frm", "subst_hsubst_compat_in_frm", "subst_hsubst_compat_in_trm", "eqb_eq", "hsubst_compose_frm_spec", "equiv_hsubst_in_frm_implies_hsubst_frm_same", "subst_nil_trm"], "remove_type": "abort"}, {"name": "twilight_trm_spec", "text": "Lemma twilight_trm_spec (t : trm L') : twilight_trm t = hsubst_trm (fun z : hatom => match z with inl x => Var_trm (x * 2) | inr hc => Var_trm (hc * 2 + 1) end) t with twilight_trms_spec n (ts : trms L' n) : twilight_trms ts = hsubst_trms (fun z : hatom => match z with inl x => Var_trm (x * 2) | inr hc => Var_trm (hc * 2 + 1) end) ts.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "untwilight_frm", "text": "Lemma untwilight_frm (p : frm L') (HENKIN_FREE : forall c, HC_occurs_in_frm c p = false) : twilight_frm p \u2261 subst_frm (fun z : ivar => Var_trm (z * 2)) p.", "decomposition": ["untwilight_trm"], "retrieval": ["subst_compose_frm_spec", "eqb_neq", "chi_frm_not_free", "equiv_subst_in_frm_implies_subst_frm_same", "alpha_equiv_eq_intro", "frm_is_fresh_in_subst_iff"], "remove_type": "abort"}, {"name": "untwilight_trm", "text": "Lemma untwilight_trm (t : trm L') (HENKIN_FREE : forall c, HC_occurs_in_trm c t = false) : twilight_trm t = subst_trm (fun z : ivar => Var_trm (z * 2)) t with untwilight_trms n (ts : trms L' n) (HENKIN_FREE : forall c, HC_occurs_in_trms c ts = false) : twilight_trms ts = subst_trms (fun z : ivar => Var_trm (z * 2)) ts.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Logic/HilbertFol2.v": [{"name": "similar_equiconsistent", "text": "Theorem similar_equiconsistent (Gamma : ensemble (frm L)) (Gamma' : ensemble (frm L')) (SIM : Gamma =~= Gamma') : inconsistent Gamma <-> inconsistent Gamma'.", "decomposition": ["embed_proves_inv", "embed_frms_spec", "embed_proves", "inconsistent_iff"], "retrieval": [], "remove_type": "abort"}, {"name": "embed_proves_inv", "text": "Lemma embed_proves_inv (Gamma : ensemble (frm L)) (p : frm L) (PROVE : E.image embed_frm Gamma \u22a2 embed_frm p) : Gamma \u22a2 p.", "decomposition": ["embed_frm_alpha", "twilight_frm_decomposition", "embed_frm_Fun_eqAxm", "embed_fvs_frm", "twilight_trm_decomposition", "twilight_frm_one_hsubst", "embed_subst_frm", "embed_frm_Rel_eqAxm", "twilight_frm'_embed", "frm_corr_twilight_frm'", "embed_frm_inj"], "retrieval": ["eqb_spec", "Deduction_theorem", "for_ByHyp", "for_Imp_I", "subst_compose_frm_spec", "proves_symmetry", "proves_reflexivity", "alpha_equiv_eq_intro", "div_mod_uniqueness", "extend_proves", "for_Imp_E", "equiv_hsubst_in_frm_implies_hsubst_frm_same", "twilight_frm_fvs", "equiv_subst_in_frm_implies_subst_frm_same", "for_All_I", "subst_nil_frm", "proves_transitivity", "proves_substitutivity", "subst_hsubst_compat_in_frm"], "remove_type": "abort"}, {"name": "embed_proves", "text": "Lemma embed_proves (Gamma : ensemble (frm L)) (p : frm L) (PROVE : Gamma \u22a2 p) : E.image embed_frm Gamma \u22a2 embed_frm p.", "decomposition": ["embed_frm_Rel_eqAxm", "embed_fvs_frm", "embed_frm_Fun_eqAxm", "embed_subst_frm"], "retrieval": ["for_ByHyp", "for_Imp_I", "Deduction_theorem", "equiv_subst_in_frm_implies_subst_frm_same", "in_image_iff", "extend_proves", "proves_symmetry", "for_All_I", "proves_reflexivity", "proves_transitivity", "for_Imp_E"], "remove_type": "abort"}, {"name": "embed_frm_Rel_eqAxm", "text": "Lemma embed_frm_Rel_eqAxm (R : L.(relation_symbols)) : embed_frm (@Rel_eqAxm L R) = @Rel_eqAxm L' R.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "embed_frm_Fun_eqAxm", "text": "Lemma embed_frm_Fun_eqAxm (f : L.(function_symbols)) : embed_frm (@Fun_eqAxm L f) = @Fun_eqAxm L' f.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "proves_hsubstitutivity", "text": "Lemma proves_hsubstitutivity (sigma : hsubst) (Gamma : ensemble (frm L')) (p : frm L') (PROVE : Gamma \u22a2 p) : E.image (hsubst_frm sigma) Gamma \u22a2 hsubst_frm sigma p.", "decomposition": ["proves_twilight"], "retrieval": ["in_image_iff", "proves_substitutivity", "twilight_frm_lemma"], "remove_type": "abort"}, {"name": "proves_twilight", "text": "Lemma proves_twilight (Gamma : ensemble (frm L')) (p : frm L') (PROVE : Gamma \u22a2 p) : E.image twilight_frm Gamma \u22a2 twilight_frm p.", "decomposition": ["twilight_Fun_eqAxm", "twilight_Rel_eqAxm", "twilight_frm_one_hsubst"], "retrieval": ["for_ByHyp", "for_Imp_I", "twilight_frm_fvs", "eqb_neq", "in_image_iff", "extend_proves", "proves_symmetry", "for_All_I", "proves_reflexivity", "proves_transitivity", "subst_hsubst_compat_in_frm", "for_Imp_E", "Deduction_theorem", "equiv_hsubst_in_frm_implies_hsubst_frm_same", "eqb_eq"], "remove_type": "abort"}, {"name": "twilight_Rel_eqAxm", "text": "Lemma twilight_Rel_eqAxm (R : L'.(relation_symbols)) : E.empty \u22a2 twilight_frm (Rel_eqAxm R).", "decomposition": ["Rel_eqAxm_HC_free", "untwilight_frm"], "retrieval": ["equiv_subst_in_frm_implies_subst_frm_same", "subst_frm_close_frm", "for_All_I", "for_Imp_E", "Rel_eqAxm_free_vars"], "remove_type": "abort"}, {"name": "twilight_Fun_eqAxm", "text": "Lemma twilight_Fun_eqAxm (f : L'.(function_symbols)) : E.empty \u22a2 twilight_frm (Fun_eqAxm f).", "decomposition": ["untwilight_frm", "Fun_eqAxm_HC_free"], "retrieval": ["equiv_subst_in_frm_implies_subst_frm_same", "subst_frm_close_frm", "for_All_I", "Fun_eqAxm_free_vars", "for_Imp_E"], "remove_type": "abort"}, {"name": "Rel_eqAxm_HC_free", "text": "Lemma Rel_eqAxm_HC_free (R : L'.(relation_symbols)) : forall c : Henkin_constants, HC_occurs_in_frm c (Rel_eqAxm R) = false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Fun_eqAxm_HC_free", "text": "Lemma Fun_eqAxm_HC_free (f : L'.(function_symbols)) : forall c : Henkin_constants, HC_occurs_in_frm c (Fun_eqAxm f) = false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inconsistent_iff", "text": "Lemma inconsistent_iff (Gamma : ensemble (frm L)) : inconsistent Gamma <-> (exists p, Gamma \u22a2 p /\\ Gamma \u22a2 Neg_frm p).", "decomposition": [], "retrieval": ["proof_ex_falso"], "remove_type": "abort"}], "theories/Logic/BasicFol.v": [{"name": "subst_frm_similarity", "text": "Lemma subst_frm_similarity (s : subst L) (s' : subst L') (p : frm L) (p' : frm L') (s_SIM : s =~= s') (p_SIM : p =~= p') : subst_frm s p =~= subst_frm s' p'.", "decomposition": [], "retrieval": ["chi_frm_similarity", "subst_trm_similiarity"], "remove_type": "abort"}, {"name": "subst_trm_similiarity", "text": "Lemma subst_trm_similiarity (s : subst L) (s' : subst L') (t : trm L) (t' : trm L') (s_SIM : s =~= s') (t_SIM : t =~= t') : subst_trm s t =~= subst_trm s' t' with subst_trms_similiarity n (s : subst L) (s' : subst L') (ts : trms L n) (ts' : trms L' n) (s_SIM : s =~= s') (ts_SIM : ts =~= ts') : subst_trms s ts =~= subst_trms s' ts'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "chi_frm_similarity", "text": "Lemma chi_frm_similarity (s : subst L) (s' : subst L') (p : frm L) (p' : frm L') (s_SIM : s =~= s') (p_SIM : p =~= p') : chi_frm s p = chi_frm s' p'.", "decomposition": [], "retrieval": ["fvs_trm_similarity", "maxs_app", "maxs_ext", "fvs_frm_similarity"], "remove_type": "abort"}, {"name": "fvs_frm_similarity", "text": "Lemma fvs_frm_similarity (p : frm L) (p' : frm L') (p_SIM : p =~= p') : fvs_frm p = fvs_frm p'.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "fvs_trm_similarity", "text": "Lemma fvs_trm_similarity (t : trm L) (t' : trm L') (t_SIM : t =~= t') : fvs_trm t = fvs_trm t' with fvs_trms_similarity n (ts : trms L n) (ts' : trms L' n) (ts_SIM : ts =~= ts') : fvs_trms ts = fvs_trms ts'.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "rename_frm_one_subst", "text": "Lemma rename_frm_one_subst (eta : renaming) (x : ivar) (t : trm L) (p : frm L) (eta_inj : exists eta' : renaming, forall z : ivar, is_free_in_frm z p = true \\/ z = x -> eta' (eta z) = z) : rename_frm eta (subst_frm (one_subst x t) p) = subst_frm (one_subst (eta x) (rename_trm eta t)) (rename_frm eta p).", "decomposition": ["rename_frm_subst"], "retrieval": ["subst_compose_frm_spec", "equiv_subst_in_frm_implies_subst_frm_same"], "remove_type": "abort"}, {"name": "rename_frm_subst", "text": "Lemma rename_frm_subst (s : subst L) (eta : renaming) (eta' : renaming) (p : frm L) (eta_inj : forall z : ivar, is_free_in_frm z p = true -> eta' (eta z) = z) : rename_frm eta (subst_frm s p) = subst_frm (rename_trm eta \u2218 s \u2218 eta')%prg (rename_frm eta p).", "decomposition": [], "retrieval": ["subst_compose_frm_spec", "equiv_subst_in_frm_implies_subst_frm_same"], "remove_type": "abort"}], "theories/Logic/HilbertFol.v": [{"name": "Rel_eqAxm_preserves_truth", "text": "Lemma Rel_eqAxm_preserves_truth (R : L.(relation_symbols)) (STRUCTURE : isStructureOf L) (env : ivar -> domain_of_discourse) : interpret_frm STRUCTURE env (Rel_eqAxm R).", "decomposition": [], "retrieval": ["nth_unfold"], "remove_type": "abort"}, {"name": "Fun_eqAxm_preserves_truth", "text": "Lemma Fun_eqAxm_preserves_truth (f : L.(function_symbols)) (STRUCTURE : isStructureOf L) (env : ivar -> domain_of_discourse) : interpret_frm STRUCTURE env (Fun_eqAxm f).", "decomposition": [], "retrieval": ["nth_unfold"], "remove_type": "abort"}, {"name": "MP_preserves_truth", "text": "Lemma MP_preserves_truth (p : frm L) (q : frm L) (ps1 : list (frm L)) (ps2 : list (frm L)) (Gamma : ensemble (frm L)) (ENTAILS1 : forall Gamma, E.fromList ps1 \\subseteq Gamma -> Gamma \u22a8 Imp_frm p q) (ENTAILS2 : forall Gamma, E.fromList ps2 \\subseteq Gamma -> Gamma \u22a8 p) (INCL : E.fromList (ps1 ++ ps2) \\subseteq Gamma) : Gamma \u22a8 q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Prelude/Prelude.v": [{"name": "null_spec", "text": "Lemma null_spec (A : Type) (l : list A) : forall b, null l = b <-> (if b then l = [] else l <> []).", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/Logic/ClassicalFol.v": [{"name": "HilbertCalculus_sound", "text": "Theorem HilbertCalculus_sound (Gamma : ensemble (frm L)) (C : frm L) (PROVE : Gamma \u22a2 C) : Gamma \u22a8 C.", "decomposition": ["MP_preserves_truth"], "retrieval": ["interpret_frm_ext_upto", "Gen_preserves_truth", "not_free_no_effect_on_interpret_frm", "Rel_eqAxm_preserves_truth", "substitution_lemma_frm", "Fun_eqAxm_preserves_truth"], "remove_type": "abort"}]}, "9e71689aa88c9a098a58c96ef7edef9e4f0aa9df": {}, "ef295768ddee7d5f95f5efbb16af0a43dc253230": {}, "a7d519ab62af2303a5d2597a7484074c360a3e49": {}, "a50103475d557dfc5b1d52e85eca6bed12e61bf7": {}, "507fe572d73fb312c735474a6448bf7eb973bf2e": {}, "23e543a33fe0d6f6d5702be58b44400db1706799": {}, "1e4072cca1c5659cad43193eb22ae11774431a7d": {}, "552658a97a8fc9c0271799e4e87d399c851b0fef": {}, "161fdf01688a16d14ebe446a19d33febe8710445": {}, "510591d2e24d1753e60549c9b8eade208734251b": {}}