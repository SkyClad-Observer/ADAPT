{"369f305f4adaaac7473da45f9cca3f1d2f23296e": {"finite.v": [{"name": "only_has_vars_weaken", "text": "Lemma only_has_vars_weaken A B x e : only_has_vars (B++A) e -> only_has_vars (B++[x]++A) e.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "only_has_vars_contract", "text": "Lemma only_has_vars_contract A B x e : only_has_vars (B++[x;x]++A) e -> only_has_vars (B++[x]++A) e.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "only_has_vars_exchange", "text": "Lemma only_has_vars_exchange A B x y e : only_has_vars (B++[x;y]++A) e -> only_has_vars (B++[y;x]++A) e.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_closed", "text": "Lemma subst_closed x v e : closed e -> subst x v e = e.", "decomposition": [], "retrieval": ["subst'_closed", "subst'_subst"], "remove_type": "abort"}, {"name": "subst_compose", "text": "Lemma subst_compose xs ys x v sub e : ~ x \u2208 ys -> only_has_vars (x::xs) e -> (\u2200 x', x' \u2208 xs -> only_has_vars ys (sub x')) -> sub x = x -> subst x v (subst' sub e) = subst' (fun x' => if decide (x = x') then v else sub x') e.", "decomposition": ["only_has_vars_exchange"], "retrieval": ["subst_equiv", "only_has_vars_weaken", "subst'_subst", "subst'_id"], "remove_type": "abort"}, {"name": "subst_eval_two", "text": "Lemma subst_eval_two {x t_x v_x y t_y v_y d_x d_y e t} (pf_x : typed' [] v_x t_x) (pf_y : typed' [] v_y t_y) (pf : typed' [(x,t_x);(y,t_y)] e t) (pf' : typed' [] (subst y v_y (subst x v_x e)) t) : eval pf_x () = Some d_x -> eval pf_y () = Some d_y -> eval pf ((), d_y, d_x) = eval pf' ().", "decomposition": ["only_has_vars_exchange"], "retrieval": ["lookup_var_there", "subst'_typed", "subst_compose", "typed_to_closed", "typed_to_only_has_vars", "typed_in_equiv_contexts", "subst'_subst", "subst'_closed", "lookup_var_here", "subst'_id", "subst_eval'"], "remove_type": "admit"}]}, "7cf2c6b8894d5873c4bd2c7f088877e0e69f91bd": {"finite.v": [{"name": "subst_compose'", "text": "Lemma subst_compose' A B x v sub e : sub x = Var x -> only_has_vars (B ++ x :: A) e -> (\u2200 x', x' \u2208 B -> sub x' = x') -> (\u2200 x', x' \u2208 A -> ~ (x' \u2208 B) -> x' <> x -> closed (sub x')) -> subst x v (subst' sub e) = subst' (fun x' => subst x v (sub x')) e.", "decomposition": [], "retrieval": ["subst_closed", "subst_equiv"], "remove_type": "abort"}, {"name": "subst_compose", "text": "Lemma subst_compose A x v sub e : sub x = Var x -> only_has_vars (x :: A) e -> (\u2200 x', x' \u2208 A -> x' <> x -> closed (sub x')) -> subst x v (subst' sub e) = subst' (fun x' => subst x v (sub x')) e.", "decomposition": ["subst_compose'"], "retrieval": [], "remove_type": "admit"}, {"name": "in_vars_to_lookup", "text": "Lemma in_vars_to_lookup (\u0393 : Ctx) x : x \u2208 map fst \u0393 -> exists t, lookup \u0393 x = Some t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_eval_two", "text": "Lemma subst_eval_two {x t_x v_x y t_y v_y d_x d_y e t} (pf_x : typed' [] v_x t_x) (pf_y : typed' [] v_y t_y) (pf : typed' [(x,t_x);(y,t_y)] e t) (pf' : typed' [] (subst y v_y (subst x v_x e)) t) : eval pf_x () = Some d_x -> eval pf_y () = Some d_y -> eval pf ((), d_y, d_x) = eval pf' ().", "decomposition": ["subst_compose'"], "retrieval": ["lookup_var_there", "subst'_typed", "subst_compose", "typed_to_closed", "subst_closed", "typed_to_only_has_vars", "typed_in_equiv_contexts", "subst'_subst", "only_has_vars_exchange", "subst'_closed", "lookup_var_here", "subst'_id", "subst_eval'"], "remove_type": "admit"}, {"name": "adequacy", "text": "Corollary adequacy {e t} (pf : typed' [] e t) : (exists v, is_value v /\\ rtc step e v) <-> (exists v, eval pf tt = Some v).", "decomposition": [], "retrieval": ["eval_of_value_is_some", "subst'_id", "preservation_steps", "soundness"], "remove_type": "abort"}]}, "37775727cd5adbeb344e38dcb245e7e5d9e37b36": {"finite.v": [{"name": "unit_unique", "text": "Lemma unit_unique (x y : unit) : x = y.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "eval_extend'", "text": "Lemma eval_extend' A B e t : forall (pf : typed' (B++A) e t) (pf' : typed' B e t) env env', eval pf (cat_env env env') = eval pf' env'.", "decomposition": [], "retrieval": ["eval_extend"], "remove_type": "admit"}, {"name": "FTLR", "text": "Theorem FTLR {\u0393 e t} (pf : typed' \u0393 e t) : forall sub env, R_env sub env -> R_E (subst' sub e) (eval pf env).", "decomposition": [], "retrieval": ["step_app_1'", "curry2_apply", "fixpoint_induction", "only_has_vars_weaken", "lookup_var_there", "subst_compose", "subst_equiv", "step_app_2'", "in_vars_to_lookup", "only_has_vars_contract", "subst_compose'", "subst_closed", "typed_to_only_has_vars", "subst'_subst", "only_has_vars_exchange", "step_if_1'", "lookup_var_here", "subst'_of_only_has_vars"], "remove_type": "admit"}, {"name": "terminates_correct", "text": "Theorem terminates_correct : \u2200 e pf, terminates e pf <-> \u2203 v, is_value v /\\ rtc step e v.", "decomposition": [], "retrieval": ["adequacy"], "remove_type": "abort"}]}, "0034146156dfe8b1e51a035bcf94b3582d111bde": {"finite.v": [{"name": "subst_eval_two", "text": "Lemma subst_eval_two {x t_x v_x y t_y v_y d_x d_y e t} (pf_x : typed' [] v_x t_x) (pf_y : typed' [] v_y t_y) (pf : typed' [(x,t_x);(y,t_y)] e t) (pf' : typed' [] (subst y v_y (subst x v_x e)) t) : eval pf_x () = Some d_x -> eval pf_y () = Some d_y -> eval pf ((), d_y, d_x) = eval pf' ().", "decomposition": [], "retrieval": ["lookup_var_there", "subst'_typed", "subst_compose", "typed_to_closed", "subst_compose'", "subst_closed", "typed_to_only_has_vars", "typed_in_equiv_contexts", "subst'_subst", "only_has_vars_exchange", "subst'_closed", "lookup_var_here", "subst'_id", "subst_eval'"], "remove_type": "admit"}, {"name": "FTLR", "text": "Theorem FTLR {\u0393 e t} (pf : typed' \u0393 e t) : forall sub env, R_env sub env -> R_E (subst' sub e) (eval pf env).", "decomposition": [], "retrieval": ["step_app_1'", "curry2_apply", "fixpoint_induction", "only_has_vars_weaken", "lookup_var_there", "subst_compose", "subst_equiv", "step_app_2'", "in_vars_to_lookup", "only_has_vars_contract", "subst_compose'", "subst_closed", "typed_to_only_has_vars", "subst'_subst", "only_has_vars_exchange", "step_if_1'", "lookup_var_here", "subst'_of_only_has_vars"], "remove_type": "admit"}, {"name": "terminates_correct", "text": "Theorem terminates_correct : \u2200 e t pf, terminates (t:=t) e pf <-> \u2203 v, is_value v /\\ rtc step e v.", "decomposition": [], "retrieval": ["adequacy"], "remove_type": "abort"}]}, "0931e36d2d9bcd92a12e2f5a074c78c2798b268d": {"finite.v": [{"name": "lfp_is_fixpoint", "text": "Lemma lfp_is_fixpoint `{pointed A} (f : Map A A) : f (lfp f) = lfp f.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "lfp_is_least", "text": "Lemma lfp_is_least `{pointed A} (f : Map A A) : \u2200 x, f x \u2264 x -> lfp f \u2264 x.", "decomposition": [], "retrieval": ["fixpoint_induction"], "remove_type": "admit"}]}}