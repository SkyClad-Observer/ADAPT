{"f382a3f252be8a6d4ec4ce6952bea11fe44d998c": {"theories/Lambda.v": [{"name": "STLC_is_SN", "text": "Corollary STLC_is_SN : forall Gamma A t, types Gamma t A -> sn t.", "decomposition": [], "retrieval": ["reducible_is_sn", "typing_is_reducible"], "remove_type": "abort"}, {"name": "typing_is_reducible", "text": "Lemma typing_is_reducible : forall (Gamma : var -> type) (sigma : var -> term), (forall (x:var), reducible (Gamma x) (sigma x)) -> forall (A:type) (t:term), types Gamma t A -> reducible A t.[sigma].", "decomposition": [], "retrieval": ["reducible_abs"], "remove_type": "abort"}, {"name": "reducible_var", "text": "Lemma reducible_var : forall x A Gamma, types Gamma (Var x) A -> reducible A (Var x).", "decomposition": [], "retrieval": ["reducible_is_sn"], "remove_type": "admit"}, {"name": "reducible_abs", "text": "Lemma reducible_abs : forall (v : term) (A B : type), (forall (u:term), reducible A u -> reducible B v.[u/]) -> reducible (Arr A B) (Lam v).", "decomposition": [], "retrieval": ["reducible_is_sn", "sn_subst", "sn_ind_pair", "step_subst"], "remove_type": "admit"}, {"name": "sn_ind_pair", "text": "Lemma sn_ind_pair : forall (P : term -> term -> Prop), (forall t u, (forall t' u', ((t = t' /\\ step u u') \\/ (step t t' /\\ u = u')) -> P t' u') -> P t u) -> forall t u, sn t -> sn u -> P t u.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sn_subst", "text": "Lemma sn_subst : forall (t : term) (sigma : var -> term), sn t -> (forall u:term, t = u.[sigma] -> sn u).", "decomposition": [], "retrieval": ["step_subst"], "remove_type": "abort"}, {"name": "reducible_is_sn", "text": "Lemma reducible_is_sn : forall (A : type), (forall (t : term), reducible A t -> sn t) /\\ (forall (t u : term), reducible A t -> step t u -> reducible A u) /\\ (forall (t : term), neutral t -> (forall t':term, step t t' -> reducible A t') -> reducible A t).", "decomposition": [], "retrieval": ["sn_var_app"], "remove_type": "abort"}, {"name": "sn_sub_term", "text": "Lemma sn_sub_term : forall (t : term), sn t -> (forall t':term, sub_term t' t -> sn t').", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "sn_lam", "text": "Lemma sn_lam : forall (t : term), sn t -> sn (Lam t).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "type_pres", "text": "Lemma type_pres : forall (Gamma : var -> type) (s t : term) (A : type), types Gamma s A -> step s t -> types Gamma t A.", "decomposition": [], "retrieval": ["type_subst"], "remove_type": "abort"}, {"name": "type_subst", "text": "Lemma type_subst : forall (Gamma Delta : var -> type) (s : term) (A : type) (sigma : var -> term), types Gamma s A -> (forall (x:var) , types Delta (sigma x) (Gamma x)) -> types Delta s.[sigma] A.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "step_subst", "text": "Lemma step_subst : forall (t t' : term) (sigma : var -> term), step t t' -> step t.[sigma] t'.[sigma].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "var_subst", "text": "Lemma var_subst: forall (x:var) (sigma : var -> term), (Var x).[sigma] = sigma x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "3dc4a13488ff0a12fa639c0d29cdcb34f418fc2b": {}, "7f88f3da29535bcd355a1e2caa615e6486cc81c4": {"theories/SimplyTypedLambdaCalculus/StrongNormalisation.v": [{"name": "STLC_is_SN", "text": "Corollary STLC_is_SN (A: type) (\u0393: var -> type) (t: term): \u0393 \u22a2 t : A -> SN t.", "decomposition": [], "retrieval": ["reducible_var", "typing_is_reducible", "reducible_is_SN"], "remove_type": "abort"}, {"name": "typing_is_reducible", "text": "Lemma typing_is_reducible (\u0393: var -> type) (\u03c3: var -> term): (forall (x: var), reducible (\u0393 x) (\u03c3 x)) -> forall (A: type) (t: term), \u0393 \u22a2 t : A -> reducible A t.[\u03c3].", "decomposition": [], "retrieval": ["reducible_abs"], "remove_type": "abort"}, {"name": "reducible_var", "text": "Lemma reducible_var (A: type) (x: var) (\u0393: var -> type): \u0393 \u22a2 Var x : A -> reducible A (Var x).", "decomposition": [], "retrieval": ["reducible_is_SN"], "remove_type": "abort"}, {"name": "reducible_abs", "text": "Lemma reducible_abs (v: term) (A B: type): (forall (u: term), reducible A u -> reducible B v.[u/]) -> reducible (Arr A B) (Lam v).", "decomposition": [], "retrieval": ["SN_ind_pair", "SN_subst", "reducible_is_SN"], "remove_type": "abort"}, {"name": "SN_ind_pair", "text": "Lemma SN_ind_pair (P : term -> term -> Prop): (forall t u, (forall t' u', ((t = t' /\\ u ->\u03b2 u') \\/ (t ->\u03b2 t' /\\ u = u')) -> P t' u') -> P t u) -> forall t u, SN t -> SN u -> P t u.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "SN_subst", "text": "Lemma SN_subst (t: term) (\u03c3: var -> term): SN t -> forall (u: term), t = u.[\u03c3] -> SN u.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reducible_is_SN", "text": "Lemma reducible_is_SN (A : type): (forall (t: term), reducible A t -> SN t) /\\ (forall (t u: term), reducible A t -> t ->\u03b2 u -> reducible A u) /\\ (forall (t: term), neutral t -> (forall (t': term), t ->\u03b2 t' -> reducible A t') -> reducible A t).", "decomposition": [], "retrieval": ["SN_var_app", "SN_inverted"], "remove_type": "abort"}, {"name": "SN_inverted", "text": "Lemma SN_inverted (t: term): SN t -> forall (t': term), t ->\u03b2 t' -> SN t'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "SN_sub_term", "text": "Lemma SN_sub_term (t: term): SN t -> forall (t': term), sub_term t' t -> SN t'.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "SN_lam", "text": "Lemma SN_lam (t: term): SN t -> SN (Lam t).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/SimplyTypedLambdaCalculus/Definitions.v": [{"name": "type_preservation", "text": "Lemma type_preservation (\u0393: var -> type) (s t: term) (A: type): \u0393 \u22a2 s : A -> s ->\u03b2 t -> \u0393 \u22a2 t : A.", "decomposition": [], "retrieval": ["type_subst"], "remove_type": "abort"}, {"name": "type_subst", "text": "Lemma type_subst (\u0393 \u0393': var -> type) (s: term) (A: type) (\u03c3: var -> term): \u0393 \u22a2 s : A -> (forall (x: var) , \u0393' \u22a2 \u03c3 x : \u0393 x) -> \u0393' \u22a2 s.[\u03c3] : A.", "decomposition": [], "retrieval": ["type_weakening"], "remove_type": "abort"}, {"name": "type_weakening", "text": "Lemma type_weakening (\u0393: var -> type) (s: term) (A: type): \u0393 \u22a2 s : A -> forall (\u0393': var -> type) (x': var -> var), \u0393 = x' >>> \u0393' -> \u0393' \u22a2 s.[ren x'] : A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "39e791439cfbae3a6fb42f657c6b5f44f67cb09a": {}, "68c98ab8aab3caaa5800e202804ec1a095d85f98": {"theories/SimplyTypedLambdaCalculus/ChurchRosser.v": [{"name": "max_par_red", "text": "Lemma max_par_red (t t': term): t >=> t' -> t' >=> par_red_max_reduction t.", "decomposition": [], "retrieval": ["par_red_subst_par_red", "par_red_refl", "lam_match", "pair_match"], "remove_type": "admit"}, {"name": "lam_match", "text": "Lemma lam_match : forall (s u : term) (f : term -> term), (exists s', s = Lam s' /\\ (replace_lambda f s u) = f s') \\/ ((replace_lambda f s u) = u /\\ ~exists s', s = Lam s').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "par_red_to_beta_star", "text": "Lemma par_red_to_beta_star (s t : term): s >=> t -> s ~>* t.", "decomposition": [], "retrieval": ["beta_star_app", "beta_star_lam"], "remove_type": "admit"}, {"name": "beta_star_lam", "text": "Lemma beta_star_lam (s s': term): s ~>* s' -> Lam s ~>* Lam s'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "par_red_subst_par_red", "text": "Lemma par_red_subst_par_red (s t: term) (sigma sigma': var -> term): (forall v: var, sigma v >=> sigma' v) -> s >=> t -> s.[sigma] >=> t.[sigma'].", "decomposition": [], "retrieval": ["par_red_subst_up_equivalence"], "remove_type": "abort"}, {"name": "par_red_subst", "text": "Lemma par_red_subst (t t': term) (sigma: var -> term): t >=> t' -> t.[sigma] >=> t'.[sigma].", "decomposition": [], "retrieval": ["par_red_refl"], "remove_type": "admit"}, {"name": "beta_to_par_red", "text": "Lemma beta_to_par_red : forall (s t : term), s ~> t -> s >=> t.", "decomposition": [], "retrieval": ["par_red_refl"], "remove_type": "admit"}, {"name": "par_red_refl", "text": "Lemma par_red_refl (t: term): t >=> t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/SimplyTypedLambdaCalculus/StrongNormalisation.v": [{"name": "typing_is_reducible", "text": "Lemma typing_is_reducible (\u0393: var -> type) (\u03c3: var -> term): (forall (x: var), reducible (\u0393 x) (\u03c3 x)) -> forall (A: type) (t: term), \u0393 \u22a2 t : A -> reducible A t.[\u03c3].", "decomposition": [], "retrieval": ["reducible_abs", "reducible_pair"], "remove_type": "admit"}, {"name": "reducible_var", "text": "Lemma reducible_var (A: type) (x: var) (\u0393: var -> type): \u0393 \u22a2 Var x : A -> reducible A (Var x).", "decomposition": [], "retrieval": ["reducible_is_SN"], "remove_type": "admit"}, {"name": "reducible_is_SN", "text": "Lemma reducible_is_SN (A : type): (forall (t: term), reducible A t -> SN t) /\\ (forall (t u: term), reducible A t -> t ~> u -> reducible A u) /\\ (forall (t: term), neutral t -> (forall (t': term), t ~> t' -> reducible A t') -> reducible A t).", "decomposition": [], "retrieval": ["SN_sub_term", "SN_var_app", "SN_inverted"], "remove_type": "admit"}, {"name": "SN_sub_term", "text": "Lemma SN_sub_term (t: term): SN t -> forall (t': term), sub_term t' t -> SN t'.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "14d4003448881cf8b94afd376a75c81d4d84c03b": {"theories/SimplyTypedLambdaCalculus/ChurchRosser.v": [{"name": "max_par_red", "text": "Lemma max_par_red (t t': term): t >=> t' -> t' >=> par_red_max_reduction t.", "decomposition": [], "retrieval": ["lam_match", "par_red_refl", "pair_match", "par_red_subst_par_red"], "remove_type": "admit"}, {"name": "pair_match", "text": "Lemma pair_match : forall (s u: term) (f : term -> term -> term), (exists s' t', s = Pair s' t' /\\ replace_pair f s u = f s' t') \\/ (replace_pair f s u = u /\\ ~ exists s' t', s = Pair s' t').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lam_match", "text": "Lemma lam_match : forall (s u : term) (f : term -> term), (exists s', s = Lam s' /\\ (replace_lambda f s u) = f s') \\/ ((replace_lambda f s u) = u /\\ ~exists s', s = Lam s').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "par_red_to_beta_star", "text": "Lemma par_red_to_beta_star (s t : term): s >=> t -> s ~>* t.", "decomposition": [], "retrieval": ["beta_star_app", "beta_star_lam"], "remove_type": "admit"}, {"name": "par_red_subst_par_red", "text": "Lemma par_red_subst_par_red (s t: term) (sigma sigma': var -> term): (forall v: var, sigma v >=> sigma' v) -> s >=> t -> s.[sigma] >=> t.[sigma'].", "decomposition": [], "retrieval": ["par_red_subst_up_equivalence"], "remove_type": "abort"}, {"name": "par_red_subst", "text": "Lemma par_red_subst (t t': term) (sigma: var -> term): t >=> t' -> t.[sigma] >=> t'.[sigma].", "decomposition": [], "retrieval": ["par_red_refl"], "remove_type": "admit"}, {"name": "beta_to_par_red", "text": "Lemma beta_to_par_red : forall (s t : term), s ~> t -> s >=> t.", "decomposition": [], "retrieval": ["par_red_refl"], "remove_type": "admit"}, {"name": "par_red_refl", "text": "Lemma par_red_refl (t: term): t >=> t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/SimplyTypedLambdaCalculus/Definitions.v": [{"name": "type_preservation", "text": "Lemma type_preservation (\u0393: var -> type) (s t: term) (A: type): \u0393 \u22a2 s : A -> s ~> t -> \u0393 \u22a2 t : A.", "decomposition": [], "retrieval": ["type_subst"], "remove_type": "abort"}, {"name": "type_subst", "text": "Lemma type_subst (\u0393 \u0393': var -> type) (s: term) (A: type) (\u03c3: var -> term): \u0393 \u22a2 s : A -> (forall (x: var) , \u0393' \u22a2 \u03c3 x : \u0393 x) -> \u0393' \u22a2 s.[\u03c3] : A.", "decomposition": [], "retrieval": ["type_weakening"], "remove_type": "abort"}, {"name": "type_weakening", "text": "Lemma type_weakening (\u0393: var -> type) (s: term) (A: type): \u0393 \u22a2 s : A -> forall (\u0393': var -> type) (x': var -> var), \u0393 = x' >>> \u0393' -> \u0393' \u22a2 s.[ren x'] : A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "beta_subst", "text": "Lemma beta_subst (t t': term) (\u03c3: var -> term): t ~> t' -> t.[\u03c3] ~> t'.[\u03c3].", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/SimplyTypedLambdaCalculus/StrongNormalisation.v": [{"name": "typing_is_reducible", "text": "Lemma typing_is_reducible (\u0393: var -> type) (\u03c3: var -> term): (forall (x: var), reducible (\u0393 x) (\u03c3 x)) -> forall (A: type) (t: term), \u0393 \u22a2 t : A -> reducible A t.[\u03c3].", "decomposition": [], "retrieval": ["reducible_pair", "reducible_abs"], "remove_type": "admit"}, {"name": "reducible_is_SN", "text": "Lemma reducible_is_SN (A : type): (forall (t: term), reducible A t -> SN t) /\\ (forall (t u: term), reducible A t -> t ~> u -> reducible A u) /\\ (forall (t: term), neutral t -> (forall (t': term), t ~> t' -> reducible A t') -> reducible A t).", "decomposition": [], "retrieval": ["SN_sub_term", "SN_var_app", "SN_inverted"], "remove_type": "admit"}, {"name": "SN_sub_term", "text": "Lemma SN_sub_term (t: term): SN t -> forall (t': term), sub_term t' t -> SN t'.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "5440ff25cdbd6aa65e5c8d1399bb497340845d72": {"theories/SimplyTypedLambdaCalculus/ChurchRosser.v": [{"name": "ChurchRosser", "text": "Theorem ChurchRosser: CR beta.", "decomposition": [], "retrieval": ["par_red_cr", "beta_star_equiv_par_red_star"], "remove_type": "abort"}, {"name": "par_red_cr", "text": "Lemma par_red_cr: CR par_red.", "decomposition": [], "retrieval": ["par_red_left_cr"], "remove_type": "abort"}, {"name": "par_red_left_cr", "text": "Lemma par_red_left_cr (t u v: term): par_red t u -> par_red* t v -> exists (w: term), par_red* u w /\\ par_red v w.", "decomposition": [], "retrieval": ["local_confluence_par_red"], "remove_type": "abort"}, {"name": "local_confluence_par_red", "text": "Lemma local_confluence_par_red: local_confluence par_red.", "decomposition": [], "retrieval": ["max_par_red"], "remove_type": "abort"}, {"name": "max_par_red", "text": "Lemma max_par_red (t t': term): t >=> t' -> t' >=> par_red_max_reduction t.", "decomposition": [], "retrieval": ["inj_match", "lam_match", "par_red_refl", "pair_match", "par_red_subst_par_red"], "remove_type": "abort"}, {"name": "pair_match", "text": "Lemma pair_match (s u: term) (f: term -> term -> term): (exists s' t', s = Pair s' t' /\\ replace_pair f s u = f s' t') \\/ (replace_pair f s u = u /\\ ~ exists s' t', s = Pair s' t').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lam_match", "text": "Lemma lam_match (s u: term) (f: term -> term): (exists s', s = Lam s' /\\ replace_lambda f s u = f s') \\/ (replace_lambda f s u = u /\\ ~ exists s', s = Lam s').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "beta_star_equiv_par_red_star", "text": "Lemma beta_star_equiv_par_red_star (s t: term): s ~>* t <-> s >=>* t.", "decomposition": [], "retrieval": ["beta_to_par_red", "par_red_to_beta_star"], "remove_type": "abort"}, {"name": "par_red_to_beta_star", "text": "Lemma par_red_to_beta_star (s t: term): s >=> t -> s ~>* t.", "decomposition": [], "retrieval": ["beta_star_app", "beta_star_lam", "beta_star_case", "beta_star_context_binary"], "remove_type": "abort"}, {"name": "par_red_subst_par_red", "text": "Lemma par_red_subst_par_red (s t: term) (\u03c3 \u03c3': var -> term): (forall v: var, \u03c3 v >=> \u03c3' v) -> s >=> t -> s.[\u03c3] >=> t.[\u03c3'].", "decomposition": [], "retrieval": ["par_red_subst_up"], "remove_type": "abort"}, {"name": "par_red_subst", "text": "Lemma par_red_subst (t t': term) (\u03c3: var -> term): t >=> t' -> t.[\u03c3] >=> t'.[\u03c3].", "decomposition": [], "retrieval": ["par_red_refl"], "remove_type": "admit"}, {"name": "beta_to_par_red", "text": "Lemma beta_to_par_red (s t: term): s ~> t -> s >=> t.", "decomposition": [], "retrieval": ["par_red_refl"], "remove_type": "abort"}, {"name": "par_red_refl", "text": "Lemma par_red_refl (t: term): t >=> t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/SimplyTypedLambdaCalculus/StrongNormalisation.v": [{"name": "typing_is_reducible", "text": "Lemma typing_is_reducible (\u0393: var -> type) (\u03c3: var -> term): (forall (x: var), reducible (\u0393 x) (\u03c3 x)) -> forall (A: type) (t: term), \u0393 \u22a2 t : A -> reducible A t.[\u03c3].", "decomposition": [], "retrieval": ["reducible_pair", "reducible_sum_injR", "reducible_abs", "reducible_sum_injL", "reducible_pat"], "remove_type": "admit"}, {"name": "reducible_pat", "text": "Lemma reducible_pat (A B C: type) (t u v: term): reducible (Sum A B) t -> reducible (Arr A C) (Lam u) -> reducible (Arr B C) (Lam v) -> reducible C (Case t u v).", "decomposition": [], "retrieval": ["SN_sub_term", "SN_triple_ind", "reducible_is_SN"], "remove_type": "abort"}, {"name": "reducible_pair", "text": "Lemma reducible_pair (A B: type) (u v: term): reducible A u -> reducible B v -> reducible (Prod A B) (Pair u v).", "decomposition": [], "retrieval": ["SN_ind_pair", "reducible_is_SN"], "remove_type": "abort"}, {"name": "reducible_var", "text": "Lemma reducible_var (A: type) (x: var) (\u0393: var -> type): \u0393 \u22a2 Var x : A -> reducible A (Var x).", "decomposition": [], "retrieval": ["reducible_is_SN"], "remove_type": "admit"}, {"name": "reducible_abs", "text": "Lemma reducible_abs (v: term) (A B: type): (forall (u: term), reducible A u -> reducible B v.[u/]) -> reducible (Arr A B) (Lam v).", "decomposition": [], "retrieval": ["SN_ind_pair", "beta_subst", "SN_subst", "reducible_is_SN"], "remove_type": "abort"}, {"name": "SN_triple_ind", "text": "Lemma SN_triple_ind (P : term -> term -> term -> Prop): (forall t u v, (forall t' u' v', ((t = t' /\\ u = u' /\\ v ~> v') \\/ (t = t' /\\ u ~> u' /\\ v = v') \\/ (t ~> t' /\\ u = u' /\\ v = v')) -> P t' u' v') -> P t u v) -> forall t u v, SN t -> SN u -> SN v -> P t u v.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "SN_subst", "text": "Lemma SN_subst (t: term) (\u03c3: var -> term): SN t -> forall (u: term), t = u.[\u03c3] -> SN u.", "decomposition": [], "retrieval": ["beta_subst"], "remove_type": "abort"}, {"name": "reducible_is_SN", "text": "Lemma reducible_is_SN (A : type): (forall (t: term), reducible A t -> SN t) /\\ (forall (t u: term), reducible A t -> t ~> u -> reducible A u) /\\ (forall (t: term), neutral t -> (forall (t': term), t ~> t' -> reducible A t') -> reducible A t).", "decomposition": [], "retrieval": ["SN_sub_term", "SN_var_app", "SN_inverted"], "remove_type": "admit"}, {"name": "SN_var_app", "text": "Lemma SN_var_app (t: term) (n: var): SN (App t (Var n)) -> SN t.", "decomposition": [], "retrieval": ["SN_sub_term"], "remove_type": "abort"}, {"name": "SN_sub_term", "text": "Lemma SN_sub_term (t: term): SN t -> forall (t': term), sub_term t' t -> SN t'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "SN_lam", "text": "Lemma SN_lam (t: term): SN t -> SN (Lam t).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "e505849f3b408552ed03abeb6730c48e4499b56d": {}}