{"eb2d9bdd565328e804bcf0b7307c45a77cb543eb": {"coq/Equivalent.v": [{"name": "a_b_matches", "text": "Theorem a_b_matches : forall (r : re) (s : string), a_matches r s <-> b_matches r s.", "decomposition": ["a_matches_star", "star_help'", "star_help", "a_matches_Star", "nil_matches_epsilon"], "retrieval": ["isEmpty_Concat", "a_matches_concat", "a_der_set_Union", "a_der_set_eps", "a_der_set_atom'", "fold_left_union", "b_der_concat", "a_matches_Concat", "b_der_void", "b_der_union", "a_der_set_atom"], "remove_type": "abort"}, {"name": "star_help'", "text": "Lemma star_help' : forall (n : nat) (r : re) (s : string), (\u2200 x0 : string, a_matches r x0 \u2194 b_matches r x0) -> b_matches (Concat_n n r) s \u2192 a_matches (Star r) s.", "decomposition": ["a_matches_Star", "b_nil_matches_epsilon"], "retrieval": ["b_der_concat"], "remove_type": "abort"}, {"name": "star_help", "text": "Lemma star_help : forall (n : nat) (r : re) (s : string), (\u2200 x0 : string, a_matches r x0 \u2194 b_matches r x0) -> a_matches (Concat_n n r) s \u2192 isEmpty (fold_left b_der s (Star r)).", "decomposition": ["nil_matches_epsilon", "isEmpty_Star"], "retrieval": ["a_matches_concat"], "remove_type": "abort"}], "coq/Regex.v": [{"name": "strong_induction", "text": "Lemma strong_induction {A} (P : list A -> Prop) : (forall n, (forall m, length m < length n -> P m) -> P n) -> forall n, P n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "coq/Brzozowski.v": [{"name": "b_nil_matches_epsilon", "text": "Lemma b_nil_matches_epsilon : forall (s : string), b_matches Epsilon s -> s = [].", "decomposition": [], "retrieval": ["b_der_void"], "remove_type": "abort"}, {"name": "isEmpty_Star", "text": "Lemma isEmpty_Star : forall (s1 s2 : string) (r : re), isEmpty (fold_left b_der s1 r) -> isEmpty (fold_left b_der s2 (Star r)) -> isEmpty (fold_left b_der (s1 ++ s2) (Star r)).", "decomposition": [], "retrieval": ["isEmpty_Concat"], "remove_type": "abort"}, {"name": "isEmpty_Concat", "text": "Lemma isEmpty_Concat : forall (s1 s2 : string) (r1 r2 : re), isEmpty (fold_left b_der s1 r1) -> isEmpty (fold_left b_der s2 r2) -> isEmpty (fold_left b_der (s1 ++ s2) (Concat r1 r2)).", "decomposition": [], "retrieval": ["b_der_union"], "remove_type": "admit"}], "coq/Antimirov.v": [{"name": "a_matches_Star", "text": "Lemma a_matches_Star : forall (s1 s2 : string) (r : re), a_matches r s1 -> a_matches (Star r) s2 -> a_matches (Star r) (s1 ++ s2).", "decomposition": [], "retrieval": ["fold_left_union", "a_matches_Concat"], "remove_type": "abort"}, {"name": "a_matches_star", "text": "Lemma a_matches_star : forall (s : string) (r : re), a_matches (Star r) s -> exists n, a_matches (Concat_n n r) s.", "decomposition": ["a_matches_epsilon", "strong_induction"], "retrieval": ["a_matches_concat", "elem_of_a_der_subset", "elem_of_set_map", "a_matches_Concat", "elem_of_fold_left"], "remove_type": "abort"}, {"name": "nil_matches_epsilon", "text": "Lemma nil_matches_epsilon : forall (s : string), a_matches Epsilon s -> [] = s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_matches_epsilon", "text": "Lemma a_matches_epsilon : a_matches Epsilon [].", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "22d4f371318aa90ddc9be7f45c475494922693ec": {"coq/Equivalent.v": [{"name": "a_b_matches", "text": "Theorem a_b_matches : forall (r : re) (s : string), a_matches r s <-> b_matches r s.", "decomposition": ["a_matches_Star_destruct", "nil_matches_Epsilon", "a_matches_Concat_destruct", "b_der_Union", "b_matches_Concat", "b_matches_Star_Concat", "b_der_Void", "a_der_set_Eps", "b_matches_Star", "a_der_set_Atom'", "a_der_set_Atom"], "retrieval": ["isEmpty_Concat", "a_der_set_Union", "a_matches_Star", "star_help'", "star_help", "fold_left_union", "a_matches_Concat"], "remove_type": "abort"}, {"name": "star_help'", "text": "Lemma star_help' : forall (n : nat) (r : re) (s : string), (\u2200 x0 : string, a_matches r x0 \u2194 b_matches r x0) -> b_matches (Concat_n n r) s \u2192 a_matches (Star r) s.", "decomposition": ["b_matches_Concat", "b_matches_Epsilon"], "retrieval": ["a_matches_Star"], "remove_type": "abort"}, {"name": "star_help", "text": "Lemma star_help : forall (n : nat) (r : re) (s : string), (\u2200 x0 : string, a_matches r x0 \u2194 b_matches r x0) -> a_matches (Concat_n n r) s \u2192 isEmpty (fold_left b_der s (Star r)).", "decomposition": ["nil_matches_Epsilon", "a_matches_Concat_destruct"], "retrieval": ["isEmpty_Star"], "remove_type": "abort"}], "coq/Brzozowski.v": [{"name": "b_matches_Star_Concat", "text": "Lemma b_matches_Star_Concat : forall (r : re) (s : string), b_matches (Star r) s -> exists n, b_matches (Concat_n n r) s.", "decomposition": ["b_matches_Concat", "b_der_Union"], "retrieval": ["strong_induction", "isEmpty_Concat"], "remove_type": "abort"}, {"name": "b_matches_Epsilon", "text": "Lemma b_matches_Epsilon : forall (s : string), b_matches Epsilon s -> s = [].", "decomposition": ["b_der_Void"], "retrieval": [], "remove_type": "abort"}, {"name": "isEmpty_Concat", "text": "Lemma isEmpty_Concat : forall (s1 s2 : string) (r1 r2 : re), isEmpty (fold_left b_der s1 r1) -> isEmpty (fold_left b_der s2 r2) -> isEmpty (fold_left b_der (s1 ++ s2) (Concat r1 r2)).", "decomposition": ["b_der_Union"], "retrieval": [], "remove_type": "abort"}, {"name": "b_matches_Star", "text": "Lemma b_matches_Star : forall (s : string) (r : re), s \u2260 [] -> b_matches (Star r) s -> exists s1 s2, (s = s1 ++ s2) /\\ b_matches r s1 /\\ b_matches (Star r) s2.", "decomposition": ["b_matches_Concat", "b_der_Union"], "retrieval": [], "remove_type": "abort"}, {"name": "b_matches_Concat", "text": "Lemma b_matches_Concat : forall (s : string) (r1 r2 : re), b_matches (Concat r1 r2) s -> exists s1 s2, (s = s1 ++ s2) /\\ b_matches r1 s1 /\\ b_matches r2 s2.", "decomposition": ["b_der_Union"], "retrieval": [], "remove_type": "abort"}, {"name": "b_der_Union", "text": "Lemma b_der_Union : forall (s : string) (r1 r2 : re), fold_left b_der s (Union r1 r2) = Union (fold_left b_der s r1) (fold_left b_der s r2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "b_der_Void", "text": "Lemma b_der_Void : forall (s : string), fold_left b_der s Void = Void.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "b_matches_matches", "text": "Lemma b_matches_matches (r : re) (s : string) : b_matches r s = true <-> matches r s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "b_der_matches_2", "text": "Lemma b_der_matches_2 (c : char) (r : re) (s : string) : matches r (c :: s) -> matches (b_der r c) s.", "decomposition": [], "retrieval": ["isEmpty_matches_2"], "remove_type": "admit"}, {"name": "b_der_matches_1", "text": "Lemma b_der_matches_1 (c : char) (r : re) (s : string) : matches (b_der r c) s -> matches r (c :: s).", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "coq/Regex.v": [{"name": "isEmpty_matches_2", "text": "Lemma isEmpty_matches_2 (r : re) : matches r [] -> isEmpty r = true.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "isEmpty_matches_1", "text": "Lemma isEmpty_matches_1 (r : re) : isEmpty r = true -> matches r [].", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "star_inv", "text": "Lemma star_inv (r : re) (s : string) : s \u2260 [] -> matches (Star r) s -> exists (s1 s2 : string), s1 \u2260 [] /\\ s = s1 ++ s2 /\\ matches r s1 /\\ matches (Star r) s2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "coq/Antimirov.v": [{"name": "a_matches_Star_destruct", "text": "Lemma a_matches_Star_destruct : forall (s : string) (r : re), a_matches (Star r) s -> exists n, a_matches (Concat_n n r) s.", "decomposition": ["a_matches_Concat_destruct", "a_matches_Epsilon"], "retrieval": ["elem_of_a_der_subset", "elem_of_set_map", "a_matches_Concat", "strong_induction", "elem_of_fold_left"], "remove_type": "abort"}, {"name": "nil_matches_Epsilon", "text": "Lemma nil_matches_Epsilon : forall (s : string), a_matches Epsilon s -> [] = s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_matches_Epsilon", "text": "Lemma a_matches_Epsilon : a_matches Epsilon [].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_matches_Concat_destruct", "text": "Lemma a_matches_Concat_destruct : forall (s : string) (r1 r2 : re), a_matches (Concat r1 r2) s -> exists s1 s2, (s = s1 ++ s2) /\\ a_matches r1 s1 /\\ a_matches r2 s2.", "decomposition": [], "retrieval": ["elem_of_a_der_subset", "elem_of_set_map", "fold_left_union", "elem_of_fold_left"], "remove_type": "abort"}, {"name": "a_der_set_Atom'", "text": "Lemma a_der_set_Atom' (c a : char) : a \u2260 c -> a_der_set {[ Atom c ]} a = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_der_set_Atom", "text": "Lemma a_der_set_Atom (c : char) : a_der_set {[ Atom c ]} c = {[ Epsilon ]}.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_der_set_Eps", "text": "Lemma a_der_set_Eps (c : char) : a_der_set {[ Epsilon ]} c = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "0a27e2115132a15debb713cb0bb1025719fbd2c4": {"coq/Finite.v": [{"name": "a_finite", "text": "Theorem a_finite : forall (s : string) (r : re), a_der_str r s \u2286 A_der r.", "decomposition": ["subset_trans", "a_finite_help", "set_bind_subset", "A_der_subset", "re_in_A_der"], "retrieval": [], "remove_type": "abort"}, {"name": "subset_trans", "text": "Lemma subset_trans (A B C : gset re) : A \u2286 B -> B \u2286 C -> A \u2286 C.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "A_der_subset", "text": "Lemma A_der_subset : forall (r r0 : re) (a : char), r0 \u2208 a_der r a -> A_der r0 \u2286 A_der r.", "decomposition": ["re_in_A_der", "a_finite_help"], "retrieval": [], "remove_type": "abort"}, {"name": "set_bind_subset", "text": "Lemma set_bind_subset : forall (f : re -> gset re) (s s' : gset re), s \u2286 s' -> (forall r, r \u2208 s -> f r \u2286 s') -> set_bind f s \u2286 s'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_finite_help", "text": "Theorem a_finite_help (r : re) : forall (a : re), a \u2208 A_der r -> forall (c : char), a_der a c \u2286 A_der r.", "decomposition": ["re_in_A_der"], "retrieval": [], "remove_type": "abort"}, {"name": "re_in_A_der", "text": "Lemma re_in_A_der : forall (r : re), r \u2208 A_der r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "coq/Equivalent.v": [{"name": "nullable_singleton", "text": "Lemma nullable_singleton : forall (r : re), isEmpty r <-> nullable {[ r ]}.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "coq/Antimirov.v": [{"name": "a_der_matches_2", "text": "Lemma a_der_matches_2 a r s : matches r (a :: s) -> matches_set' s (a_der r a).", "decomposition": [], "retrieval": ["isEmpty_matches_2"], "remove_type": "abort"}, {"name": "a_der_matches_1", "text": "Lemma a_der_matches_1 a r s : matches_set' s (a_der r a) -> matches r (a :: s).", "decomposition": ["not_matches_empty"], "retrieval": ["isEmpty_matches_1"], "remove_type": "abort"}, {"name": "matches_set_epsilon", "text": "Lemma matches_set_epsilon : matches_set [] {[Epsilon]}.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "matches_singleton'", "text": "Lemma matches_singleton' (s : string) (r : re) : matches r s -> matches_set s {[ r ]}.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "not_matches_empty", "text": "Lemma not_matches_empty (s : string) : ~(matches_set s \u2205).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "matches_set_union_inv", "text": "Lemma matches_set_union_inv : forall (rs1 rs2 : gset re) (s : string), matches_set' s (rs1 \u222a rs2) -> matches_set' s rs1 \\/ matches_set' s rs2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "matches_set_weakening_right", "text": "Lemma matches_set_weakening_right : forall (rs rs' : gset re) (s : string), matches_set s rs -> matches_set s (rs' \u222a rs).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "matches_set_weakening_left", "text": "Lemma matches_set_weakening_left : forall (rs rs' : gset re) (s : string), matches_set s rs -> matches_set s (rs \u222a rs').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "matches_set_matches_set'", "text": "Lemma matches_set_matches_set' : forall (s : string) (rs : gset re), matches_set s rs <-> matches_set' s rs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "elem_of_a_der_set", "text": "Lemma elem_of_a_der_set : forall (x : re) (c : char) (rs : gset re), x \u2208 a_der_set rs c -> exists r, r \u2208 rs /\\ x \u2208 a_der r c.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "set_bind_empty", "text": "Lemma set_bind_empty (f : re -> gset re) : set_bind f (\u2205 : gset re) = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "fold_left_empty", "text": "Lemma fold_left_empty (s : string) : fold_left a_der_set s \u2205 = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "a_der_set_singleton", "text": "Lemma a_der_set_singleton (r : re) (c : char) : a_der_set {[ r ]} c = a_der r c.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "coq/Height.v": [{"name": "set_size_union_bound", "text": "Lemma set_size_union_bound : forall (rs1 rs2 : gset re), size (rs1 \u222a rs2) <= size rs1 + size rs2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "size_map_upper_bound", "text": "Lemma size_map_upper_bound : forall (f : re -> re) (s : gset re), size ((set_map f s) : gset re) <= size s.", "decomposition": ["set_map_singleton", "removing_nonexistent_elem_preserves_size"], "retrieval": [], "remove_type": "admit"}, {"name": "removing_nonexistent_elem_preserves_size", "text": "Lemma removing_nonexistent_elem_preserves_size : forall (x : re) (X : gset re), x \u2209 X -> size (X \u2216 {[ x ]}) = size X.", "decomposition": ["empty_intersection_with_absent_element"], "retrieval": [], "remove_type": "abort"}, {"name": "empty_intersection_with_absent_element", "text": "Lemma empty_intersection_with_absent_element : forall (x : re) (X : gset re), x \u2209 X -> X \u2229 {[ x ]} = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_deriv_height", "text": "Lemma a_deriv_height : forall (c : char) (r : re), max_height_re_set (a_der r c) <= 2 * re_height r.", "decomposition": ["height_lemma", "max_height_singleton"], "retrieval": ["max_height_empty_set"], "remove_type": "abort"}, {"name": "height_lemma", "text": "Lemma height_lemma : \u2200 (X : nat) (rs : gset re), max_height_re_set rs <= X <-> \u2200 (r : re), r \u2208 rs -> re_height r <= X.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "max_height_singleton", "text": "Lemma max_height_singleton : forall (r : re), max_height_re_set {[r]} = re_height r.", "decomposition": ["set_fold_singleton"], "retrieval": [], "remove_type": "abort"}, {"name": "set_map_singleton", "text": "Lemma set_map_singleton (f : re -> re) (x : re): set_map f ({[ x ]} : gset re) = ({[ f x ]} : gset re).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "set_fold_singleton", "text": "Lemma set_fold_singleton (f : re -> nat -> nat) (b : nat) (r : re) : set_fold f b ({[ r ]} : gset re) = f r b.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "6e6b989da866a819df010d74797b8f9779bc9df3": {"coq/Regex_lecture.v": [{"name": "DerivParse2", "text": "Lemma DerivParse2 : forall r cs, [[r]] cs -> deriv_parse r cs = true.", "decomposition": ["Derivs2", "Null1"], "retrieval": [], "remove_type": "abort"}, {"name": "DerivParse1", "text": "Lemma DerivParse1 : forall r cs, deriv_parse r cs = true -> [[r]] cs.", "decomposition": ["AccNull", "Derivs1"], "retrieval": [], "remove_type": "abort"}, {"name": "AccNull", "text": "Lemma AccNull : forall r, null r = Eps -> [[r]] nil.", "decomposition": ["app_nil_beg"], "retrieval": [], "remove_type": "abort"}, {"name": "Derivs2", "text": "Lemma Derivs2 : forall cs r, [[r]] cs -> [[derivs r cs]] nil.", "decomposition": ["Deriv1"], "retrieval": [], "remove_type": "abort"}, {"name": "Derivs1", "text": "Lemma Derivs1 : forall cs r, [[derivs r cs]] nil -> [[r]] cs.", "decomposition": ["Deriv2"], "retrieval": [], "remove_type": "abort"}, {"name": "Deriv2", "text": "Lemma Deriv2 : forall r c cs, [[deriv r c]] cs -> [[r]] (c::cs).", "decomposition": ["NullNil", "app_nil_beg", "app_cons"], "retrieval": [], "remove_type": "abort"}, {"name": "Deriv1", "text": "Lemma Deriv1 : forall r c cs, [[r]] (c::cs) -> [[deriv r c]] cs.", "decomposition": ["app_nil_beg"], "retrieval": [], "remove_type": "abort"}, {"name": "NullNil", "text": "Lemma NullNil : forall r cs, [[null r]] cs -> cs = nil.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Null2", "text": "Lemma Null2 : forall r, [[null r]] nil -> [[r]] nil.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "Null1", "text": "Lemma Null1 : forall r, [[r]] nil -> [[null r]] nil.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "app_cons", "text": "Lemma app_cons : forall A (x:A) (y z:list A), x :: y ++ z = (x::y) ++ z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "app_nil_beg", "text": "Lemma app_nil_beg : forall A (cs:list A), cs = nil ++ cs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "opt_alt", "text": "Lemma opt_alt : forall r1 r2, OptAlt r1 r2 [=] Alt r1 r2.", "decomposition": ["reg_eq_refl", "alt_r_r", "alt_zero_l", "alt_zero_r", "reg_eq_sym"], "retrieval": [], "remove_type": "admit"}, {"name": "alt_r_r", "text": "Lemma alt_r_r : forall r, (Alt r r) [=] r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "alt_zero_l", "text": "Lemma alt_zero_l : forall r, (Alt Zero r) [=] r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "alt_zero_r", "text": "Lemma alt_zero_r : forall r, (Alt r Zero) [=] r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "opt_cat", "text": "Lemma opt_cat : forall r1 r2, OptCat r1 r2 [=] Cat r1 r2.", "decomposition": ["reg_eq_refl", "cat_zero_l", "cat_eps_l", "cat_zero_r", "cat_eps_r", "reg_eq_sym"], "retrieval": [], "remove_type": "admit"}, {"name": "cat_zero_l", "text": "Lemma cat_zero_l : forall r, (Cat Zero r) [=] Zero.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "cat_zero_r", "text": "Lemma cat_zero_r : forall r, (Cat r Zero) [=] Zero.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "cat_eps_l", "text": "Lemma cat_eps_l : forall r, (Cat Eps r) [=] r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "cat_eps_r", "text": "Lemma cat_eps_r : forall r, (Cat r Eps) [=] r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reg_eq_sym", "text": "Lemma reg_eq_sym : forall (r1 r2: regexp), r1 [=] r2 -> r2 [=] r1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reg_eq_trans", "text": "Lemma reg_eq_trans : forall (r1 r2 r3: regexp), r1 [=] r2 -> r2 [=] r3 -> r1 [=] r3.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reg_eq_refl", "text": "Lemma reg_eq_refl : forall (r:regexp), r [=] r.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "3a351eef1fa638533516b75ab492410002eb4749": {"coq/Antimirov.v": [{"name": "char_refl", "text": "Lemma char_refl : forall (c : char), (if char_dec c c then true else false) = true.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "set_bind_union", "text": "Lemma set_bind_union (f : re -> gset re) (r1 r2 : gset re) : set_bind f (r1 \u222a r2) = set_bind f r1 \u222a set_bind f r2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "set_bind_singleton", "text": "Lemma set_bind_singleton (f : re -> gset re) (r : re) : set_bind f ({[r ]} : gset re) = f r.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "set_bind_empty", "text": "Lemma set_bind_empty (f : re -> gset re) : set_bind f (\u2205 : gset re) = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "fold_left_empty", "text": "Lemma fold_left_empty (s : string) : fold_left a_der_set s \u2205 = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "a_der_set_empty", "text": "Lemma a_der_set_empty (c : char) : a_der_set \u2205 c = \u2205.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "a_der_set_singleton", "text": "Lemma a_der_set_singleton (r : re) (c : char) : a_der_set {[ r ]} c = a_der r c.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "54296197f58bb53ffc65a5dde16e0720cdb8df57": {}, "0503e231dcf3300004cbb1a18289764de1c6fed3": {}}