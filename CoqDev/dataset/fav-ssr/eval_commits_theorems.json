{"47cd657fbe0388a03e2ddd412203b9c1a1df1caf": {"src/prelude.v": [{"name": "up_div_uphalf", "text": "Lemma up_div_uphalf n : up_div n 2 = uphalf n.", "decomposition": ["up_divS"], "retrieval": [], "remove_type": "abort"}, {"name": "up_divMA", "text": "Lemma up_divMA m n p : up_div (up_div m n) p = up_div m (n * p).", "decomposition": ["up_div_divDP", "up_div1n", "up_divn0", "up_div0n", "up_divS"], "retrieval": [], "remove_type": "abort"}, {"name": "up_divnMl", "text": "Lemma up_divnMl p m d : 0 < p -> up_div (p * m) (p * d) = up_div m d.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leq_up_div", "text": "Lemma leq_up_div n d : up_div n d * d <= n + d.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leq_up_div2r", "text": "Lemma leq_up_div2r d m n : m <= n -> up_div m d <= up_div n d.", "decomposition": ["up_divn0", "up_div_divDP"], "retrieval": [], "remove_type": "abort"}, {"name": "up_div_lt", "text": "Lemma up_div_lt n m : 1 < m -> 1 < n -> up_div n m < n.", "decomposition": ["up_divS"], "retrieval": [], "remove_type": "abort"}, {"name": "up_div_divDP", "text": "Lemma up_div_divDP p q : 0 < q -> up_div p q = (p + q.-1) %/ q.", "decomposition": ["up_divS", "up_div0n"], "retrieval": [], "remove_type": "abort"}, {"name": "div_pred_up_div", "text": "Corollary div_pred_up_div p q : p.-1 %/ q = (up_div p q).-1.", "decomposition": ["up_divS", "up_div0n"], "retrieval": [], "remove_type": "abort"}, {"name": "up_div_div", "text": "Corollary up_div_div p q : 0 < p -> up_div p q = (p.-1 %/ q).+1.", "decomposition": ["up_divS"], "retrieval": [], "remove_type": "abort"}, {"name": "up_divS", "text": "Lemma up_divS p q : up_div p.+1 q = (p %/ q).+1.", "decomposition": ["up_divn0"], "retrieval": [], "remove_type": "abort"}, {"name": "up_div_gt0", "text": "Lemma up_div_gt0 p q : 0 < p -> 0 < up_div p q.", "decomposition": [], "retrieval": ["ltn_leq_trans"], "remove_type": "abort"}, {"name": "up_divn1", "text": "Lemma up_divn1 n : up_div n 1 = n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "up_div1n", "text": "Lemma up_div1n d : up_div 1 d = 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "up_divn0", "text": "Lemma up_divn0 n : up_div n 0 = (n != 0).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "up_div0n", "text": "Lemma up_div0n d : up_div 0 d = 0.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "src/selection.v": [{"name": "T_mom_select_bound", "text": "Lemma T_mom_select_bound k xs : (T_mom_select k xs <= T_mom_select_upper (size xs))%N.", "decomposition": ["leq_up_div", "up_div_divDP"], "retrieval": ["mom_select_correct", "T_mapfilter_size", "T_slow_select_leq", "T_slow_median_leq", "T_chop_leq", "mom_pivot_bound", "T_mom_select_upper_mono", "T_partition3_eq", "chop_size", "chop_mem_size"], "remove_type": "abort"}, {"name": "T_mom_select_upper_mono", "text": "Lemma T_mom_select_upper_mono n m : (n <= m -> T_mom_select_upper n <= T_mom_select_upper m)%N.", "decomposition": ["leq_up_div2r"], "retrieval": ["ltn_leq_trans"], "remove_type": "abort"}, {"name": "mom_select_spec", "text": "Lemma mom_select_spec k xs r : mom_select_grph k xs r -> r = select x0 k xs.", "decomposition": [], "retrieval": ["chop_size", "select_recurrence"], "remove_type": "admit"}, {"name": "mom_pivot_bound", "text": "Lemma mom_pivot_bound xs : (count (< mom xs) xs <= up_div (7*size xs) 10 + 1) && (count (> mom xs) xs <= up_div (7*size xs) 10 + 3).", "decomposition": ["up_div71", "up_div73"], "retrieval": ["chops_eq", "chop_count_le", "chop_ltgt_bound", "chop_flatten_eq", "chop_ge_mom_lt", "chop_size", "chop_le_mom_gt"], "remove_type": "abort"}, {"name": "up_div73", "text": "Lemma up_div73 n : (0 < n)%N -> (3 * uphalf (up_div n 5).-1 + 2 * up_div n 5 <= up_div (7 * n) 10 + 3)%N.", "decomposition": ["up_div_div"], "retrieval": ["ltn_leq_trans"], "remove_type": "abort"}, {"name": "up_div71", "text": "Lemma up_div71 n : (0 < n)%N -> (3 * ((up_div n 5).-1)./2 + 2 * up_div n 5 <= up_div (7 * n) 10 + 1)%N.", "decomposition": ["up_div_div"], "retrieval": ["ltn_leq_trans"], "remove_type": "abort"}, {"name": "chop_ltgt_bound", "text": "Lemma chop_ltgt_bound xs : (0 < size xs)%N -> ((size (chop_lt xs) <= (up_div (size xs) 5).-1./2) && (size (chop_gt xs) <= uphalf (up_div (size xs) 5).-1))%N.", "decomposition": ["up_div_gt0"], "retrieval": ["chop_size", "median_bound"], "remove_type": "abort"}, {"name": "mom_mem", "text": "Lemma mom_mem xs : (0 < size xs)%N -> mom xs \\in xs.", "decomposition": ["up_div_gt0"], "retrieval": ["median_mem", "chop_flatten_eq", "chop_size", "chop_mem_size"], "remove_type": "admit"}, {"name": "chop_size", "text": "Lemma chop_size n xs : 0 < n -> size (chop n xs) = up_div (size xs) n.", "decomposition": ["up_divS"], "retrieval": ["chop_ge_length_eq"], "remove_type": "admit"}, {"name": "chop_flattenK", "text": "Lemma chop_flattenK n (xs : seq (seq T)) : (0 < n)%N -> (forall x, x \\in xs -> size x = n) -> chop n (flatten xs) = xs.", "decomposition": ["chop1", "chop_nil"], "retrieval": [], "remove_type": "abort"}, {"name": "chop_cat", "text": "Lemma chop_cat n k xs ys : (0 < n)%N -> size xs = n * k -> chop n (xs++ys) = chop n xs ++ chop n ys.", "decomposition": ["chop1", "chop_nil"], "retrieval": [], "remove_type": "abort"}, {"name": "chop1", "text": "Lemma chop1 n xs ys : (0 < n)%N -> size xs = n -> chop n (xs ++ ys) = xs :: chop n ys.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "chop_nil", "text": "Lemma chop_nil n : chop n [::] = [::].", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "151001d7b4980b97d1aad1d1409d3f86c0f9deaa": {"src/bintree.v": [{"name": "bal_acomplete", "text": "Corollary bal_acomplete n xs t ss : n <= size xs -> bal n xs = (t, ss) -> acomplete t.", "decomposition": ["trunc_up_log_ltn", "bal_h_mh"], "retrieval": [], "remove_type": "abort"}, {"name": "bal_h_mh", "text": "Lemma bal_h_mh n xs t ss : n <= size xs -> bal n xs = (t, ss) -> height t = log2n n.+1 /\\ min_height t = trunc_log' 2 n.+1.", "decomposition": ["bal_suffix_size", "half_uphalfK", "trunc_log2S", "leq_trunc_log"], "retrieval": ["leq_log2n", "uphalf_le", "log2nS"], "remove_type": "abort"}, {"name": "inorder_balance_tree", "text": "Corollary inorder_balance_tree t : inorder (balance_tree t) = inorder t.", "decomposition": ["size_inorder", "bal_tree_take"], "retrieval": [], "remove_type": "abort"}, {"name": "bal_tree_take", "text": "Corollary bal_tree_take n t : n <= size_tree t -> inorder (bal_tree n t) = take n (inorder t).", "decomposition": ["size_inorder", "bal_list_take"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_balance_list", "text": "Corollary inorder_balance_list xs : inorder (balance_list xs) = xs.", "decomposition": ["bal_list_take"], "retrieval": [], "remove_type": "abort"}, {"name": "bal_list_take", "text": "Corollary bal_list_take n xs : n <= size xs -> inorder (bal_list n xs) = take n xs.", "decomposition": ["bal_prefix_suffix", "size_inorder"], "retrieval": [], "remove_type": "abort"}, {"name": "bal_suffix_size", "text": "Corollary bal_suffix_size n xs : n <= size xs -> size (bal n xs).2 = size xs - n.", "decomposition": ["bal_prefix_suffix", "size_inorder"], "retrieval": [], "remove_type": "abort"}, {"name": "bal_prefix_suffix", "text": "Lemma bal_prefix_suffix n xs t ss : n <= size xs -> bal n xs = (t, ss) -> xs = inorder t ++ ss /\\ size_tree t = n.", "decomposition": ["size_inorder"], "retrieval": ["uphalf_le"], "remove_type": "abort"}, {"name": "acomplete_mh", "text": "Lemma acomplete_mh t : acomplete t -> min_height t = trunc_log' 2 (size1_tree t).", "decomposition": [], "retrieval": ["ncomplete_size1", "complete_mh_h", "trunc_log_eq", "trunc_expnK", "exp_mh_leq", "acomplete_h1", "completeE"], "remove_type": "abort"}, {"name": "size_inorder", "text": "Lemma size_inorder t : size (inorder t) = size_tree t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "src/prelude.v": [{"name": "trunc_up_log_ltn", "text": "Lemma trunc_up_log_ltn n : trunc_log' 2 n <= log2n n <= trunc_log' 2 n + 1.", "decomposition": ["trunc_log0", "trunc_log_ltn", "up_log0", "trunc_logP"], "retrieval": ["log2n_exp", "log2n_geq"], "remove_type": "abort"}, {"name": "log2n_bounds", "text": "Lemma log2n_bounds n : 1 < n -> let k := log2n n in 2 ^ k.-1 < n <= 2 ^ k.", "decomposition": ["trunc_log_bounds"], "retrieval": [], "remove_type": "abort"}, {"name": "up_log0", "text": "Lemma up_log0 : log2n 0 = 0.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_log2S", "text": "Lemma trunc_log2S n : 1 < n -> trunc_log' 2 n = (trunc_log' 2 n./2).+1.", "decomposition": ["trunc_log_ltn", "trunc_log2_double", "trunc_logP"], "retrieval": ["trunc_log_eq"], "remove_type": "abort"}, {"name": "trunc_log2_double", "text": "Lemma trunc_log2_double n : 0 < n -> trunc_log' 2 n.*2 = (trunc_log' 2 n).+1.", "decomposition": ["trunc_logMp"], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_logMp", "text": "Lemma trunc_logMp p n : 1 < p -> 0 < n -> trunc_log' p (p * n) = (trunc_log' p n).+1.", "decomposition": ["trunc_log_ltn", "trunc_logP"], "retrieval": ["trunc_log_eq"], "remove_type": "abort"}, {"name": "trunc_expnK", "text": "Lemma trunc_expnK p n : 1 < p -> trunc_log' p (p ^ n) = n.", "decomposition": [], "retrieval": ["trunc_log_eq"], "remove_type": "abort"}, {"name": "trunc_log_eq", "text": "Lemma trunc_log_eq p n k : 1 < p -> p ^ n <= k < p ^ n.+1 -> trunc_log' p k = n.", "decomposition": ["trunc_log_max", "trunc_logP"], "retrieval": [], "remove_type": "abort"}, {"name": "leq_trunc_log", "text": "Lemma leq_trunc_log p m n : m <= n -> trunc_log' p m <= trunc_log' p n.", "decomposition": ["trunc_log0n", "trunc_log_max", "trunc_logP", "trunc_log0"], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_log_max", "text": "Lemma trunc_log_max p k j : 1 < p -> p ^ j <= k -> j <= trunc_log' p k.", "decomposition": ["trunc_log_ltn"], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_log_ltn", "text": "Lemma trunc_log_ltn p n : 1 < p -> n < p ^ (trunc_log' p n).+1.", "decomposition": ["trunc_log_bounds", "trunc_log0"], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_logP", "text": "Lemma trunc_logP p n : 1 < p -> 0 < n -> p ^ trunc_log' p n <= n.", "decomposition": ["trunc_log_bounds"], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_log_bounds", "text": "Lemma trunc_log_bounds p n : 1 < p -> 0 < n -> let k := trunc_log' p n in p ^ k <= n < p ^ k.+1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_log0n", "text": "Lemma trunc_log0n n : trunc_log' 0 n = 0.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "trunc_log0", "text": "Lemma trunc_log0 p : trunc_log' p 0 = 0.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "half_subn", "text": "Lemma half_subn n : n - n./2 = uphalf n.", "decomposition": ["half_uphalfK"], "retrieval": [], "remove_type": "abort"}, {"name": "half_uphalfK", "text": "Lemma half_uphalfK n : n = n./2 + uphalf n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "e1ca1056132aa5da931127604c8bc3bf332db6bb": {"src/prelude.v": [{"name": "log2_trunc_log", "text": "Lemma log2_trunc_log n : 1 < n -> log2n n = (trunc_log' 2 n.-1).+1.", "decomposition": [], "retrieval": ["trunc_log_ltn", "log2n_eq", "trunc_logP"], "remove_type": "abort"}], "src/braun.v": [{"name": "invar_list_array", "text": "Corollary invar_list_array xs : list (array xs) = xs.", "decomposition": ["adds_list"], "retrieval": [], "remove_type": "admit"}, {"name": "invar_array", "text": "Corollary invar_array xs : invar (array xs).", "decomposition": ["adds_braun"], "retrieval": [], "remove_type": "admit"}, {"name": "invar_len", "text": "Corollary invar_len t : invar t -> len t = size (list t).", "decomposition": ["size_list1"], "retrieval": [], "remove_type": "admit"}, {"name": "invar_list_update", "text": "Corollary invar_list_update x0 x ar n : invar ar -> n < len ar -> list (update n x ar) = set_nth x0 (list ar) n x.", "decomposition": ["update1_list"], "retrieval": [], "remove_type": "admit"}, {"name": "invar_update", "text": "Corollary invar_update x ar n : invar ar -> n < len ar -> invar (update n x ar).", "decomposition": ["update1_braun", "update1_size"], "retrieval": [], "remove_type": "admit"}, {"name": "invar_lookup", "text": "Corollary invar_lookup x0 ar n : invar ar -> n < len ar -> lookup x0 ar n = nth x0 (list ar) n.", "decomposition": ["lookup1_braun"], "retrieval": [], "remove_type": "admit"}, {"name": "adds_list", "text": "Lemma adds_list t xs : braun t -> list1 (adds xs (size_tree t) t) = list1 t ++ xs.", "decomposition": ["update1_size_extend", "update1_braun_extend", "update1_braun_rcons"], "retrieval": [], "remove_type": "abort"}, {"name": "adds_braun", "text": "Lemma adds_braun t xs : braun t -> (size_tree (adds xs (size_tree t) t) == size_tree t + size xs) && braun (adds xs (size_tree t) t).", "decomposition": ["update1_size_extend", "update1_braun_extend"], "retrieval": [], "remove_type": "abort"}, {"name": "update1_braun_rcons", "text": "Lemma update1_braun_rcons t x : braun t -> list1 (update1 (size_tree t + 1) x t) = rcons (list1 t) x.", "decomposition": ["splice_rcons", "size_list1"], "retrieval": [], "remove_type": "abort"}, {"name": "splice_rcons", "text": "Lemma splice_rcons x y xs ys : (size ys <= size xs -> splice (rcons xs x) ys = rcons (splice xs ys) x) * (size xs <= size ys + 1 -> splice xs (rcons ys y) = rcons (splice xs ys) y).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "update1_braun_extend", "text": "Lemma update1_braun_extend t x : braun t -> braun (update1 (size_tree t + 1) x t).", "decomposition": ["update1_size_extend"], "retrieval": [], "remove_type": "abort"}, {"name": "update1_size_extend", "text": "Lemma update1_size_extend t x : braun t -> size_tree (update1 (size_tree t + 1) x t) = size_tree t + 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "update1_list", "text": "Lemma update1_list x0 n x t: braun t -> n \\in iota 1 (size_tree t) -> list1 (update1 n x t) = set_nth x0 (list1 t) n.-1 x.", "decomposition": ["lookup1_braun", "update1_lookup", "update1_size", "update1_braun", "size_list1"], "retrieval": [], "remove_type": "abort"}, {"name": "update1_lookup", "text": "Lemma update1_lookup x0 n m x t : braun t -> n \\in iota 1 (size_tree t) -> lookup1 x0 (update1 n x t) m = (if n == m then x else lookup1 x0 t m).", "decomposition": ["braun_iota"], "retrieval": ["odd2"], "remove_type": "abort"}, {"name": "update1_braun", "text": "Lemma update1_braun n x t : braun t -> n \\in iota 1 (size_tree t) -> braun (update1 n x t).", "decomposition": ["braun_iota", "update1_size"], "retrieval": [], "remove_type": "abort"}, {"name": "update1_size", "text": "Lemma update1_size n x t : braun t -> n \\in iota 1 (size_tree t) -> size_tree (update1 n x t) == size_tree t.", "decomposition": ["braun_iota"], "retrieval": [], "remove_type": "abort"}, {"name": "list_lookup1", "text": "Lemma list_lookup1 x0 t : braun t -> list1 t = map (lookup1 x0 t) (iota 1 (size_tree t)).", "decomposition": ["lookup1_braun", "size_list1"], "retrieval": [], "remove_type": "abort"}, {"name": "lookup1_braun", "text": "Lemma lookup1_braun x0 t n : braun t -> n < size_tree t -> lookup1 x0 t n.+1 = nth x0 (list1 t) n.", "decomposition": ["braun_iota", "size_list1", "nth_splice"], "retrieval": [], "remove_type": "abort"}, {"name": "nth_splice", "text": "Lemma nth_splice x0 n xs ys : n < size xs + size ys -> size ys <= size xs <= size ys + 1 -> nth x0 (splice xs ys) n = nth x0 (if ~~odd n then xs else ys) n./2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "braun_iota", "text": "Lemma braun_iota (l : tree A) x r n : braun (Node l x r) -> n \\in iota 1 (size_tree (Node l x r)) -> 1 < n -> (odd n ==> (n./2 \\in iota 1 (size_tree r))) && (~~ odd n ==> (n./2 \\in iota 1 (size_tree l))).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "size_list1", "text": "Lemma size_list1 t : size_tree t = size (list1 t).", "decomposition": ["size_splice"], "retrieval": [], "remove_type": "abort"}, {"name": "size_splice", "text": "Lemma size_splice xs ys : size (splice xs ys) = size xs + size ys.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "braun_acomplete", "text": "Lemma braun_acomplete t : braun t -> acomplete t.", "decomposition": ["acomplete_compose"], "retrieval": ["acomplete_h", "size1_size", "acomplete_mh"], "remove_type": "abort"}, {"name": "acomplete_compose", "text": "Lemma acomplete_compose (l : tree A) x r : acomplete l -> acomplete r -> size_tree l == size_tree r + 1 -> acomplete (Node l x r).", "decomposition": ["log2_trunc_log"], "retrieval": ["size1_size", "leq_log2n", "acomplete_h", "acomplete_mh", "leq_trunc_log"], "remove_type": "abort"}]}, "5e7b85040a4d5531a1f87122e95bca40d4943b9e": {"src/beyond.v": [{"name": "invh_joinR", "text": "Lemma invh_joinR l x r : invh l -> invh r -> (bh r <= bh l)%N -> invh (joinR l x r).", "decomposition": [], "retrieval": ["invh_baliR", "bh_joinR"], "remove_type": "abort"}, {"name": "bh_joinR", "text": "Lemma bh_joinR l x r : invh l -> invh r -> (bh r <= bh l)%N -> bh (joinR l x r) == bh l.", "decomposition": [], "retrieval": ["bh_baliR"], "remove_type": "abort"}, {"name": "invc2_joinR", "text": "Lemma invc2_joinR l x r : invc l -> invc r -> invh l -> invh r -> (bh r <= bh l)%N -> invc2 (joinR l x r) && ((bh l != bh r) && (color l == Black) ==> invc (joinR l x r)).", "decomposition": [], "retrieval": ["invc_baliR", "invc2I"], "remove_type": "abort"}, {"name": "bst_joinL", "text": "Lemma bst_joinL l a r : all (< a) (inorder_a l) -> all (> a) (inorder_a r) -> bst_a l -> bst_a r -> (bh l <= bh r)%N -> bst_a (joinL l a r).", "decomposition": [], "retrieval": ["bst_baliL", "joinL_inorder"], "remove_type": "abort"}, {"name": "invh_joinL", "text": "Lemma invh_joinL l x r : invh l -> invh r -> (bh l <= bh r)%N -> invh (joinL l x r).", "decomposition": [], "retrieval": ["invh_baliL", "bh_joinL"], "remove_type": "abort"}, {"name": "bh_joinL", "text": "Lemma bh_joinL l x r : invh l -> invh r -> (bh l <= bh r)%N -> bh (joinL l x r) == bh r.", "decomposition": [], "retrieval": ["bh_baliL"], "remove_type": "abort"}, {"name": "invc2_joinL", "text": "Lemma invc2_joinL l x r : invc l -> invc r -> (bh l <= bh r)%N -> invc2 (joinL l x r) && ((bh l != bh r) && (color r == Black) ==> invc (joinL l x r)).", "decomposition": [], "retrieval": ["invc_baliL", "invc2I"], "remove_type": "abort"}], "src/avl.v": [{"name": "inv_isin_list", "text": "Corollary inv_isin_list x t : invariant t -> isin_a t x = (x \\in inorder_a t).", "decomposition": ["inorder_isin_list_a"], "retrieval": [], "remove_type": "admit"}, {"name": "invariant_delete", "text": "Corollary invariant_delete x t : invariant t -> invariant (delete x t).", "decomposition": [], "retrieval": ["avl_delete", "del_list_sorted", "inorder_delete"], "remove_type": "admit"}, {"name": "invariant_insert", "text": "Corollary invariant_insert x t : invariant t -> invariant (insert x t).", "decomposition": [], "retrieval": ["avl_insert", "inorder_insert", "ins_list_sorted"], "remove_type": "admit"}, {"name": "inorder_delete_list", "text": "Corollary inorder_delete_list x t : invariant t -> perm_eq (inorder_a (delete x t)) (filter (predC1 x) (inorder_a t)).", "decomposition": [], "retrieval": ["inorder_delete", "inorder_del_list"], "remove_type": "admit"}, {"name": "inorder_insert_list", "text": "Corollary inorder_insert_list x t : invariant t -> perm_eq (inorder_a (insert x t)) (if x \\in inorder_a t then inorder_a t else x :: inorder_a t).", "decomposition": [], "retrieval": ["inorder_insert", "inorder_ins_list"], "remove_type": "admit"}, {"name": "inorder_delete", "text": "Theorem inorder_delete x t : bst_list_a t -> inorder_a (delete x t) = del_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "inorder_split_max", "inorder_balR", "sorted_cat_cons_cat", "dellist_sorted_cat_cons_cat", "cmp_gt", "cmp_lt", "inorder_balL"], "remove_type": "abort"}, {"name": "inorder_insert", "text": "Theorem inorder_insert x t : bst_list_a t -> inorder_a (insert x t) = ins_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "inorder_balR", "sorted_cat_cons_cat", "cmp_gt", "inslist_sorted_cat_cons_cat", "cmp_lt", "inorder_balL"], "remove_type": "abort"}], "src/redblack.v": [{"name": "invariant_delete_j", "text": "Corollary invariant_delete_j x (t : rbt T) : invariant t -> invariant (delete_j x t).", "decomposition": [], "retrieval": ["rbt_delete_j", "del_list_sorted", "inorder_delete_j"], "remove_type": "admit"}, {"name": "inorder_delete_j_list", "text": "Corollary inorder_delete_j_list x (t : rbt T) : invariant t -> perm_eq (inorder_a (delete_j x t)) (filter (predC1 x) (inorder_a t)).", "decomposition": [], "retrieval": ["inorder_del_list", "inorder_delete_j"], "remove_type": "admit"}, {"name": "inorder_delete_j", "text": "Corollary inorder_delete_j x t : bst_list_a t -> inorder_a (delete_j x t) = del_list x (inorder_a t).", "decomposition": [], "retrieval": ["inorder_del_j", "inorder_paint"], "remove_type": "abort"}, {"name": "inorder_del_j", "text": "Lemma inorder_del_j x t : bst_list_a t -> inorder_a (del_j x t) = del_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "inorder_baldR", "inorder_baldL", "inorder_join", "sorted_cat_cons_cat", "dellist_sorted_cat_cons_cat", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "rbt_delete_j", "text": "Corollary rbt_delete_j x t : rbt_inv t -> rbt_inv (delete_j x t).", "decomposition": ["inv_delete_j"], "retrieval": ["paint_black"], "remove_type": "abort"}, {"name": "inv_delete_j", "text": "Corollary inv_delete_j x t : invch t -> invch (delete_j x t).", "decomposition": ["invc_del_j", "invh_del_j"], "retrieval": ["invh_paint"], "remove_type": "abort"}, {"name": "invh_del_j", "text": "Lemma invh_del_j x t : invch t -> invh (del_j x t) && (bh (del_j x t) == bh t - (color t == Black)).", "decomposition": ["invh_baldR_invc", "invh_join", "invh_baldL_invc", "bh_gt0"], "retrieval": ["invch_ind"], "remove_type": "abort"}, {"name": "invc_del_j", "text": "Lemma invc_del_j x t : invc t -> invc2 (del_j x t) && ((color t == Red) ==> invc (del_j x t)).", "decomposition": ["invc_join", "invc2_baldL", "invc_baldL", "invc_baldR", "invc2_baldR"], "retrieval": ["invc2I"], "remove_type": "abort"}, {"name": "invh_join", "text": "Lemma invh_join l r : invh l -> invh r -> bh l == bh r -> invh (join l r) && (bh (join l r) == bh l).", "decomposition": ["invh_baldL_black"], "retrieval": [], "remove_type": "abort"}, {"name": "invh_baldL_black", "text": "Lemma invh_baldL_black l a r : invh l -> invh r -> bh l + 1 == bh r -> color r = Black -> invh (baldL l a r) && (bh (baldL l a r) == bh r).", "decomposition": [], "retrieval": ["bh_baliR", "invh_baliR"], "remove_type": "abort"}, {"name": "invc_join", "text": "Lemma invc_join l r : invc l -> invc r -> invc2 (join l r) && ((color l == Black) && (color r == Black) ==> invc (join l r)).", "decomposition": ["invc_baldL"], "retrieval": ["invc2I"], "remove_type": "abort"}, {"name": "inv_isin_list", "text": "Corollary inv_isin_list x (t : rbt T) : invariant t -> isin_a t x = (x \\in inorder_a t).", "decomposition": ["inorder_isin_list_a"], "retrieval": [], "remove_type": "admit"}, {"name": "inorder_delete_list", "text": "Corollary inorder_delete_list x (t : rbt T) : invariant t -> perm_eq (inorder_a (delete x t)) (filter (predC1 x) (inorder_a t)).", "decomposition": [], "retrieval": ["inorder_delete", "inorder_del_list"], "remove_type": "admit"}, {"name": "invariant_delete", "text": "Corollary invariant_delete x (t : rbt T) : invariant t -> invariant (delete x t).", "decomposition": [], "retrieval": ["rbt_delete", "del_list_sorted", "inorder_delete"], "remove_type": "admit"}, {"name": "inorder_insert_list", "text": "Corollary inorder_insert_list x (t : rbt T) : invariant t -> perm_eq (inorder_a (insert x t)) (if x \\in inorder_a t then inorder_a t else x :: inorder_a t).", "decomposition": [], "retrieval": ["inorder_insert", "inorder_ins_list"], "remove_type": "admit"}, {"name": "invariant_insert", "text": "Corollary invariant_insert x (t : rbt T) : invariant t -> invariant (insert x t).", "decomposition": [], "retrieval": ["rbt_insert", "inorder_insert", "ins_list_sorted"], "remove_type": "admit"}, {"name": "invariant_empty", "text": "Lemma invariant_empty : invariant empty_a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "inorder_delete", "text": "Corollary inorder_delete x t : bst_list_a t -> inorder_a (delete x t) = del_list x (inorder_a t).", "decomposition": [], "retrieval": ["inorder_del", "inorder_paint"], "remove_type": "abort"}, {"name": "inorder_del", "text": "Lemma inorder_del x t : bst_list_a t -> inorder_a (del x t) = del_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "inorder_baldR", "inorder_baldL", "sorted_cat_cons_cat", "inorder_split_min", "dellist_sorted_cat_cons_cat", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_insert", "text": "Corollary inorder_insert x t : bst_list_a t -> inorder_a (insert x t) = ins_list x (inorder_a t).", "decomposition": [], "retrieval": ["inorder_paint", "inorder_ins"], "remove_type": "abort"}, {"name": "inorder_ins", "text": "Lemma inorder_ins x t : bst_list_a t -> inorder_a (ins x t) = ins_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "inorder_baliR", "cmp_gt", "inslist_sorted_cat_cons_cat", "cmp_lt", "inorder_baliL"], "remove_type": "abort"}, {"name": "rbt_delete", "text": "Corollary rbt_delete x t : rbt_inv t -> rbt_inv (delete x t).", "decomposition": ["inv_delete"], "retrieval": ["paint_black"], "remove_type": "abort"}, {"name": "inv_delete", "text": "Corollary inv_delete x t : invch t -> invch (delete x t).", "decomposition": ["invh_del", "invc_del"], "retrieval": ["invh_paint"], "remove_type": "abort"}, {"name": "invh_del", "text": "Lemma invh_del x t : invch t -> invh (del x t) && (bh (del x t) == bh t - (color t == Black)).", "decomposition": ["split_min_invh", "invh_baldR_invc", "invh_baldL_invc", "bh_gt0"], "retrieval": ["invch_ind"], "remove_type": "abort"}, {"name": "invc_del", "text": "Lemma invc_del x t : invc t -> invc2 (del x t) && ((color t == Red) ==> invc (del x t)).", "decomposition": ["split_min_invc", "invc2_baldL", "invc_baldL", "invc_baldR", "invc2_baldR"], "retrieval": ["invc2I"], "remove_type": "abort"}, {"name": "split_min_invh", "text": "Lemma split_min_invh l a r x t : split_min l a r = (x, t) -> invc l -> invc r -> invh l -> invh r -> bh l == bh r -> invh t && (bh t == bh l).", "decomposition": ["invh_baldL_invc"], "retrieval": [], "remove_type": "abort"}, {"name": "split_min_invc", "text": "Lemma split_min_invc l a r x t : split_min l a r = (x, t) -> invc l -> invc r -> invc2 t && ((color l == Black) && (color r == Black) ==> invc t).", "decomposition": ["invc2_baldL", "invc_baldL"], "retrieval": ["invc2I"], "remove_type": "abort"}, {"name": "invc_baldR", "text": "Lemma invc_baldR l a r : invc l -> invc2 r -> color l == Black -> invc (baldR l a r).", "decomposition": [], "retrieval": ["invc_baliL"], "remove_type": "abort"}, {"name": "invc2_baldR", "text": "Lemma invc2_baldR l a r : invc l -> invc2 r -> invc2 (baldR l a r).", "decomposition": [], "retrieval": ["invc_baliL", "paint2", "invc2I"], "remove_type": "abort"}, {"name": "invh_baldR_invc", "text": "Lemma invh_baldR_invc l a r : invh l -> invh r -> bh l == bh r + 1 -> invc l -> invh (baldR l a r) && (bh (baldR l a r) == bh l).", "decomposition": [], "retrieval": ["invh_paint", "invh_baliL", "bh_paint_red", "bh_baliL"], "remove_type": "abort"}, {"name": "invc_baldL", "text": "Lemma invc_baldL l a r : invc2 l -> invc r -> color r == Black -> invc (baldL l a r).", "decomposition": [], "retrieval": ["invc_baliR"], "remove_type": "abort"}, {"name": "invc2_baldL", "text": "Lemma invc2_baldL l a r : invc2 l -> invc r -> invc2 (baldL l a r).", "decomposition": [], "retrieval": ["paint2", "invc_baliR", "invc2I"], "remove_type": "abort"}, {"name": "invh_baldL_invc", "text": "Lemma invh_baldL_invc l a r : invh l -> invh r -> bh l + 1 == bh r -> invc r -> invh (baldL l a r) && (bh (baldL l a r) == bh r).", "decomposition": [], "retrieval": ["bh_baliR", "invh_baliR", "invh_paint", "bh_paint_red"], "remove_type": "abort"}, {"name": "rbt_insert", "text": "Corollary rbt_insert x t : rbt_inv t -> rbt_inv (insert x t).", "decomposition": ["inv_insert"], "retrieval": ["paint_black"], "remove_type": "abort"}, {"name": "inv_insert", "text": "Corollary inv_insert x t : invch t -> invch (insert x t).", "decomposition": ["invh_ins", "invc_ins"], "retrieval": ["invh_paint"], "remove_type": "abort"}, {"name": "invh_ins", "text": "Lemma invh_ins x t : invh t -> invh (ins x t) && (bh (ins x t) == bh t).", "decomposition": [], "retrieval": ["bh_baliR", "invh_baliL", "invh_baliR", "bh_baliL"], "remove_type": "abort"}, {"name": "invc_ins", "text": "Lemma invc_ins x t : invc t -> invc2 (ins x t) && ((color t == Black) ==> invc (ins x t)).", "decomposition": [], "retrieval": ["invc_baliL", "invc_baliR", "invc2I"], "remove_type": "abort"}, {"name": "invh_baliR", "text": "Lemma invh_baliR l a r : invh l -> invh r -> bh l == bh r -> invh (baliR l a r).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bh_baliR", "text": "Lemma bh_baliR l a r : bh l == bh r -> bh (baliR l a r) == bh l + 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "invh_baliL", "text": "Lemma invh_baliL l a r : invh l -> invh r -> bh l == bh r -> invh (baliL l a r).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bh_baliL", "text": "Lemma bh_baliL l a r : bh l == bh r -> bh (baliL l a r) == bh l + 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rbt_log_height", "text": "Lemma rbt_log_height t : rbt_inv t -> ((height t)./2 <= up_log 2 (size1_tree t))%N.", "decomposition": [], "retrieval": ["bh_size1"], "remove_type": "abort"}, {"name": "bh_size1", "text": "Lemma bh_size1 t : invch t -> (2 ^ (bh t) <= size1_tree t)%N.", "decomposition": [], "retrieval": ["invch_ind"], "remove_type": "abort"}, {"name": "bound_bht", "text": "Corollary bound_bht t : rbt_inv t -> (height t)./2 <= bh t.", "decomposition": [], "retrieval": ["height_black_height"], "remove_type": "abort"}, {"name": "height_black_height", "text": "Lemma height_black_height t : invch t -> (height t <= 2 * bh t + (color t == Red))%N.", "decomposition": [], "retrieval": ["invch_ind"], "remove_type": "abort"}, {"name": "invch_ind", "text": "Lemma invch_ind (P : rbt A -> Prop) : P (Leaf (A*col)) -> (forall l a c r, (c == Red) ==> (color l == Black) && (color r == Black) -> invc l -> invc r -> bh l == bh r -> invh l -> invh r -> P l -> P r -> P (Node l (a,c) r)) -> forall t, invch t -> P t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "bh_gt0", "text": "Lemma bh_gt0 t : t <> empty_a -> color t = Black -> (0 < bh t)%N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bh_paint_red", "text": "Lemma bh_paint_red t : color t = Black -> bh (paint Red t) = bh t - 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "src/bst.v": [{"name": "search_correct", "text": "Lemma search_correct t x : invar t -> search t x = has_overlap (inorder_a t) x.", "decomposition": [], "retrieval": ["max_hi_mem", "le_low", "overlapC", "not_node_leaf", "max_hi_max"], "remove_type": "abort"}, {"name": "invar_delete", "text": "Corollary invar_delete x (t : ivl_tree) : invar t -> invar (delete_i x t).", "decomposition": [], "retrieval": ["inv_max_hi_delete", "inorder_ivl_delete_list", "del_list_sorted"], "remove_type": "abort"}, {"name": "invar_insert", "text": "Corollary invar_insert x (t : ivl_tree) : invar t -> invar (insert_i x t).", "decomposition": [], "retrieval": ["inv_max_hi_insert", "ins_list_sorted", "inorder_ivl_insert_list"], "remove_type": "abort"}, {"name": "inorder_ivl_delete_list", "text": "Lemma inorder_ivl_delete_list x t : bst_list_a t -> inorder_a (delete_i x t) = del_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "dellist_sorted_cat_cons_cat", "inorder_ivl_split_min", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_ivl_insert_list", "text": "Lemma inorder_ivl_insert_list x t : bst_list_a t -> inorder_a (insert_i x t) = ins_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "cmp_gt", "inslist_sorted_cat_cons_cat", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_isin_list_a", "text": "Lemma inorder_isin_list_a t : bst_list_a t -> forall x, isin_a t x = (x \\in inorder_a t).", "decomposition": ["bst_to_list_a"], "retrieval": ["cmp_eq", "cmp_lt", "cmp_gt"], "remove_type": "abort"}, {"name": "bst_to_list_a", "text": "Lemma bst_to_list_a t : bst_a t <-> bst_list_a t.", "decomposition": [], "retrieval": ["sorted_cat_cons_cat", "sorted_rconsE"], "remove_type": "abort"}, {"name": "bst_to_list", "text": "Lemma bst_to_list (t : tree T) : bst t <-> bst_list t.", "decomposition": [], "retrieval": ["sorted_cat_cons_cat", "sorted_rconsE"], "remove_type": "abort"}], "src/bintree.v": [{"name": "in_a'", "text": "Lemma in_a' : inorder_a =1 inorder_a''.", "decomposition": [], "retrieval": ["map_inorder"], "remove_type": "abort"}, {"name": "in_a", "text": "Lemma in_a : inorder_a =1 inorder_a'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "1387b38fcfe88ab2456f23f8c4d12c5eb1b898df": {"src/avl.v": [{"name": "avl_delete_b", "text": "Lemma avl_delete_b x t : avl_b t -> avl_b (delete_b x t) && (height t == height (delete_b x t) + decr t (delete_b x t)).", "decomposition": ["avl_b_ind"], "retrieval": ["avl_split_max_b", "maxn_addl", "heightE", "maxn_addr"], "remove_type": "abort"}, {"name": "avl_insert_b", "text": "Lemma avl_insert_b x t : avl_b t -> avl_b (insert_b x t) && (height (insert_b x t) == height t + incr t (insert_b x t)).", "decomposition": ["avl_b_ind"], "retrieval": ["maxn_addl", "maxn_addr"], "remove_type": "abort"}, {"name": "avl_b_ind", "text": "Lemma avl_b_ind {A} (P : tree_bal A -> Prop) : P (Leaf (A*bal)) -> (forall l a b r, bal_inv (height l) b (height r) -> avl_b l -> avl_b r -> P l -> P r -> P (Node l (a,b) r)) -> forall t, avl_b t -> P t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "avl_delete", "text": "Theorem avl_delete x t : avl t -> avl (delete x t) && ((height t == height (delete x t)) || (height t == height (delete x t) + 1)).", "decomposition": ["avl_ind"], "retrieval": ["avl_split_max", "maxn_addl", "height_balL", "maxn_addr", "height_balR", "distn_Dr", "height_balR2", "dist_leq", "avl_balR", "height_balL2", "avl_balL"], "remove_type": "abort"}, {"name": "avl_insert", "text": "Theorem avl_insert x t : avl t -> avl (insert x t) && ((height (insert x t) == height t) || (height (insert x t) == height t + 1)).", "decomposition": ["avl_ind"], "retrieval": ["maxn_addl", "height_balL", "maxn_addr", "height_balR", "avl_balR", "distn_Dr", "height_balR2", "dist_leq", "distn_Dl", "height_balL2", "avl_balL"], "remove_type": "abort"}, {"name": "avl_fib", "text": "Lemma avl_fib (t : tree_ht A) : avl t -> (fib (height t + 2) <= size1_tree t)%N.", "decomposition": ["avl_ind"], "retrieval": ["dist_leqL", "dist_leqR", "fib_monotone"], "remove_type": "abort"}, {"name": "avl_ind", "text": "Lemma avl_ind (P : tree_ht A -> Prop) : P (Leaf (A*nat)) -> (forall l a r, `|height l - height r| <= 1%N -> avl l -> avl r -> P l -> P r -> P (Node l (a,maxn (height l) (height r) + 1) r)) -> forall t, avl t -> P t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "src/twothree.v": [{"name": "inorder_isin_list", "text": "Lemma inorder_isin_list x (t : tree23 T) : bst_list t -> isin23 t x = (x \\in inorder23 t).", "decomposition": [], "retrieval": ["cmp_eq", "sorted_rconsE", "sorted_cat_cons_cat", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_delete23", "text": "Lemma inorder_delete23 x t : complete23 t -> bst_list t -> inorder23 (delete x t) = del_list x (inorder23 t).", "decomposition": ["complete23_ind"], "retrieval": ["complete_lift", "cmp_eq", "height_empty", "inorderD22", "inorderD21", "inorderD33", "inorderD31", "split_minD", "dellist_sorted_cat_cons_cat", "inorder_lift", "cmp_gt", "inorderD32", "cmp_lt"], "remove_type": "abort"}, {"name": "complete_treeD", "text": "Lemma complete_treeD t (x : T) : complete23 t -> complete23 (treeD (del x t)).", "decomposition": ["complete23_ind"], "retrieval": ["complete21", "complete31", "complete_lift", "complete32", "complete33", "height_lift", "complete22", "split_min_completeD", "hD_del", "split_min_hD"], "remove_type": "abort"}, {"name": "hD_del", "text": "Lemma hD_del t (x : T) : complete23 t -> hD (del x t) = height23 t.", "decomposition": ["complete23_ind"], "retrieval": ["hD21", "complete_lift", "hD31", "height_lift", "hD22", "hD33", "hD32", "split_min_hD"], "remove_type": "abort"}, {"name": "complete_insert", "text": "Lemma complete_insert x (t : tree23 T) : complete23 t -> complete23 (insert x t).", "decomposition": [], "retrieval": ["complete_ins"], "remove_type": "abort"}, {"name": "complete_ins", "text": "Lemma complete_ins (x : T) t : complete23 t -> complete23 (treeI (ins x t)) && (hI (ins x t) == height23 t).", "decomposition": ["complete23_ind"], "retrieval": [], "remove_type": "abort"}, {"name": "complete23_ind", "text": "Lemma complete23_ind (P : tree23 A -> Prop) : P (Leaf A) -> (forall l a r, height23 l == height23 r -> complete23 l -> complete23 r -> P l -> P r -> P (Node2 l a r)) -> (forall l a m b r, height23 l == height23 m -> height23 m == height23 r -> complete23 l -> complete23 m -> complete23 r -> P l -> P m -> P r -> P (Node3 l a m b r)) -> forall t, complete23 t -> P t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "src/redblack.v": [{"name": "rbt_delete_j", "text": "Corollary rbt_delete_j x t : rbt_inv t -> rbt_inv (delete_j x t).", "decomposition": [], "retrieval": ["del_j_inv", "invh_paint", "paint_black"], "remove_type": "abort"}, {"name": "del_j_inv", "text": "Lemma del_j_inv x t : invc t && invh t -> [&& invh (del_j x t), (color t == Red) ==> (bh (del_j x t) == bh t) && invc (del_j x t) & (color t == Black) ==> (bh (del_j x t) == bh t - 1) && invc2 (del_j x t) ].", "decomposition": ["invch_ind"], "retrieval": ["join_inv", "inv_baldR", "inv_baldL"], "remove_type": "abort"}, {"name": "rbt_delete", "text": "Corollary rbt_delete x t : rbt_inv t -> rbt_inv (delete x t).", "decomposition": [], "retrieval": ["del_inv", "invh_paint", "paint_black"], "remove_type": "abort"}, {"name": "del_inv", "text": "Lemma del_inv x t : invc t && invh t -> [&& invh (del x t), (color t == Red) ==> (bh (del x t) == bh t) && invc (del x t) & (color t == Black) ==> (bh (del x t) == bh t - 1) && invc2 (del x t) ].", "decomposition": ["invch_ind"], "retrieval": ["inv_baldL", "inv_baldR", "split_min_inv", "invc2I"], "remove_type": "abort"}, {"name": "rbt_insert", "text": "Corollary rbt_insert x t : rbt_inv t -> rbt_inv (insert x t).", "decomposition": [], "retrieval": ["inv_ins", "invh_paint", "paint_black"], "remove_type": "abort"}, {"name": "inv_ins", "text": "Lemma inv_ins x t : invc t && invh t -> [&& invc2 (ins x t), (color t == Black) ==> invc (ins x t), invh (ins x t) & bh (ins x t) == bh t].", "decomposition": ["invch_ind"], "retrieval": ["inv_baliR", "invc2I", "inv_baliL"], "remove_type": "abort"}, {"name": "rbt_log_height", "text": "Lemma rbt_log_height t : rbt_inv t -> ((height t)./2 <= up_log 2 (size1_tree t))%N.", "decomposition": [], "retrieval": ["bh_size1"], "remove_type": "abort"}, {"name": "bh_size1", "text": "Lemma bh_size1 t : invc t && invh t -> (2 ^ (bh t) <= size1_tree t)%N.", "decomposition": ["invch_ind"], "retrieval": [], "remove_type": "abort"}, {"name": "bound_bht", "text": "Corollary bound_bht t : rbt_inv t -> (height t)./2 <= bh t.", "decomposition": [], "retrieval": ["height_black_height"], "remove_type": "abort"}, {"name": "height_black_height", "text": "Lemma height_black_height t : invc t && invh t -> (height t <= 2 * bh t + (color t == Red))%N.", "decomposition": ["invch_ind"], "retrieval": [], "remove_type": "abort"}, {"name": "invch_ind", "text": "Lemma invch_ind (P : rbt A -> Prop) : P (Leaf (A*col)) -> (forall l a c r, (c == Red) ==> (color l == Black) && (color r == Black) -> invc l -> invc r -> bh l == bh r -> invh l -> invh r -> P l -> P r -> P (Node l (a,c) r)) -> forall t, invc t && invh t -> P t.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "f5a2bb5cc750d936402ce4c8af1ba765ad0daeec": {"src/avl.v": [{"name": "inv_isin_list", "text": "Lemma inv_isin_list x t : invariant t -> isin_a t x = (x \\in inorder_a t).", "decomposition": [], "retrieval": ["inorder_isin_list"], "remove_type": "admit"}, {"name": "invariant_delete", "text": "Corollary invariant_delete x t : invariant t -> invariant (delete x t).", "decomposition": ["avl_delete"], "retrieval": ["del_list_sorted", "inorder_delete"], "remove_type": "admit"}, {"name": "invariant_insert", "text": "Corollary invariant_insert x t : invariant t -> invariant (insert x t).", "decomposition": ["avl_insert"], "retrieval": ["inorder_insert", "ins_list_sorted"], "remove_type": "admit"}, {"name": "invariant_empty", "text": "Corollary invariant_empty : invariant empty_a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "inorder_delete_list", "text": "Corollary inorder_delete_list x t : invariant t -> perm_eq (inorder_a (delete x t)) (filter (predC1 x) (inorder_a t)).", "decomposition": [], "retrieval": ["inorder_delete", "inorder_del_list"], "remove_type": "admit"}, {"name": "inorder_insert_list", "text": "Corollary inorder_insert_list x t : invariant t -> perm_eq (inorder_a (insert x t)) (if x \\in inorder_a t then inorder_a t else x :: inorder_a t).", "decomposition": [], "retrieval": ["inorder_insert", "inorder_ins_list"], "remove_type": "admit"}, {"name": "inorder_isin_list", "text": "Lemma inorder_isin_list x t : bst_list t -> isin_a t x = (x \\in inorder_a t).", "decomposition": [], "retrieval": ["sorted_cat_cons_cat", "cmp_eq", "cmp_lt", "cmp_gt"], "remove_type": "abort"}, {"name": "inorder_delete", "text": "Theorem inorder_delete x t : bst_list t -> inorder_a (delete x t) = del_list x (inorder_a t).", "decomposition": ["inorder_split_max", "inorder_balR", "inorder_balL"], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "dellist_sorted_cat_cons_cat", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_insert", "text": "Theorem inorder_insert x t : bst_list t -> inorder_a (insert x t) = ins_list x (inorder_a t).", "decomposition": ["inorder_balR", "inorder_balL"], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "cmp_gt", "inslist_sorted_cat_cons_cat", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_split_max", "text": "Lemma inorder_split_max l a r t x : split_max l a r = (t, x) -> inorder_a t ++ [:: x] = inorder_a l ++ a :: inorder_a r.", "decomposition": ["inorder_balL"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_balR", "text": "Lemma inorder_balR l a r : inorder_a (balR l a r) = inorder_a l ++ a :: inorder_a r.", "decomposition": ["ne_hgt", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_balL", "text": "Lemma inorder_balL l a r : inorder_a (balL l a r) = inorder_a l ++ a :: inorder_a r.", "decomposition": ["ne_hgt", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "avl_delete", "text": "Theorem avl_delete x t : avl t -> avl (delete x t) && ((height t == height (delete x t)) || (height t == height (delete x t) + 1)).", "decomposition": ["avl_split_max", "height_balL", "height_balR", "height_balR2", "dist_leq", "avl_balR", "height_balL2", "avl_balL"], "retrieval": [], "remove_type": "abort"}, {"name": "avl_split_max", "text": "Lemma avl_split_max l a r t x : split_max l a r = (t, x) -> `|height l - height r| <= 1%N -> avl l -> avl r -> avl t && ((height t == maxn (height l) (height r)) || (height t == maxn (height l) (height r) + 1)).", "decomposition": ["height_balL2", "height_balL", "avl_balL", "dist_leq"], "retrieval": [], "remove_type": "abort"}, {"name": "avl_insert", "text": "Theorem avl_insert x t : avl t -> avl (insert x t) && ((height (insert x t) == height t) || (height (insert x t) == height t + 1)).", "decomposition": ["height_balL", "height_balR", "height_balR2", "dist_leq", "avl_balR", "height_balL2", "avl_balL"], "retrieval": [], "remove_type": "abort"}, {"name": "avl_balR", "text": "Lemma avl_balR l a r : avl l -> avl r -> (height l - 1 <= height r <= height l + 2)%N -> avl (balR l a r).", "decomposition": ["ne_hgt", "dist_leqR", "ht_height", "dist_leqL", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "avl_balL", "text": "Lemma avl_balL l a r : avl l -> avl r -> (height r - 1 <= height l <= height r + 2)%N -> avl (balL l a r).", "decomposition": ["ne_hgt", "dist_leqR", "ht_height", "dist_leqL", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "height_balR2", "text": "Lemma height_balR2 l a r : avl l -> avl r -> height r != height l + 2 -> height (balR l a r) = maxn (height l) (height r) + 1.", "decomposition": ["ht_height", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "height_balL2", "text": "Lemma height_balL2 l a r : avl l -> avl r -> height l != height r + 2 -> height (balL l a r) = maxn (height l) (height r) + 1.", "decomposition": ["ht_height", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "height_balR", "text": "Lemma height_balR l a r : avl l -> avl r -> height r = height l + 2 -> (height (balR l a r) == height l + 2) || (height (balR l a r) == height l + 3).", "decomposition": ["ne_hgt", "dist_leqR", "ht_height", "dist_leqL", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "height_balL", "text": "Lemma height_balL l a r : avl l -> avl r -> height l = height r + 2 -> (height (balL l a r) == height r + 2) || (height (balL l a r) == height r + 3).", "decomposition": ["ne_hgt", "dist_leqR", "ht_height", "dist_leqL", "ne_hplus2"], "retrieval": [], "remove_type": "abort"}, {"name": "ne_hgt", "text": "Lemma ne_hgt (t1 t2 : tree_ht T) : non_empty_if (ht t2 < ht t1)%N t1.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "ne_hplus2", "text": "Lemma ne_hplus2 (t1 t2 : tree_ht T) : non_empty_if (ht t1 == ht t2 + 2) t1.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "height_bound", "text": "Corollary height_bound (t : tree_ht A) : avl t -> phi ^+ (height t) <= (size1_tree t)%:R.", "decomposition": ["fib_bound", "avl_fib"], "retrieval": [], "remove_type": "abort"}, {"name": "fib_bound", "text": "Lemma fib_bound n : phi ^+ n <= (fib (n + 2)) %:R.", "decomposition": ["phi_sq"], "retrieval": [], "remove_type": "abort"}, {"name": "phi_sq", "text": "Lemma phi_sq : phi ^+ 2 = phi + 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "avl_fib", "text": "Lemma avl_fib (t : tree_ht A) : avl t -> (fib (height t + 2) <= size1_tree t)%N.", "decomposition": ["dist_leqL", "dist_leqR", "fib_monotone"], "retrieval": [], "remove_type": "abort"}, {"name": "fib_monotone", "text": "Lemma fib_monotone : {homo fib : x y / (x <= y)%N}.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "dist_leqR", "text": "Corollary dist_leqR (a b c : nat) : (`|a - b| <= c -> b <= a -> a <= b + c)%N.", "decomposition": ["dist_leq"], "retrieval": [], "remove_type": "abort"}, {"name": "dist_leqL", "text": "Corollary dist_leqL (a b c : nat) : (`|a - b| <= c -> a <= b -> b <= a + c)%N.", "decomposition": ["dist_leq"], "retrieval": [], "remove_type": "abort"}, {"name": "dist_leq", "text": "Lemma dist_leq (a b c : nat) : (`|a - b| <= c -> (a <= b <= a + c) || (b <= a <= b + c))%N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ht_height", "text": "Lemma ht_height (t : tree_ht A) : avl t -> ht t = height t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "fe608b1ed8c9fa8eb7b62aa53adf9bfe6ddf3c4b": {"src/bst.v": [{"name": "invar_delete", "text": "Corollary invar_delete x (t : ivl_tree) : invar t -> invar (delete_i x t).", "decomposition": ["inv_max_hi_delete", "inorder_ivl_delete_list", "del_list_sorted"], "retrieval": [], "remove_type": "abort"}, {"name": "invar_insert", "text": "Corollary invar_insert x (t : ivl_tree) : invar t -> invar (insert_i x t).", "decomposition": ["inv_max_hi_insert", "ins_list_sorted", "inorder_ivl_insert_list"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_ivl_delete_list_set", "text": "Corollary inorder_ivl_delete_list_set x (t : ivl_tree) : invar t -> perm_eq (inorder_a (delete_i x t)) (filter (predC1 x) (inorder_a t)).", "decomposition": ["inorder_ivl_delete_list", "inorder_del_list"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_ivl_insert_list_set", "text": "Corollary inorder_ivl_insert_list_set x (t : ivl_tree) : invar t -> perm_eq (inorder_a (insert_i x t)) (if x \\in inorder_a t then inorder_a t else x :: inorder_a t).", "decomposition": ["inorder_ins_list", "inorder_ivl_insert_list"], "retrieval": [], "remove_type": "abort"}, {"name": "inv_max_hi_delete", "text": "Lemma inv_max_hi_delete x t : inv_max_hi t -> inv_max_hi (delete_i x t).", "decomposition": ["inv_max_split_min"], "retrieval": [], "remove_type": "abort"}, {"name": "inv_max_split_min", "text": "Lemma inv_max_split_min (l r t : ivl_tree) a x : split_min_i l a r = (x, t) -> inv_max_hi l -> inv_max_hi r -> inv_max_hi t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inv_max_hi_insert", "text": "Lemma inv_max_hi_insert x t : inv_max_hi t -> inv_max_hi (insert_i x t).", "decomposition": [], "retrieval": ["rmin"], "remove_type": "abort"}, {"name": "inorder_ivl_delete_list", "text": "Lemma inorder_ivl_delete_list x t : sorted <%O (inorder_a t) -> inorder_a (delete_i x t) = del_list x (inorder_a t).", "decomposition": ["inorder_ivl_split_min"], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "dellist_sorted_cat_cons_cat", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_ivl_insert_list", "text": "Lemma inorder_ivl_insert_list x t : sorted <%O (inorder_a t) -> inorder_a (insert_i x t ) = ins_list x (inorder_a t).", "decomposition": [], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "cmp_gt", "inslist_sorted_cat_cons_cat", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_ivl_split_min", "text": "Lemma inorder_ivl_split_min (l r t : ivl_tree) a x : split_min_i l a r = (x, t) -> x :: inorder_a t = inorder_a l ++ a :: inorder_a r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "max_hi_mem", "text": "Lemma max_hi_mem t : inv_max_hi t -> is_node t -> has (fun a => high a == max_hi t) (inorder_a t).", "decomposition": [], "retrieval": ["rmin"], "remove_type": "abort"}, {"name": "max_hi_max", "text": "Lemma max_hi_max t x : inv_max_hi t -> x \\in inorder_a t -> high x <= max_hi t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rmin", "text": "Lemma rmin : right_id x0 Order.max.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "overlapC", "text": "Lemma overlapC x y : overlap x y = overlap y x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "xivl_eqE", "text": "Lemma xivl_eqE x y : (x == y) = (low x == low y) && (high x == high y).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "bst_list_delete", "text": "Corollary bst_list_delete x (t : tree T) : bst_list t -> bst_list (delete x t).", "decomposition": ["del_list_sorted"], "retrieval": ["inorder_delete_list"], "remove_type": "abort"}, {"name": "bst_list_insert", "text": "Corollary bst_list_insert x (t : tree T) : bst_list t -> bst_list (insert x t).", "decomposition": ["ins_list_sorted"], "retrieval": ["inorder_insert_list"], "remove_type": "abort"}, {"name": "bst_list_empty", "text": "Corollary bst_list_empty : bst_list (@empty _ T).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_delete_list_set", "text": "Corollary inorder_delete_list_set x (t : tree T) : bst_list t -> perm_eq (inorder (delete x t)) (filter (predC1 x) (inorder t)).", "decomposition": ["inorder_del_list"], "retrieval": ["inorder_delete_list"], "remove_type": "abort"}, {"name": "inorder_insert_list_set", "text": "Corollary inorder_insert_list_set x (t : tree T) : bst_list t -> perm_eq (inorder (insert x t)) (if x \\in inorder t then inorder t else x :: inorder t).", "decomposition": ["inorder_ins_list"], "retrieval": ["inorder_insert_list"], "remove_type": "abort"}, {"name": "dellist_sorted_cat_cons_cat", "text": "Lemma dellist_sorted_cat_cons_cat (xs ys : seq T) x a : sorted <%O (xs ++ a :: ys) -> del_list x (xs ++ a :: ys) = if x < a then del_list x xs ++ a :: ys else xs ++ del_list x (a :: ys).", "decomposition": [], "retrieval": ["del_nop"], "remove_type": "abort"}, {"name": "inslist_sorted_cat_cons_cat", "text": "Lemma inslist_sorted_cat_cons_cat (xs ys : seq T) x a : sorted <%O (xs ++ [::a]) -> ins_list x (xs ++ a :: ys) = if x < a then ins_list x xs ++ a :: ys else xs ++ ins_list x (a :: ys).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "del_list_sorted", "text": "Lemma del_list_sorted x xs : sorted <%O xs -> sorted <%O (del_list x xs).", "decomposition": ["inorder_del_list"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_del_list", "text": "Lemma inorder_del_list x xs : sorted <%O xs -> perm_eq (del_list x xs) (filter (predC1 x) xs).", "decomposition": [], "retrieval": ["del_nop"], "remove_type": "abort"}, {"name": "ins_list_sorted", "text": "Lemma ins_list_sorted x xs : sorted <%O xs -> sorted <%O (ins_list x xs).", "decomposition": ["inorder_ins_list"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_ins_list", "text": "Lemma inorder_ins_list x xs : sorted <%O xs -> perm_eq (ins_list x xs) (if x \\in xs then xs else x :: xs).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_split_min", "text": "Lemma inorder_split_min (l r t : tree T) a x : split_min l a r = (x, t) -> x :: inorder t = inorder l ++ a :: inorder r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "<unknown>", "text": "Fact total_ivl : total le_ivl.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "c84d46b5e5b27932015203be18d4af77e302c36a": {}, "30bf23a126b39d3312e2563391d99c41d9e03abf": {}, "3df029f11464124033ef58c739fdf5a46230c144": {}, "c1a962767e9c07c1e0e972da2a2a07129e04bb13": {}, "f0001ff5be8e11c89eb60813c8494592e30ee4bb": {}, "27487c12ee0a75f17d37bbb3f2f2454c5d092912": {}, "0a5703086fc0820b3cd02352b757d1e1f45eeb05": {}, "529cfcd50a68c139a1f7ff506aafafc7d0ef8ba8": {}, "bef3ae055a154fe474fefacdacf9570192a3cf65": {}, "600c6c97573367f08484f0217b14bd2aa4192626": {}, "5d0c0399a59c4d3363d0fcc3f59cff0658ff1d61": {}, "134efa61efd4afe3b1caaf8728b5e83c5b50a2d6": {}, "bf41f44dddf21675c2198259337528eebcb3fd3d": {}, "0e3e27015b838db3e1aa333fe1476379259f1f36": {}, "371da80cd6a70f7c828b305b88a1dfa655c666b7": {}, "72ab2f03adff91182fa23d1d6d5a4c680ba0c010": {}, "13b916ea819cd9cb1e1af80e27ff44a92fcc66dd": {}, "35e22b40c47eb851ab38d42248138d861d5c9472": {}, "01f0cc21ae9033151258edef2922e9fa8f1f3494": {}, "93a695416f3379965660832c5474b2486c687739": {}, "41108c16b06b1093197ab937775e3fa9bd46cc78": {}, "35fb8921fb27cf27f5631130a2757228014e20c6": {}, "7e1e3b5973afc3c7f38784a592aa0f7d91b9734a": {}, "58fb2bd0f0897f9161493051f9e28c9636ae61cf": {}, "e1aaf325294a9b95b7634bf1650e1c9c5980ed6f": {}, "9d4e0c2ca02329882ae56337c1c88dc8bdbd8276": {}, "3aa0869cff3cb86610bdf8d05fa50a0a50f1088e": {}, "df6d857bfebc00d1fd19d82261c588c16210bf7b": {}, "43cf1030bb3528a655e0e144f88c98eafdc8cc51": {"src/twothree.v": [{"name": "inv_isin_list", "text": "Lemma inv_isin_list x (t : tree23 T) : invariant t -> isin23 t x = (x \\in inorder23 t).", "decomposition": [], "retrieval": ["inorder_isin_list"], "remove_type": "admit"}, {"name": "invariant_delete", "text": "Corollary invariant_delete x (t : tree23 T) : invariant t -> invariant (delete x t).", "decomposition": ["inorder_delete23", "complete_delete"], "retrieval": ["del_list_sorted"], "remove_type": "admit"}, {"name": "invariant_insert", "text": "Corollary invariant_insert x (t : tree23 T) : invariant t -> invariant (insert x t).", "decomposition": ["inorder_insert23", "complete_insert"], "retrieval": ["ins_list_sorted"], "remove_type": "admit"}, {"name": "invariant_empty", "text": "Corollary invariant_empty : invariant (@empty T).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "inorder_delete_list23", "text": "Corollary inorder_delete_list23 x (t : tree23 T) : invariant t -> perm_eq (inorder23 (delete x t)) (filter (predC1 x) (inorder23 t)).", "decomposition": ["inorder_delete23"], "retrieval": ["inorder_del_list"], "remove_type": "admit"}, {"name": "inorder_insert_list23", "text": "Corollary inorder_insert_list23 x (t : tree23 T) : invariant t -> perm_eq (inorder23 (insert x t)) (if x \\in inorder23 t then inorder23 t else x :: inorder23 t).", "decomposition": ["inorder_insert23"], "retrieval": ["inorder_ins_list"], "remove_type": "admit"}, {"name": "inorder_isin_list", "text": "Lemma inorder_isin_list x (t : tree23 T) : bst_list t -> isin23 t x = (x \\in inorder23 t).", "decomposition": [], "retrieval": ["cmp_eq", "sorted_rconsE", "sorted_cat_cons_cat", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "inorder_delete23", "text": "Lemma inorder_delete23 x t : complete23 t -> bst_list t -> inorder23 (delete x t) = del_list x (inorder23 t).", "decomposition": ["complete_lift", "height_empty", "inorderD22", "inorderD21", "inorderD33", "inorderD31", "split_minD", "inorder_lift", "inorderD32"], "retrieval": ["cmp_eq", "dellist_sorted_cat_cons_cat", "cmp_gt", "cmp_lt"], "remove_type": "abort"}, {"name": "split_minD", "text": "Lemma split_minD {A} (t : n23 A) x t' : split_min t = (x,t') -> completen23 t -> x :: inorder23 (treeD t') = inordern23 t.", "decomposition": ["split_minD2"], "retrieval": [], "remove_type": "abort"}, {"name": "split_minD2", "text": "Lemma split_minD2 {A} (l : tree23 A) a r x t' : split_min2 l a r = (x, t') -> height23 l = height23 r -> complete23 l -> complete23 r -> x :: inorder23 (treeD t') = inorder23 l ++ a :: inorder23 r with split_minD3 {A} (l : tree23 A) a m b r x t' : split_min3 l a m b r = (x, t') -> height23 l = height23 m -> height23 m = height23 r -> complete23 l -> complete23 m -> complete23 r -> x :: inorder23 (treeD t') = inorder23 l ++ a :: inorder23 m ++ b :: inorder23 r.", "decomposition": ["inorderD31", "height_empty", "inorderD21", "inorder_lift"], "retrieval": [], "remove_type": "abort"}, {"name": "inorderD33", "text": "Lemma inorderD33 {A} (l : tree23 A) a m b r' : inorder23 (treeD (node33 l a m b r')) = inorder23 l ++ a :: inordern23 m ++ b :: inorder23 (treeD r').", "decomposition": ["inorder_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "inorderD32", "text": "Lemma inorderD32 {A} (l : tree23 A) a m' b r : inorder23 (treeD (node32 l a m' b r)) = inorder23 l ++ a :: inorder23 (treeD m') ++ b :: inordern23 r.", "decomposition": ["inorder_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "inorderD31", "text": "Lemma inorderD31 {A} (l' : upD A) a m b r : inorder23 (treeD (node31 l' a m b r)) = inorder23 (treeD l') ++ a :: inordern23 m ++ b :: inorder23 r.", "decomposition": ["inorder_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "inorderD22", "text": "Lemma inorderD22 {A} (l : n23 A) a r' : inorder23 (treeD (node22 l a r')) = inordern23 l ++ a :: inorder23 (treeD r').", "decomposition": ["inorder_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "inorderD21", "text": "Lemma inorderD21 {A} (l' : upD A) a r : inorder23 (treeD (node21 l' a r)) = inorder23 (treeD l') ++ a :: inordern23 r.", "decomposition": ["inorder_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_insert23", "text": "Lemma inorder_insert23 x t : bst_list t -> inorder23 (insert x t) = ins_list x (inorder23 t).", "decomposition": [], "retrieval": ["cmp_eq", "sorted_cat_cons_cat", "cmp_gt", "inslist_sorted_cat_cons_cat", "cmp_lt"], "remove_type": "abort"}, {"name": "complete_delete", "text": "Lemma complete_delete t (x : T) : complete23 t -> complete23 (delete x t).", "decomposition": ["complete_treeD"], "retrieval": [], "remove_type": "abort"}, {"name": "complete_treeD", "text": "Lemma complete_treeD t (x : T) : complete23 t -> complete23 (treeD (del x t)).", "decomposition": ["complete21", "complete31", "complete_lift", "complete32", "complete33", "height_lift", "complete22", "split_min_completeD", "hD_del", "split_min_hD"], "retrieval": [], "remove_type": "abort"}, {"name": "hD_del", "text": "Lemma hD_del t (x : T) : complete23 t -> hD (del x t) = height23 t.", "decomposition": ["hD21", "complete_lift", "hD31", "height_lift", "hD22", "hD33", "hD32", "split_min_hD"], "retrieval": [], "remove_type": "abort"}, {"name": "split_min_completeD", "text": "Lemma split_min_completeD {A} (t : n23 A) x t' : split_min t = (x, t') -> completen23 t -> complete23 (treeD t').", "decomposition": ["split_min_completeD2"], "retrieval": [], "remove_type": "abort"}, {"name": "split_min_hD", "text": "Lemma split_min_hD {A} (t : n23 A) x t' : split_min t = (x, t') -> completen23 t -> hD t' = heightn23 t.", "decomposition": ["split_min_hD2"], "retrieval": [], "remove_type": "abort"}, {"name": "split_min_completeD2", "text": "Lemma split_min_completeD2 {A} (l : tree23 A) a r x t' : split_min2 l a r = (x, t') -> height23 l = height23 r -> complete23 l -> complete23 r -> complete23 (treeD t') with split_min_completeD3 {A} (l : tree23 A) a m b r x t': split_min3 l a m b r = (x, t') -> height23 l = height23 m -> height23 m = height23 r -> complete23 l -> complete23 m -> complete23 r -> complete23 (treeD t').", "decomposition": ["complete21", "complete31", "complete_lift", "split_min_hD2", "height_lift"], "retrieval": [], "remove_type": "abort"}, {"name": "split_min_hD2", "text": "Lemma split_min_hD2 {A} (l : tree23 A) a r x t': split_min2 l a r = (x, t') -> height23 l = height23 r -> complete23 l -> complete23 r -> hD t' = maxn (height23 l) (height23 r) + 1 with split_min_hD3 {A} (l : tree23 A) a m b r x t': split_min3 l a m b r = (x, t') -> height23 l = height23 m -> height23 m = height23 r -> complete23 l -> complete23 m -> complete23 r -> hD t' = maxn (height23 l) (maxn (height23 m) (height23 r)) + 1.", "decomposition": ["hD21", "hD31", "height_lift"], "retrieval": [], "remove_type": "abort"}, {"name": "complete33", "text": "Lemma complete33 {A} (l : tree23 A) a m b r' : height23 l = heightn23 m -> heightn23 m = hD r' -> complete23 l -> completen23 m -> complete23 (treeD r') -> complete23 (treeD (node33 l a m b r')).", "decomposition": ["complete_embed", "height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "complete32", "text": "Lemma complete32 {A} (l : tree23 A) a m' b r : height23 l = hD m' -> hD m' = heightn23 r -> complete23 l -> complete23 (treeD m') -> completen23 r -> complete23 (treeD (node32 l a m' b r)).", "decomposition": ["complete_embed", "height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "complete31", "text": "Lemma complete31 {A} (l' : upD A) a m b r : hD l' = heightn23 m -> heightn23 m = height23 r -> complete23 (treeD l') -> completen23 m -> complete23 r -> complete23 (treeD (node31 l' a m b r)).", "decomposition": ["complete_embed", "height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "complete22", "text": "Lemma complete22 {A} (l : n23 A) a r' : heightn23 l = hD r' -> completen23 l -> complete23 (treeD r') -> complete23 (treeD (node22 l a r')).", "decomposition": ["complete_embed", "height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "complete21", "text": "Lemma complete21 {A} (l' : upD A) a r : hD l' = heightn23 r -> complete23 (treeD l') -> completen23 r -> complete23 (treeD (node21 l' a r)).", "decomposition": ["complete_embed", "height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "hD33", "text": "Lemma hD33 {A} (l : tree23 A) a m b r' : hD (node33 l a m b r') = maxn (height23 l) (maxn (heightn23 m) (hD r')) + 1.", "decomposition": ["height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "hD32", "text": "Lemma hD32 {A} (l : tree23 A) a m' b r : hD (node32 l a m' b r) = maxn (height23 l) (maxn (hD m') (heightn23 r)) + 1.", "decomposition": ["height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "hD31", "text": "Lemma hD31 {A} (l' : upD A) a m b r : hD (node31 l' a m b r) = maxn (hD l') (maxn (heightn23 m) (height23 r)) + 1.", "decomposition": ["height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "hD22", "text": "Lemma hD22 {A} (l : n23 A) a r' : hD (node22 l a r') = maxn (heightn23 l) (hD r') + 1.", "decomposition": ["height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "hD21", "text": "Lemma hD21 {A} (l' : upD A) a r : hD (node21 l' a r) = maxn (hD l') (heightn23 r) + 1.", "decomposition": ["height_embed"], "retrieval": [], "remove_type": "abort"}, {"name": "complete_insert", "text": "Lemma complete_insert x (t : tree23 T) : complete23 t -> complete23 (insert x t).", "decomposition": ["complete_ins"], "retrieval": [], "remove_type": "abort"}, {"name": "complete_ins", "text": "Lemma complete_ins (x : T) t : complete23 t -> complete23 (treeI (ins x t)) /\\ hI (ins x t) = height23 t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "complete_lift", "text": "Lemma complete_lift {A} (t : tree23 A) (n : n23 A) : lift t = Some n -> complete23 t = completen23 n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "complete_embed", "text": "Lemma complete_embed {A} (t : n23 A) : completen23 t = complete23 (embed t).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "height_lift", "text": "Lemma height_lift {A} (t : tree23 A) (n : n23 A) : lift t = Some n -> height23 t = heightn23 n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "height_embed", "text": "Lemma height_embed {A} (t : n23 A) : heightn23 t = height23 (embed t).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_lift", "text": "Lemma inorder_lift {A} (t : tree23 A) (n : n23 A) : lift t = Some n -> inorder23 t = inordern23 n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inorder_embed", "text": "Lemma inorder_embed {A} (t : n23 A) : inordern23 t = inorder23 (embed t).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "complete_size23", "text": "Lemma complete_size23 t : complete23 t -> 2^height23 t <= size23 t + 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "height_empty", "text": "Lemma height_empty t : height23 t == 0 -> t = empty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "8a52c261e9b186f61c25c44a71e76abe25516f12": {}, "70b0b04eb725edeb4f8886529c9f870fa2eccb42": {}, "284876ca1b79d25c6f36f00ee7bbe17039025d78": {}, "d77d78f775edc8a1e893f2d80ade7d34c784fc80": {}, "20ff10ea3b1a9d19fb36254f3396c1b2b71016eb": {}, "915f86d9abffd976b80c7ed8dcb46f15b935eb24": {}, "411d7b48ac29f77075df37e3898fc1745ea1a4f8": {"src/prelude.v": [{"name": "perm_allrelr", "text": "Lemma perm_allrelr {A B : eqType} r (s : seq A) (s1 s2 : seq B) : perm_eq s1 s2 -> allrel r s s1 = allrel r s s2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "perm_allrell", "text": "Lemma perm_allrell {A B : eqType} r (s : seq A) (s1 s2 : seq B) : perm_eq s1 s2 -> allrel r s1 s = allrel r s2 s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and14P", "text": "Lemma and14P : reflect [/\\ b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13 & b14] [&& b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13 & b14].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and13P", "text": "Lemma and13P : reflect [/\\ b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12 & b13] [&& b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12 & b13].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and12P", "text": "Lemma and12P : reflect [/\\ b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11 & b12] [&& b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11 & b12].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and11P", "text": "Lemma and11P : reflect [/\\ b1, b2, b3, b4, b5, b6, b7, b8, b9, b10 & b11] [&& b1, b2, b3, b4, b5, b6, b7, b8, b9, b10 & b11].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and10P", "text": "Lemma and10P : reflect [/\\ b1, b2, b3, b4, b5, b6, b7, b8, b9 & b10] [&& b1, b2, b3, b4, b5, b6, b7, b8, b9 & b10].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and9P", "text": "Lemma and9P : reflect [/\\ b1, b2, b3, b4, b5, b6, b7, b8 & b9] [&& b1, b2, b3, b4, b5, b6, b7, b8 & b9].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and8P", "text": "Lemma and8P : reflect [/\\ b1, b2, b3, b4, b5, b6, b7 & b8] [&& b1, b2, b3, b4, b5, b6, b7 & b8].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and7P", "text": "Lemma and7P : reflect [/\\ b1, b2, b3, b4, b5, b6 & b7] [&& b1, b2, b3, b4, b5, b6 & b7].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and6P", "text": "Lemma and6P : reflect [/\\ b1, b2, b3, b4, b5 & b6] [&& b1, b2, b3, b4, b5 & b6].", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "8977922dd4d89333a811488423d6268da863680a": {}, "6a7533ccc5f458e6c4823de999af84c7b659300d": {}, "3d4a3367464f09a1d506e46ca120ea56858c1f8e": {}}