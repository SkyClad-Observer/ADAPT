{"2d6d348ed5275ee7e244f0c292c3f1c3f732ac80": {"theories/Open.v": [{"name": "subst_app", "text": "Lemma subst_app {A B} [w0] (f : Open (A -> B) w0) (a : Open A w0) [w1] (\u03b8 : \u0398 w0 w1) : subst (ap f a) \u03b8 = ap (subst f \u03b8) (subst a \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_fmap", "text": "Lemma subst_fmap {A B} (f : A -> B) [w0] (a : Open A w0) [w1] (\u03b8 : \u0398 w0 w1) : subst (fmap f a) \u03b8 = fmap f (subst a \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_pure", "text": "Lemma subst_pure {A} (a : A) [w0 w1] (\u03b8 : \u0398 w0 w1) : subst (pure a) \u03b8 = pure a.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Sub/Parallel.v": [{"name": "subst_hmap", "text": "Lemma subst_hmap {\u0398 : SUB} {T} {subT : Subst T} {subLT : SubstLaws T} [w0 w1] (\u03b8 : \u0398 w0 w1) : forall t, subst t (hmap \u03b8) = subst t \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Ty_subterm_subst", "text": "Lemma Ty_subterm_subst {w1 w2} (s t : OTy w1) (\u03b8 : Par w1 w2) : oty.OTy_subterm s t -> oty.OTy_subterm (subst s \u03b8) (subst t \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "thin_thick_pointful", "text": "Lemma thin_thick_pointful {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (s : OTy (w - \u03b1)) (t : OTy (w - \u03b1)) : subst (subst t (thin \u03b1)) (thick \u03b1 s) = t.", "decomposition": [], "retrieval": ["comp_thin_thick"], "remove_type": "abort"}], "theories/Environment.v": [{"name": "lookup_map", "text": "Lemma lookup_map {\u0393} (E : Env D1 \u0393) : \u2200 [b] (bIn\u0393 : b \u2208 \u0393), lookup (map E) bIn\u0393 = f (lookup E bIn\u0393).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Sub/Triangular.v": [{"name": "subst_outer_subst", "text": "Lemma subst_outer_subst {w0 w1} (\u03b8 : w0 \u2292\u207b w1) (t : OTy w0) : subst_outer t \u03b8 = subst t \u03b8.", "decomposition": ["subst_outer_fix"], "retrieval": [], "remove_type": "admit"}, {"name": "subst_outer_trans", "text": "Lemma subst_outer_trans {w0 w1 w2 \u03c4} (\u03b81 : w0 \u2292\u207b w1) (\u03b82 : w1 \u2292\u207b w2) : subst_outer \u03c4 (\u03b81 \u2299 \u03b82) = subst_outer (subst_outer \u03c4 \u03b81) \u03b82.", "decomposition": ["subst_outer_subst_inner", "proper_subst_inner"], "retrieval": [], "remove_type": "admit"}, {"name": "subst_outer_subst_inner", "text": "Lemma subst_outer_subst_inner {w0 w1} (t : OTy w0) (rec : \u2200 y (yIn : y \u2208 w0), OTy w1) {w2} (r : w1 \u2292\u207b w2) : subst_outer (subst_inner rec t) r = subst_inner (fun y yIn => subst_outer (rec y yIn) r) t.", "decomposition": ["subst_outer_fix"], "retrieval": [], "remove_type": "abort"}, {"name": "subst_subst_inner", "text": "Lemma subst_subst_inner {w0 w1} (t : OTy w0) (rec : \u2200 y (yIn : y \u2208 w0), OTy w1) {w2} (r : w1 \u2292\u207b w2) : subst (subst_inner rec t) r = subst_inner (fun y yIn => subst (rec y yIn) r) t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_outer_refl", "text": "Lemma subst_outer_refl {w} (t : OTy w) : subst_outer t refl = t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_outer_fix", "text": "Lemma subst_outer_fix {w0 w1} (\u03b8 : w0 \u2292\u207b w1) (t : OTy w0) : subst_outer t \u03b8 = match t with | oty.evar \u03b1In => lk \u03b8 \u03b1In | oty.bool => oty.bool | oty.func t1 t2 => oty.func (subst_outer t1 \u03b8) (subst_outer t2 \u03b8) end.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "proper_subst_inner", "text": "Lemma proper_subst_inner {w0 w1} (rec1 rec2 : \u2200 \u03b1, \u03b1 \u2208 w0 \u2192 OTy w1) (Hrec : \u2200 \u03b1 (\u03b1In : \u03b1 \u2208 w0), rec1 \u03b1 \u03b1In = rec2 \u03b1 \u03b1In) : \u2200 \u03c4, subst_inner rec1 \u03c4 = subst_inner rec2 \u03c4.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Instantiation.v": [{"name": "inst_step", "text": "Lemma inst_step {\u0398} {step\u0398 : Step \u0398} {lkStep\u0398 : LkStep \u0398} {w x} (\u03b9 : Assignment (w \u060c x)) : inst (step (\u0398 := \u0398)) \u03b9 = let (\u03b9',_) := env.view \u03b9 in \u03b9'.", "decomposition": [], "retrieval": ["inst_step_snoc"], "remove_type": "abort"}, {"name": "inst_trans", "text": "Lemma inst_trans {\u0398} {trans\u0398 : Trans \u0398} {lktrans\u0398 : LkTrans \u0398} : forall w0 w1 w2 (\u03b81 : \u0398 w0 w1) (\u03b82 : \u0398 w1 w2) (\u03b9 : Assignment w2), inst (trans \u03b81 \u03b82) \u03b9 = inst \u03b81 (inst \u03b82 \u03b9).", "decomposition": [], "retrieval": ["lookup_extensional", "lookup_tabulate", "lk_trans"], "remove_type": "abort"}], "theories/Unification.v": [{"name": "solve_correct", "text": "Lemma solve_correct `{LkHMap Tri \u0398} {w} (C : List (OTy * OTy) w) : WP (solve (\u0398 := \u0398) C) (fun _ _ _ => \u22a4\u209a)%P \u22a3\u22a2\u209a instpred C.", "decomposition": ["subst_pred_refl", "instpred_solved_hmap"], "retrieval": ["asolve_correct"], "remove_type": "abort"}, {"name": "aflex_correct", "text": "Lemma aflex_correct {\u03b1} (\u03b1In : \u03b1 \u2208 w) (t : OTy w) w1 (\u03b81 : w \u2291\u207b w1) : instpred (aflex lamgu \u03b1 t \u03b81) \u22a3\u22a2\u209a (oty.evar \u03b1In =\u209a t)[\u03b81].", "decomposition": ["subst_pred_refl", "subst_eq"], "retrieval": ["flex_correct"], "remove_type": "abort"}, {"name": "instpred_cand_intro", "text": "Lemma instpred_cand_intro {w0} (c1 c2 : C w0) P Q : (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (c1 w1 \u03b81) \u22a3\u22a2\u209a P[\u03b81]) \u2192 (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (c2 w1 \u03b81) \u22a3\u22a2\u209a Q[\u03b81]) \u2192 (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (cand c1 c2 \u03b81) \u22a3\u22a2\u209a (P /\\\u209a Q)[\u03b81]).", "decomposition": ["wp_solved_frame", "subst_pred_trans", "and_true_l", "subst_and", "wp_solved_bind"], "retrieval": [], "remove_type": "abort"}], "theories/Monad/Interface.v": [{"name": "instpred_solved_hmap", "text": "Lemma instpred_solved_hmap `{LkHMap \u03981 \u03982} {A} `{ipA : InstPred A} {w} (m : Solved \u03981 A w) : instpred (solved_hmap m) \u22a3\u22a2\u209a instpred m.", "decomposition": ["wp_hmap"], "retrieval": [], "remove_type": "abort"}, {"name": "wp_solved_bind", "text": "Lemma wp_solved_bind {\u0398} {trans\u0398 : Trans \u0398} {lkTrans\u0398 : LkTrans \u0398} {A B w0} (m : Solved \u0398 A w0) (f : \u25fb(A \u21e2 Solved \u0398 B) w0) (Q : \u25fb(B \u21e2 Pred) w0) : WP (bind m f) Q \u22a3\u22a2\u209a WP m (fun w1 \u03b61 a1 => WP (f w1 \u03b61 a1) (_4 Q \u03b61)).", "decomposition": ["wp_false", "wp_trans"], "retrieval": [], "remove_type": "abort"}, {"name": "wp_solved_pure", "text": "Lemma wp_solved_pure {\u0398} {refl\u0398 : Refl \u0398} {lkrefl\u0398 : LkRefl \u0398} {A w0} (a : A w0) (Q : \u25fb(A \u21e2 Pred) w0) : wp_solved (pure (M := Solved \u0398) a) Q \u22a3\u22a2\u209a Q _ refl a.", "decomposition": ["wp_refl"], "retrieval": [], "remove_type": "abort"}, {"name": "wp_solved_frame", "text": "Lemma wp_solved_frame {\u0398 A w} (m : Solved \u0398 A w) (P : \u25fb(A \u21e2 Pred) w) (Q : Pred w) : WP m P /\\\u209a Q \u22a3\u22a2\u209a WP m (fun w1 \u03b81 a1 => P w1 \u03b81 a1 /\\\u209a subst Q \u03b81).", "decomposition": ["and_wp_l"], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_mono'", "text": "Lemma wlp_mono' `{TypeCheckLogicM \u0398 M} {A w} (m : M A w) (P Q : \u25fb(A \u21e2 Pred) w) : (WLP m P -\u2217 \u25fc(fun _ \u03b81 => \u2200\u209a a1, P _ \u03b81 a1 -\u2217 Q _ \u03b81 a1) -\u2217 WLP m Q)%P.", "decomposition": ["wlp_mono"], "retrieval": [], "remove_type": "abort"}, {"name": "wp_mono'", "text": "Lemma wp_mono' `{TypeCheckLogicM \u0398 M} {A w} (m : M A w) (P Q : \u25fb(A \u21e2 Pred) w) : (WP m P -\u2217 \u25fc(fun _ \u03b81 => \u2200\u209a a1, P _ \u03b81 a1 -\u2217 Q _ \u03b81 a1) -\u2217 WP m Q)%P.", "decomposition": ["wp_mono"], "retrieval": [], "remove_type": "abort"}], "theories/BaseLogic.v": [{"name": "subst_pbox", "text": "Lemma subst_pbox `{LkTrans \u0398} [w] (Q : \u25fbPred w) [w1] (\u03b81 : \u0398 w w1) : (\u25fcQ)[\u03b81] \u22a2\u209a \u25fc(Q[\u03b81]).", "decomposition": [], "retrieval": ["inst_trans"], "remove_type": "admit"}, {"name": "eq_func", "text": "Lemma eq_func {w} (s1 s2 t1 t2 : OTy w) : oty.func s1 s2 =\u209a oty.func t1 t2 \u22a3\u22a2\u209a (s1 =\u209a t1) /\\\u209a (s2 =\u209a t2).", "decomposition": ["peq_ty_noconfusion"], "retrieval": [], "remove_type": "admit"}, {"name": "eq\u209a_insert", "text": "Lemma eq\u209a_insert {w} (G1 G2 : OEnv w) (x : string) (t1 t2 : OTy w) : G1 =\u209a G2 /\\\u209a t1 =\u209a t2 \u22a2\u209a insert (M := OEnv w) x t1 G1 =\u209a insert (M := OEnv w) x t2 G2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pno_cycle", "text": "Lemma pno_cycle {w} (t1 t2 : OTy w) (Hsub : oty.OTy_subterm t1 t2) : t1 =\u209a t2 \u22a2\u209a \u22a5\u209a.", "decomposition": [], "retrieval": ["no_cycle", "inst_subterm"], "remove_type": "abort"}, {"name": "instpred_list_app", "text": "Lemma instpred_list_app {A} `{ipA : InstPred A} [w] (xs ys : List A w) : instpred (xs ++ ys) \u22a3\u22a2\u209a instpred xs /\\\u209a instpred ys.", "decomposition": ["and_true_l", "and_assoc"], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_hmap", "text": "Lemma wlp_hmap `{LkHMap \u03981 \u03982} [w0 w1] (\u03b8 : \u03981 w0 w1) P : wlp (hmap \u03b8) P \u22a3\u22a2\u209a wlp \u03b8 P.", "decomposition": [], "retrieval": ["inst_hmap"], "remove_type": "abort"}, {"name": "wp_hmap", "text": "Lemma wp_hmap `{LkHMap \u03981 \u03982} [w0 w1] (\u03b8 : \u03981 w0 w1) P : wp (hmap \u03b8) P \u22a3\u22a2\u209a wp \u03b8 P.", "decomposition": [], "retrieval": ["inst_hmap"], "remove_type": "abort"}, {"name": "wp_split", "text": "Lemma wp_split {\u0398 : SUB} [w0 w1] (\u03b8 : \u0398 w0 w1) P : wp \u03b8 \u22a4\u209a /\\\u209a wlp \u03b8 P \u22a2\u209a wp \u03b8 P.", "decomposition": ["and_true_l", "and_wp_l", "subst_wlp"], "retrieval": [], "remove_type": "abort"}, {"name": "intro_wp_step", "text": "Lemma intro_wp_step {\u0398} {step\u0398 : Step \u0398} {lkStep\u0398 : LkStep \u0398} t {w \u03b1} (Q : Pred (w \u060c \u03b1)) : wlp step (lift t =\u209a oty.evar world.in_zero ->\u209a Q) \u22a2\u209a wp (step (\u0398 := \u0398)) Q.", "decomposition": ["subst_wlp"], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_frame", "text": "Lemma wlp_frame {w0 w1} (\u03b8 : \u0398 w0 w1) (P : Pred _) (Q : Pred _) : P ->\u209a wlp \u03b8 Q \u22a3\u22a2\u209a wlp \u03b8 (subst P \u03b8 ->\u209a Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_wp", "text": "Lemma subst_wp {w0 w1} {\u03b8 : \u0398 w0 w1} (P : Pred w1) : P \u22a2\u209a subst (wp \u03b8 P) \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_wlp", "text": "Lemma subst_wlp {w0 w1} {\u03b8 : \u0398 w0 w1} (P : Pred w1) : subst (wlp \u03b8 P) \u03b8 \u22a2\u209a P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_impl", "text": "Lemma wp_impl {w0 w1} (\u03b81 : \u0398 w0 w1) (P : Pred _) (Q : Pred _) : (wp \u03b81 P ->\u209a Q) \u22a3\u22a2\u209a wlp \u03b81 (P ->\u209a subst Q \u03b81).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "entails_wp", "text": "Lemma entails_wp {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : (P \u22a2\u209a subst Q \u03b8) <-> (wp \u03b8 P \u22a2\u209a Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "entails_wlp", "text": "Lemma entails_wlp {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : (subst P \u03b8 \u22a2\u209a Q) <-> (P \u22a2\u209a wlp \u03b8 Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_mono", "text": "Lemma wlp_mono {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : wlp \u03b8 (interface.bi_wand P Q) \u22a2\u209a interface.bi_wand (wlp \u03b8 P) (wlp \u03b8 Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_mono", "text": "Lemma wp_mono {w0 w1} (\u03b8 : \u0398 w0 w1) P Q: wlp \u03b8 (interface.bi_wand P Q) \u22a2\u209a interface.bi_wand (wp \u03b8 P) (wp \u03b8 Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_or", "text": "Lemma wp_or {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : wp \u03b8 P \\/\u209a wp \u03b8 Q \u22a3\u22a2\u209a wp \u03b8 (P \\/\u209a Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_and", "text": "Lemma wlp_and {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : wlp \u03b8 P /\\\u209a wlp \u03b8 Q \u22a3\u22a2\u209a wlp \u03b8 (P /\\\u209a Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_true", "text": "Lemma wlp_true {w0 w1} (\u03b8 : \u0398 w0 w1) : wlp \u03b8 \u22a4\u209a \u22a3\u22a2\u209a \u22a4\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_trans", "text": "Lemma wlp_trans {transR : Trans \u0398} {lktrans\u0398 : LkTrans \u0398} {w0 w1 w2} (\u03b81 : \u0398 w0 w1) (\u03b82 : \u0398 w1 w2) Q : wlp (\u03b81 \u2299 \u03b82) Q \u22a3\u22a2\u209a wlp \u03b81 (wlp \u03b82 Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_refl", "text": "Lemma wlp_refl {refl\u0398 : Refl \u0398} {lkrefl\u0398 : LkRefl \u0398} {w} (Q : Pred w) : wlp refl Q \u22a3\u22a2\u209a Q.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_thick", "text": "Lemma wp_thick {thick\u0398 : Thick \u0398} {lkThick\u0398 : LkThick \u0398} {w \u03b1} (\u03b1In : world.In \u03b1 w) (t : OTy (w - \u03b1)) (Q : Pred (w - \u03b1)) : wp (thick \u03b1 t) Q \u22a3\u22a2\u209a oty.evar \u03b1In =\u209a subst t (thin (\u0398 := Par) \u03b1) /\\\u209a subst Q (thin (\u0398 := Par) \u03b1).", "decomposition": [], "retrieval": ["insert_remove", "inst_thick", "lookup_insert", "remove_insert"], "remove_type": "abort"}, {"name": "and_wp_r", "text": "Lemma and_wp_r {w0 w1} (\u03b8 : \u0398 w0 w1) (P : Pred w0) (Q : Pred w1) : P /\\\u209a wp \u03b8 Q \u22a3\u22a2\u209a wp \u03b8 (subst P \u03b8 /\\\u209a Q).", "decomposition": ["and_wp_l", "and_comm"], "retrieval": [], "remove_type": "abort"}, {"name": "and_wp_l", "text": "Lemma and_wp_l {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : wp \u03b8 P /\\\u209a Q \u22a3\u22a2\u209a wp \u03b8 (P /\\\u209a subst Q \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_false", "text": "Lemma wp_false {w0 w1} (\u03b8 : \u0398 w0 w1) : wp \u03b8 \u22a5\u209a \u22a3\u22a2\u209a \u22a5\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_trans", "text": "Lemma wp_trans {transR : Trans \u0398} {lktrans\u0398 : LkTrans \u0398} {w0 w1 w2} (\u03b81 : \u0398 w0 w1) (\u03b82 : \u0398 w1 w2) Q : wp (\u03b81 \u2299 \u03b82) Q \u22a3\u22a2\u209a wp \u03b81 (wp \u03b82 Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_refl", "text": "Lemma wp_refl {refl\u0398 : Refl \u0398} {lkrefl\u0398 : LkRefl \u0398} {w} (Q : Pred w) : wp refl Q \u22a3\u22a2\u209a Q.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_tpb", "text": "Lemma subst_tpb {w0 w1} (\u03b8 : \u0398 w0 w1) G (e : Exp) (t : OTy w0) (ee : OExp w0) : subst (G |--\u209a e; t ~> ee) \u03b8 \u22a3\u22a2\u209a subst G \u03b8 |--\u209a e; subst t \u03b8 ~> subst ee \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_exists", "text": "Lemma subst_exists [A] [w0 w1] (\u03b8 : \u0398 w0 w1) (Q : A -> Pred w0) : subst (\u2203\u209a a : A, Q a) \u03b8 \u22a3\u22a2\u209a (\u2203\u209a a : A, subst (Q a) \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_forall", "text": "Lemma subst_forall [A] [w0 w1] (\u03b8 : \u0398 w0 w1) (Q : A -> Pred w0) : subst (\u2200\u209a a : A, Q a) \u03b8 \u22a3\u22a2\u209a (\u2200\u209a a : A, subst (Q a) \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_true", "text": "Lemma subst_true {w0 w1} (\u03b8 : \u0398 w0 w1) : subst \u22a4\u209a \u03b8 \u22a3\u22a2\u209a \u22a4\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_false", "text": "Lemma subst_false {w0 w1} (\u03b8 : \u0398 w0 w1) : subst \u22a5\u209a \u03b8 \u22a3\u22a2\u209a \u22a5\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_wand", "text": "Lemma subst_wand {w0 w1} (\u03b8 : \u0398 w0 w1) (P Q : Pred w0) : subst (interface.bi_wand P Q) \u03b8 \u22a3\u22a2\u209a interface.bi_wand (subst P \u03b8) (subst Q \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_impl", "text": "Lemma subst_impl {w0 w1} (\u03b8 : \u0398 w0 w1) (P Q : Pred w0) : subst (P ->\u209a Q) \u03b8 \u22a3\u22a2\u209a (subst P \u03b8 ->\u209a subst Q \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_and", "text": "Lemma subst_and {w0 w1} (\u03b8 : \u0398 w0 w1) (P Q : Pred w0) : subst (P /\\\u209a Q) \u03b8 \u22a3\u22a2\u209a subst P \u03b8 /\\\u209a subst Q \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_pred_trans", "text": "Lemma subst_pred_trans `{lktrans\u0398 : LkTrans \u0398} {w0 w1 w2} (\u03b81 : \u0398 w0 w1) (\u03b82 : \u0398 w1 w2) (P : Pred w0) : subst P (\u03b81 \u2299 \u03b82) \u22a3\u22a2\u209a subst (subst P \u03b81) \u03b82.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_pred_refl", "text": "Lemma subst_pred_refl `{lkRefl\u0398 : LkRefl \u0398} [w] (P : Pred w) : subst P refl \u22a3\u22a2\u209a P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_eq", "text": "Lemma subst_eq {T : OType} {substT : Subst T} {A : Type} {instTA : Inst T A} {instSubstTA : InstSubst T A} {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) (t1 t2 : T w0) : subst (t1 =\u209a t2) \u03b8 \u22a3\u22a2\u209a subst t1 \u03b8 =\u209a subst t2 \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "eq_pair", "text": "Lemma eq_pair {AT BT : OType} {A B : Type} {instA : Inst AT A} {instB : Inst BT B} [w] (a1 a2 : AT w) (b1 b2 : BT w) : (a1,b1) =\u209a (a2,b2) \u22a3\u22a2\u209a ((a1 =\u209a a2) /\\\u209a (b1 =\u209a b2)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "peq_ty_noconfusion", "text": "Lemma peq_ty_noconfusion {w} (t1 t2 : OTy w) : t1 =\u209a t2 \u22a3\u22a2\u209a match t1 , t2 with | oty.evar _ , _ => t1 =\u209a t2 | _ , oty.evar _ => t1 =\u209a t2 | oty.bool , oty.bool => \u22a4\u209a | oty.func t11 t12 , oty.func t21 t22 => t11 =\u209a t21 /\\\u209a t12 =\u209a t22 | _ , _ => \u22a5\u209a end.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eq\u209a_trans", "text": "Lemma eq\u209a_trans {w} (s t u : T w) : s =\u209a t /\\\u209a t =\u209a u \u22a2\u209a s =\u209a u.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "eq\u209a_sym", "text": "Lemma eq\u209a_sym {w} (s t : T w) : s =\u209a t \u22a3\u22a2\u209a t =\u209a s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eq\u209a_refl", "text": "Lemma eq\u209a_refl {w} (t : T w) : t =\u209a t \u22a3\u22a2\u209a \u22a4\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "eq\u209a_intro", "text": "Lemma eq\u209a_intro {w} (t : T w) : \u22a2 (t =\u209a t)%P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pApply_r", "text": "Lemma pApply_r {w} {P Q R : Pred w} : Q \u22a2\u209a R -> P \u22a2\u209a Q -> P \u22a2\u209a R.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pApply", "text": "Lemma pApply {w} {P Q R : Pred w} : P \u22a2\u209a Q -> Q \u22a2\u209a R -> P \u22a2\u209a R.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wand_is_impl", "text": "Lemma wand_is_impl [w] (P Q : Pred w) : (P -\u2217 Q)%I \u22a3\u22a2\u209a (P ->\u209a Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exists_r", "text": "Lemma exists_r {I : Type} {w} P (Q : I -> Pred w) : (exists x : I, P \u22a2\u209a Q x) -> P \u22a2\u209a (\u2203\u209a x : I, Q x).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "exists_l", "text": "Lemma exists_l {I : Type} {w} (P : I -> Pred w) (Q : Pred w) : (forall x : I, P x \u22a2\u209a Q) -> (\u2203\u209a x : I, P x) \u22a2\u209a Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "impl_and", "text": "Lemma impl_and [w] (P Q R : Pred w) : ((P /\\\u209a Q) ->\u209a R) \u22a3\u22a2\u209a (P ->\u209a Q ->\u209a R).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "impl_false_l", "text": "Lemma impl_false_l {w} (P : Pred w) : \u22a5\u209a ->\u209a P \u22a3\u22a2\u209a \u22a4\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "impl_true_r", "text": "Lemma impl_true_r {w} (P : Pred w) : P ->\u209a \u22a4\u209a \u22a3\u22a2\u209a \u22a4\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "impl_true_l", "text": "Lemma impl_true_l {w} (P : Pred w) : \u22a4\u209a ->\u209a P \u22a3\u22a2\u209a P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_false_r", "text": "Lemma and_false_r {w} (P : Pred w) : P /\\\u209a \u22a5\u209a \u22a3\u22a2\u209a \u22a5\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_false_l", "text": "Lemma and_false_l {w} (P : Pred w) : \u22a5\u209a /\\\u209a P \u22a3\u22a2\u209a \u22a5\u209a.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_true_r", "text": "Lemma and_true_r {w} (P : Pred w) : P /\\\u209a \u22a4\u209a \u22a3\u22a2\u209a P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_true_l", "text": "Lemma and_true_l {w} (P : Pred w) : \u22a4\u209a /\\\u209a P \u22a3\u22a2\u209a P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_assoc", "text": "Lemma and_assoc {w} (P Q R : Pred w) : (P /\\\u209a Q) /\\\u209a R \u22a3\u22a2\u209a P /\\\u209a (Q /\\\u209a R).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and_comm", "text": "Lemma and_comm {w} (P Q : Pred w) : P /\\\u209a Q \u22a3\u22a2\u209a Q /\\\u209a P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "impl_and_adjoint", "text": "Lemma impl_and_adjoint {w} (P Q R : Pred w) : (P /\\\u209a Q \u22a2\u209a R) <-> (P \u22a2\u209a Q ->\u209a R).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "split_bientails", "text": "Lemma split_bientails {w} (P Q : Pred w) : (P \u22a3\u22a2\u209a Q) <-> (P \u22a2\u209a Q) /\\ (Q \u22a2\u209a P).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "intuitionistically_unfold", "text": "Lemma intuitionistically_unfold w (P : Pred w) : \u2200 \u03b9, @derived_connectives.bi_intuitionistically _ P \u03b9 <-> P \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wand_unfold", "text": "Lemma wand_unfold w (P Q : Pred w) : \u2200 \u03b9, interface.bi_wand P Q \u03b9 \u2194 (P \u03b9 \u2192 Q \u03b9).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "sep_unfold", "text": "Lemma sep_unfold w (P Q : Pred w) : \u2200 \u03b9, interface.bi_sep P Q \u03b9 \u2194 (P \u03b9 /\\ Q \u03b9).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "entails_unfold", "text": "Lemma entails_unfold [w] (P Q : Pred w) : (P \u22a2\u209a Q) <-> forall \u03b9, P \u03b9 -> Q \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "bientails_unfold", "text": "Lemma bientails_unfold [w] (P Q : Pred w) : (P \u22a3\u22a2\u209a Q) <-> forall \u03b9, P \u03b9 <-> Q \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "6e06e4abec38323c2deccf6488bf5160c967d8f9": {"theories/Substitution.v": [{"name": "subst_insert", "text": "Lemma subst_insert {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) (G : OEnv w0) (x : string) (t : OTy w0) : subst (insert x t G) \u03b8 = insert x (subst t \u03b8) (subst G \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_empty", "text": "Lemma subst_empty {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) : subst (empty (A := OEnv w0)) \u03b8 = empty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lookup_subst", "text": "Lemma lookup_subst {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) (G : OEnv w0) (x : string) : lookup x (subst G \u03b8) = subst (lookup x G) \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/PrenexConversion.v": [{"name": "prenex_correct", "text": "Lemma prenex_correct {A w} (m : Free A w) (Q : Box Prefix (A \u21a0 Pred) w) : WP (prenex m) Q \u22a3\u22a2 WP m Q.", "decomposition": [], "retrieval": ["and_wp_r"], "remove_type": "abort"}], "theories/Related/Gen/Synthesise.v": [{"name": "generate_correct_logrel", "text": "Lemma generate_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : otyping_algo (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2 \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["correctness", "relatedness_of_algo_typing"], "remove_type": "abort"}], "theories/Related/Gen/Bidirectional.v": [{"name": "synth_correct_logrel", "text": "Lemma synth_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : otyping_algo_synth (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2 \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["correctness_synth", "relatedness_of_algo_typing_synth"], "remove_type": "abort"}], "theories/Related/Gen/Check.v": [{"name": "generate_correct_logrel", "text": "Lemma generate_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : otyping_algo (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2 \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["correctness", "relatedness_of_algo_typing"], "remove_type": "abort"}], "theories/UnificationGeneric.v": [{"name": "instpred_cand_intro", "text": "Lemma instpred_cand_intro {w0} (c1 c2 : C w0) P Q : (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (c1 w1 \u03b81) \u22a3\u22a2 P[\u03b81]) \u2192 (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (c2 w1 \u03b81) \u22a3\u22a2 Q[\u03b81]) \u2192 (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (cand c1 c2 \u03b81) \u22a3\u22a2 (P \u2227 Q)[\u03b81]).", "decomposition": [], "retrieval": ["wp_solved_frame", "subst_pred_trans", "and_true_l", "subst_and", "wp_solved_bind"], "remove_type": "abort"}, {"name": "instpred_cfalse", "text": "Lemma instpred_cfalse {w0 w1} (\u03b81 : Tri w0 w1) : instpred (cfalse \u03b81) \u22a3\u22a2 \u22a5.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "instpred_ctrue", "text": "Lemma instpred_ctrue {w0 w1} (\u03b81 : Tri w0 w1) : instpred (ctrue \u03b81) \u22a3\u22a2 \u22a4.", "decomposition": [], "retrieval": ["wp_refl"], "remove_type": "abort"}], "theories/Gen/Synthesise.v": [{"name": "ocorrectness", "text": "Lemma ocorrectness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2 \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": [], "retrieval": ["ocompleteness", "osoundness"], "remove_type": "abort"}, {"name": "ocompleteness", "text": "Lemma ocompleteness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a2 \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": [], "retrieval": ["wp_mono", "ocompleteness_aux"], "remove_type": "abort"}, {"name": "ocompleteness_aux", "text": "Lemma ocompleteness_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : OEnv w0), \u22a2 lift G \u2248 G0 \u2192 WP (osynth e G0) (fun _ _ '(t',e') => lift t \u2248 t' \u2227 Open.pure ee \u2248 e')%I.", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "osoundness", "text": "Lemma osoundness (e : Exp) {w} (\u0393 : OEnv w) \u03c4 e' : \u0393 |--\u2090 e \u2237 \u03c4 ~> e' \u22a2 \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["osoundness_aux", "wlp_mono'", "wand_is_impl", "wp_impl"], "remove_type": "abort"}], "theories/Gen/Check.v": [{"name": "ocorrectness", "text": "Lemma ocorrectness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2 \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": [], "retrieval": ["ocompleteness", "osoundness"], "remove_type": "abort"}, {"name": "ocompleteness", "text": "Lemma ocompleteness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a2 \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": [], "retrieval": ["wp_mono", "ocompleteness_aux"], "remove_type": "abort"}, {"name": "ocompleteness_aux", "text": "Lemma ocompleteness_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : OEnv w0) (t0 : OTy w0), \u22a2 lift G \u2248 G0 \u2192 lift t \u2248 t0 \u2192 WP (ocheck e G0 t0) (fun _ _ e' => Open.pure ee \u2248 e').", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "osoundness", "text": "Lemma osoundness (e : Exp) {w} (\u0393 : OEnv w) \u03c4 e' : \u0393 |--\u2090 e \u2237 \u03c4 ~> e' \u22a2 \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["osoundness_aux", "wlp_mono'", "wand_is_impl", "wp_impl"], "remove_type": "abort"}, {"name": "osoundness_aux", "text": "Lemma osoundness_aux e : \u2200 w (G : OEnv w) (t : OTy w), \u22a2 WLP (ocheck e G t) (fun w1 \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Related/Monad/Interface.v": [{"name": "rwpstep", "text": "Lemma rwpstep {w \u03b1} (SP : Ty \u2192 Prop) (DP : Pred (w \u060c \u03b1)) : (wlp step (\u2200 \u03c4 : Ty, lift \u03c4 \u2248 oty.evar world.in_zero -\u2217 RSat RPred DP (SP \u03c4)))%I \u22a2 RSat RPred (wp step DP) (\u2203 t : Ty, SP t)%type.", "decomposition": [], "retrieval": ["inst_step_snoc"], "remove_type": "abort"}, {"name": "rlookup", "text": "Lemma rlookup x {w} : \u22a2 RSat (w := w) (REnv \u21a3 ROption RTy) (lookup x) (lookup x).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "req", "text": "Lemma req [DA SA] {instA : Inst DA SA} w : \u22a2 RSat (RInst DA SA \u21a3 RInst DA SA \u21a3 RPred) (oeq (w:=w)) eq.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Gen/Bidirectional.v": [{"name": "ocorrectness", "text": "Lemma ocorrectness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2 \u0393 |--\u2090 e \u2193 \u03c4 ~> e'.", "decomposition": [], "retrieval": ["ocompleteness", "osoundness"], "remove_type": "abort"}, {"name": "ocompleteness", "text": "Lemma ocompleteness (e : Exp) (w0 : World) (G0 : OEnv w0) t0 e0 : G0 |--\u209a e; t0 ~> e0 \u22a2 G0 |--\u2090 e \u2193 t0 ~> e0.", "decomposition": [], "retrieval": ["wp_mono", "ocompleteness_aux"], "remove_type": "abort"}, {"name": "ocompleteness_aux", "text": "Lemma ocompleteness_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : (\u2200 w0 (G0 : OEnv w0) (t0 : OTy w0), \u22a2 lift G \u2248 G0 \u2192 lift t \u2248 t0 \u2192 WP (ocheck e G0 t0) (fun _ _ e' => Open.pure ee \u2248 e')) \u2227 (\u2200 w0 (G0 : OEnv w0), \u22a2 lift G \u2248 G0 \u2192 WP (osynth e G0) (fun _ _ '(t',e') => lift t \u2248 t' \u2227 Open.pure ee \u2248 e')).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "osoundness", "text": "Lemma osoundness (e : Exp) (w0 : World) (G0 : OEnv w0) t0 e0 : G0 |--\u2090 e \u2193 t0 ~> e0 \u22a2 G0 |--\u209a e; t0 ~> e0.", "decomposition": [], "retrieval": ["osoundness_aux", "wlp_mono'", "wand_is_impl", "wp_impl"], "remove_type": "abort"}, {"name": "osoundness_aux", "text": "Lemma osoundness_aux e : (\u2200 w (G : OEnv w) (t : OTy w), \u22a2 WLP (ocheck e G t) (fun _ \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee)) /\\ (\u2200 w (G : OEnv w), \u22a2 WLP (osynth e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee)).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Monad/Interface.v": [{"name": "instpred_solved_hmap", "text": "Lemma instpred_solved_hmap `{LkHMap \u03981 \u03982} {A} `{ipA : InstPred A} {w} (m : Solved \u03981 A w) : instpred (solved_hmap m) \u22a3\u22a2 instpred m.", "decomposition": [], "retrieval": ["wp_hmap"], "remove_type": "abort"}, {"name": "wp_solved_bind", "text": "Lemma wp_solved_bind {\u0398} {trans\u0398 : Trans \u0398} {lkTrans\u0398 : LkTrans \u0398} {A B w0} (m : Solved \u0398 A w0) (f : \u25fb(A \u21a0 Solved \u0398 B) w0) (Q : \u25fb(B \u21a0 Pred) w0) : WP (bind m f) Q \u22a3\u22a2 WP m (fun w1 \u03b61 a1 => WP (f w1 \u03b61 a1) (_4 Q \u03b61)).", "decomposition": [], "retrieval": ["wp_false", "wp_trans"], "remove_type": "abort"}, {"name": "wp_solved_pure", "text": "Lemma wp_solved_pure {\u0398} {refl\u0398 : Refl \u0398} {lkrefl\u0398 : LkRefl \u0398} {A w0} (a : A w0) (Q : \u25fb(A \u21a0 Pred) w0) : wp_solved (pure (M := Solved \u0398) a) Q \u22a3\u22a2 Q _ refl a.", "decomposition": [], "retrieval": ["wp_refl"], "remove_type": "abort"}, {"name": "wp_solved_frame", "text": "Lemma wp_solved_frame {\u0398 A w} (m : Solved \u0398 A w) (P : \u25fb(A \u21a0 Pred) w) (Q : Pred w) : WP m P \u2227 Q \u22a3\u22a2 WP m (fun w1 \u03b81 a1 => P w1 \u03b81 a1 \u2227 subst Q \u03b81).", "decomposition": [], "retrieval": ["and_wp_l"], "remove_type": "abort"}, {"name": "wlp_mono'", "text": "Lemma wlp_mono' `{TypeCheckLogicM \u0398 M} {A w} (m : M A w) (P Q : \u25fb(A \u21a0 Pred) w) : WLP m P -\u2217 \u25fc(fun _ \u03b81 => \u2200 a1, P _ \u03b81 a1 -\u2217 Q _ \u03b81 a1) -\u2217 WLP m Q.", "decomposition": [], "retrieval": ["wlp_mono"], "remove_type": "abort"}, {"name": "wp_mono'", "text": "Lemma wp_mono' `{TypeCheckLogicM \u0398 M} {A w} (m : M A w) (P Q : \u25fb(A \u21a0 Pred) w) : WP m P -\u2217 \u25fc(fun _ \u03b81 => \u2200 a1, P _ \u03b81 a1 -\u2217 Q _ \u03b81 a1) -\u2217 WP m Q.", "decomposition": [], "retrieval": ["wp_mono"], "remove_type": "abort"}, {"name": "ax_wp_pick_substitute", "text": "Lemma ax_wp_pick_substitute `{AxiomaticSemantics \u0398 M, Thick \u0398} {lkThick\u0398 : LkThick \u0398} [w] (Q : \u25fb(OTy \u21a0 Pred) w) : WP pick Q \u22a3\u22a2 let \u03b1 := world.fresh w in (\u2203 \u03c4 : OTy w, (Q (w \u060c \u03b1) step (oty.evar world.in_zero))[thick \u03b1 (\u03b1In := world.in_zero) \u03c4]).", "decomposition": [], "retrieval": ["inst_thick", "inst_step_snoc"], "remove_type": "abort"}], "theories/Monad/Free.v": [{"name": "wlp_free_mono", "text": "Lemma wlp_free_mono [A w0] (m : Free A w0) (P Q : \u25fb(A \u21a0 Pred) w0) : \u25fc(fun _ \u03b81 => \u2200 a, P _ \u03b81 a -\u2217 Q _ \u03b81 a) \u22a2 (WLP m P -\u2217 WLP m Q).", "decomposition": [], "retrieval": ["wlp_mono", "wand_is_impl"], "remove_type": "admit"}, {"name": "wp_free_mono", "text": "Lemma wp_free_mono [A w0] (m : Free A w0) (P Q : \u25fb(A \u21a0 Pred) w0) : \u25fc(fun _ \u03b81 => \u2200 a, P _ \u03b81 a -\u2217 Q _ \u03b81 a) \u22a2 (WP m P -\u2217 WP m Q).", "decomposition": [], "retrieval": ["wp_mono"], "remove_type": "admit"}], "theories/BaseLogic.v": [{"name": "subst_pbox", "text": "Lemma subst_pbox `{LkTrans \u0398} [w] (Q : \u25fbPred w) [w1] (\u03b81 : \u0398 w w1) : (\u25fcQ)[\u03b81] \u22a2 \u25fc(Q[\u03b81]).", "decomposition": [], "retrieval": ["inst_trans"], "remove_type": "admit"}, {"name": "oeq_func", "text": "Lemma oeq_func {w} (s1 s2 t1 t2 : OTy w) : oty.func s1 s2 \u2248 oty.func t1 t2 \u22a3\u22a2 (s1 \u2248 t1) \u2227 (s2 \u2248 t2).", "decomposition": ["oeq_ty_noconfusion"], "retrieval": [], "remove_type": "admit"}, {"name": "oeq_insert", "text": "Lemma oeq_insert {w} (G1 G2 : OEnv w) (x : string) (t1 t2 : OTy w) : G1 \u2248 G2 \u2227 t1 \u2248 t2 \u22a2 insert (M := OEnv w) x t1 G1 \u2248 insert (M := OEnv w) x t2 G2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pno_cycle", "text": "Lemma pno_cycle {w} (t1 t2 : OTy w) (Hsub : oty.OTy_subterm t1 t2) : t1 \u2248 t2 \u22a2 \u22a5.", "decomposition": [], "retrieval": ["no_cycle", "inst_subterm"], "remove_type": "abort"}, {"name": "instpred_list_app", "text": "Lemma instpred_list_app {A} `{ipA : InstPred A} [w] (xs ys : List A w) : instpred (xs ++ ys) \u22a3\u22a2 instpred xs \u2227 instpred ys.", "decomposition": [], "retrieval": ["and_true_l"], "remove_type": "abort"}, {"name": "wlp_hmap", "text": "Lemma wlp_hmap `{LkHMap \u03981 \u03982} [w0 w1] (\u03b8 : \u03981 w0 w1) P : wlp (hmap \u03b8) P \u22a3\u22a2 wlp \u03b8 P.", "decomposition": [], "retrieval": ["inst_hmap"], "remove_type": "abort"}, {"name": "wp_hmap", "text": "Lemma wp_hmap `{LkHMap \u03981 \u03982} [w0 w1] (\u03b8 : \u03981 w0 w1) P : wp (hmap \u03b8) P \u22a3\u22a2 wp \u03b8 P.", "decomposition": [], "retrieval": ["inst_hmap"], "remove_type": "abort"}, {"name": "intro_wp_step", "text": "Lemma intro_wp_step {\u0398} {step\u0398 : Step \u0398} {lkStep\u0398 : LkStep \u0398} t {w \u03b1} (Q : Pred (w \u060c \u03b1)) : wlp step (lift t \u2248 oty.evar world.in_zero \u2192 Q) \u22a2 wp (step (\u0398 := \u0398)) Q.", "decomposition": ["intro_wp_step'"], "retrieval": ["subst_wlp"], "remove_type": "abort"}, {"name": "intro_wp_step'", "text": "Lemma intro_wp_step' {\u0398} {step\u0398 : Step \u0398} {lkStep\u0398 : LkStep \u0398} {w \u03b1} (P : Pred w) (Q : Pred (w \u060c \u03b1)) (t : Ty) : (P[step] \u22a2 lift t \u2248 oty.evar world.in_zero \u2192 Q) \u2192 (P \u22a2 wp (step (\u0398 := \u0398)) Q).", "decomposition": [], "retrieval": ["inst_step"], "remove_type": "abort"}, {"name": "wlp_frame", "text": "Lemma wlp_frame {w0 w1} (\u03b8 : \u0398 w0 w1) (P : Pred _) (Q : Pred _) : (P \u2192 wlp \u03b8 Q) \u22a3\u22a2 wlp \u03b8 (P[\u03b8] \u2192 Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_wp", "text": "Lemma subst_wp {w0 w1} {\u03b8 : \u0398 w0 w1} (P : Pred w1) : P \u22a2 (wp \u03b8 P)[\u03b8].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_wlp", "text": "Lemma subst_wlp {w0 w1} {\u03b8 : \u0398 w0 w1} (P : Pred w1) : (wlp \u03b8 P)[\u03b8] \u22a2 P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_impl", "text": "Lemma wp_impl {w0 w1} (\u03b81 : \u0398 w0 w1) (P : Pred _) (Q : Pred _) : (wp \u03b81 P \u2192 Q) \u22a3\u22a2 wlp \u03b81 (P \u2192 Q[\u03b81]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "entails_wp", "text": "Lemma entails_wp {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : (P \u22a2 Q[\u03b8]) \u2194 (wp \u03b8 P \u22a2 Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "entails_wlp", "text": "Lemma entails_wlp {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : (P[\u03b8] \u22a2 Q) \u2194 (P \u22a2 wlp \u03b8 Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_mono", "text": "Lemma wlp_mono {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : wlp \u03b8 (P -\u2217 Q) \u22a2 wlp \u03b8 P -\u2217 wlp \u03b8 Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_mono", "text": "Lemma wp_mono {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : wlp \u03b8 (P -\u2217 Q) \u22a2 wp \u03b8 P -\u2217 wp \u03b8 Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_true", "text": "Lemma wlp_true {w0 w1} (\u03b8 : \u0398 w0 w1) : wlp \u03b8 \u22a4 \u22a3\u22a2 \u22a4.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_trans", "text": "Lemma wlp_trans {transR : Trans \u0398} {lktrans\u0398 : LkTrans \u0398} {w0 w1 w2} (\u03b81 : \u0398 w0 w1) (\u03b82 : \u0398 w1 w2) Q : wlp (\u03b81 \u2299 \u03b82) Q \u22a3\u22a2 wlp \u03b81 (wlp \u03b82 Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_refl", "text": "Lemma wlp_refl {refl\u0398 : Refl \u0398} {lkrefl\u0398 : LkRefl \u0398} {w} (Q : Pred w) : wlp refl Q \u22a3\u22a2 Q.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_thick", "text": "Lemma wp_thick {thick\u0398 : Thick \u0398} {lkThick\u0398 : LkThick \u0398} {w \u03b1} (\u03b1In : world.In \u03b1 w) (t : OTy (w - \u03b1)) (Q : Pred (w - \u03b1)) : wp (thick \u03b1 t) Q \u22a3\u22a2 oty.evar \u03b1In \u2248 t[thin (\u0398 := Par) \u03b1] \u2227 Q[thin (\u0398 := Par) \u03b1].", "decomposition": [], "retrieval": ["insert_remove", "inst_thick", "lookup_insert", "remove_insert"], "remove_type": "abort"}, {"name": "and_wp_r", "text": "Lemma and_wp_r {w0 w1} (\u03b8 : \u0398 w0 w1) (P : Pred w0) (Q : Pred w1) : P \u2227 wp \u03b8 Q \u22a3\u22a2 wp \u03b8 (P[\u03b8] \u2227 Q).", "decomposition": [], "retrieval": ["and_wp_l"], "remove_type": "abort"}, {"name": "and_wp_l", "text": "Lemma and_wp_l {w0 w1} (\u03b8 : \u0398 w0 w1) P Q : wp \u03b8 P \u2227 Q \u22a3\u22a2 wp \u03b8 (P \u2227 Q[\u03b8]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_false", "text": "Lemma wp_false {w0 w1} (\u03b8 : \u0398 w0 w1) : wp \u03b8 \u22a5 \u22a3\u22a2 \u22a5.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_trans", "text": "Lemma wp_trans {transR : Trans \u0398} {lktrans\u0398 : LkTrans \u0398} {w0 w1 w2} (\u03b81 : \u0398 w0 w1) (\u03b82 : \u0398 w1 w2) Q : wp (\u03b81 \u2299 \u03b82) Q \u22a3\u22a2 wp \u03b81 (wp \u03b82 Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_refl", "text": "Lemma wp_refl {refl\u0398 : Refl \u0398} {lkrefl\u0398 : LkRefl \u0398} {w} (Q : Pred w) : wp refl Q \u22a3\u22a2 Q.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_typing", "text": "Lemma subst_typing {w0 w1} (\u03b8 : \u0398 w0 w1) G (e : Exp) (t : OTy w0) (ee : OExp w0) : (G |--\u209a e; t ~> ee)[\u03b8] \u22a3\u22a2 G[\u03b8] |--\u209a e; t[\u03b8] ~> ee[\u03b8].", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_exists", "text": "Lemma subst_exists [A] [w0 w1] (\u03b8 : \u0398 w0 w1) (Q : A -> Pred w0) : (\u2203 a : A, Q a)[\u03b8] \u22a3\u22a2 (\u2203 a : A, (Q a)[\u03b8]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_forall", "text": "Lemma subst_forall [A] [w0 w1] (\u03b8 : \u0398 w0 w1) (Q : A -> Pred w0) : (\u2200 a : A, Q a)[\u03b8] \u22a3\u22a2 (\u2200 a : A, (Q a)[\u03b8]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_true", "text": "Lemma subst_true {w0 w1} (\u03b8 : \u0398 w0 w1) : \u22a4[\u03b8] \u22a3\u22a2 \u22a4.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_false", "text": "Lemma subst_false {w0 w1} (\u03b8 : \u0398 w0 w1) : \u22a5[\u03b8] \u22a3\u22a2 \u22a5.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_wand", "text": "Lemma subst_wand {w0 w1} (\u03b8 : \u0398 w0 w1) (P Q : Pred w0) : (P -\u2217 Q)[\u03b8] \u22a3\u22a2 (P[\u03b8] -\u2217 Q[\u03b8]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_impl", "text": "Lemma subst_impl {w0 w1} (\u03b8 : \u0398 w0 w1) (P Q : Pred w0) : (P \u2192 Q)[\u03b8] \u22a3\u22a2 (P[\u03b8] \u2192 Q[\u03b8]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_and", "text": "Lemma subst_and {w0 w1} (\u03b8 : \u0398 w0 w1) (P Q : Pred w0) : (P \u2227 Q)[\u03b8] \u22a3\u22a2 P[\u03b8] \u2227 Q[\u03b8].", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_pred_trans", "text": "Lemma subst_pred_trans `{lktrans\u0398 : LkTrans \u0398} {w0 w1 w2} (\u03b81 : \u0398 w0 w1) (\u03b82 : \u0398 w1 w2) (P : Pred w0) : P[\u03b81 \u2299 \u03b82] \u22a3\u22a2 P[\u03b81][\u03b82].", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_pred_refl", "text": "Lemma subst_pred_refl `{lkRefl\u0398 : LkRefl \u0398} [w] (P : Pred w) : P[refl] \u22a3\u22a2 P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "subst_eq", "text": "Lemma subst_eq {T : OType} {substT : Subst T} {A : Type} {instTA : Inst T A} {instSubstTA : InstSubst T A} {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) (t1 t2 : T w0) : (t1 \u2248 t2)[\u03b8] \u22a3\u22a2 t1[\u03b8] \u2248 t2[\u03b8].", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "oeq_pair", "text": "Lemma oeq_pair {AT BT : OType} {A B : Type} {instA : Inst AT A} {instB : Inst BT B} [w] (a1 a2 : AT w) (b1 b2 : BT w) : (a1,b1) \u2248 (a2,b2) \u22a3\u22a2 ((a1 \u2248 a2) \u2227 (b1 \u2248 b2)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "oeq_ty_noconfusion", "text": "Lemma oeq_ty_noconfusion {w} (t1 t2 : OTy w) : t1 \u2248 t2 \u22a3\u22a2 match t1 , t2 with | oty.evar _ , _ => t1 \u2248 t2 | _ , oty.evar _ => t1 \u2248 t2 | oty.bool , oty.bool => True | oty.func t11 t12 , oty.func t21 t22 => t11 \u2248 t21 \u2227 t12 \u2248 t22 | _ , _ => False end.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "oeq_trans", "text": "Lemma oeq_trans {w} (s t u : T w) : s \u2248 t \u2227 t \u2248 u \u22a2 s \u2248 u.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "oeq_sym", "text": "Lemma oeq_sym {w} (s t : T w) : s \u2248 t \u22a3\u22a2 t \u2248 s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "oeq_refl", "text": "Lemma oeq_refl {w} (t : T w) : t \u2248 t \u22a3\u22a2 \u22a4.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "oeq_intro", "text": "Lemma oeq_intro {w} (t : T w) : \u22a2 t \u2248 t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pApply_r", "text": "Lemma pApply_r {w} {P Q R : Pred w} : (Q \u22a2 R) \u2192 (P \u22a2 Q) \u2192 (P \u22a2 R).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pApply", "text": "Lemma pApply {w} {P Q R : Pred w} : (P \u22a2 Q) -> (Q \u22a2 R) -> (P \u22a2 R).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wand_is_impl", "text": "Lemma wand_is_impl [w] (P Q : Pred w) : (P -\u2217 Q) \u22a3\u22a2 (P \u2192 Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exists_r", "text": "Lemma exists_r {I : Type} {w} P (Q : I -> Pred w) : (\u2203 x : I, P \u22a2 Q x) -> P \u22a2 (\u2203 x : I, Q x).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "exists_l", "text": "Lemma exists_l {I : Type} {w} (P : I -> Pred w) (Q : Pred w) : (\u2200 x : I, P x \u22a2 Q) -> (\u2203 x : I, P x) \u22a2 Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "impl_and", "text": "Lemma impl_and [w] (P Q R : Pred w) : (P \u2227 Q \u2192 R) \u22a3\u22a2 (P \u2192 Q \u2192 R).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "impl_false_l", "text": "Lemma impl_false_l {w} (P : Pred w) : (\u22a5 \u2192 P) \u22a3\u22a2 \u22a4.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "impl_true_r", "text": "Lemma impl_true_r {w} (P : Pred w) : (P \u2192 \u22a4) \u22a3\u22a2 \u22a4.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "impl_true_l", "text": "Lemma impl_true_l {w} (P : Pred w) : (\u22a4 \u2192 P) \u22a3\u22a2 P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_false_r", "text": "Lemma and_false_r {w} (P : Pred w) : P \u2227 \u22a5 \u22a3\u22a2 \u22a5.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_false_l", "text": "Lemma and_false_l {w} (P : Pred w) : \u22a5 \u2227 P \u22a3\u22a2 \u22a5.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_true_r", "text": "Lemma and_true_r {w} (P : Pred w) : P \u2227 \u22a4 \u22a3\u22a2 P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "and_true_l", "text": "Lemma and_true_l {w} (P : Pred w) : \u22a4 \u2227 P \u22a3\u22a2 P.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "impl_and_adjoint", "text": "Lemma impl_and_adjoint {w} (P Q R : Pred w) : (P \u2227 Q \u22a2 R) <-> (P \u22a2 Q \u2192 R).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "split_bientails", "text": "Lemma split_bientails {w} (P Q : Pred w) : (P \u22a3\u22a2 Q) <-> (P \u22a2 Q) \u2227 (Q \u22a2 P).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "intuitionistically_unfold", "text": "Lemma intuitionistically_unfold w (P : Pred w) : \u2200 \u03b9, @derived_connectives.bi_intuitionistically _ P \u03b9 \u2194 P \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "sep_unfold", "text": "Lemma sep_unfold w (P Q : Pred w) : \u2200 \u03b9, interface.bi_sep P Q \u03b9 \u2194 (P \u03b9 \u2227 Q \u03b9).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "entails_unfold", "text": "Lemma entails_unfold [w] (P Q : Pred w) : (P \u22a2 Q) <-> \u2200 \u03b9, P \u03b9 -> Q \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "bientails_unfold", "text": "Lemma bientails_unfold [w] (P Q : Pred w) : (P \u22a3\u22a2 Q) <-> \u2200 \u03b9, P \u03b9 <-> Q \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "d0e8ebee6ad5e6d3d57d9997751ddf7f8b909b48": {"theories/Shallow/Gen/Synthesise.v": [{"name": "correctness", "text": "Lemma correctness \u0393 e t ee : \u0393 |-- e \u2237 t ~> ee \u2194 \u0393 |--\u2090 e \u2237 t ~> ee.", "decomposition": ["completeness", "soundness"], "retrieval": [], "remove_type": "abort"}, {"name": "soundness", "text": "Lemma soundness (\u0393 : Env) (e : Exp) t ee : \u0393 |--\u2090 e \u2237 t ~> ee \u2192 \u0393 |-- e \u2237 t ~> ee.", "decomposition": [], "retrieval": ["wlp_mono", "wp_impl"], "remove_type": "abort"}, {"name": "completeness", "text": "Lemma completeness (\u0393 : Env) (e ee : Exp) (t : Ty) : \u0393 |-- e \u2237 t ~> ee \u2192 \u0393 |--\u2090 e \u2237 t ~> ee.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Shallow/Gen/Bidirectional.v": [{"name": "correctness_synth", "text": "Lemma correctness_synth \u0393 e t ee : \u0393 |-- e \u2237 t ~> ee \u2194 \u0393 |--\u2090 e \u2193 t ~> ee.", "decomposition": ["soundness_synth", "completeness"], "retrieval": [], "remove_type": "abort"}, {"name": "correctness_check", "text": "Lemma correctness_check \u0393 e t ee : \u0393 |-- e \u2237 t ~> ee \u2194 \u0393 |--\u2090 e \u2191 t ~> ee.", "decomposition": ["completeness", "soundness_check"], "retrieval": [], "remove_type": "abort"}, {"name": "soundness_synth", "text": "Lemma soundness_synth (\u0393 : Env) (e : Exp) t ee : \u0393 |--\u2090 e \u2193 t ~> ee \u2192 \u0393 |-- e \u2237 t ~> ee.", "decomposition": ["soundness_aux"], "retrieval": ["wlp_mono", "wp_impl"], "remove_type": "abort"}, {"name": "soundness_check", "text": "Lemma soundness_check (\u0393 : Env) (e : Exp) t ee : \u0393 |--\u2090 e \u2191 t ~> ee \u2192 \u0393 |-- e \u2237 t ~> ee.", "decomposition": ["soundness_aux"], "retrieval": ["wlp_mono", "wp_impl"], "remove_type": "abort"}, {"name": "soundness_aux", "text": "Lemma soundness_aux e : (\u2200 \u0393 t, WLP (check e \u0393 t) (fun ee => \u0393 |-- e \u2237 t ~> ee)) \u2227 (\u2200 \u0393, WLP (synth e \u0393) (fun '(t,ee) => \u0393 |-- e \u2237 t ~> ee)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "completeness", "text": "Lemma completeness (\u0393 : Env) (e ee : Exp) (t : Ty) : \u0393 |-- e \u2237 t ~> ee \u2192 \u0393 |--\u2090 e \u2191 t ~> ee \u2227 \u0393 |--\u2090 e \u2193 t ~> ee.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Gen/Synthesise.v": [{"name": "ocorrectness", "text": "Lemma ocorrectness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": ["ocompleteness", "osoundness"], "retrieval": [], "remove_type": "abort"}, {"name": "ocompleteness", "text": "Lemma ocompleteness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a2\u209a \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": ["ocompleteness_aux"], "retrieval": ["wp_mono"], "remove_type": "abort"}, {"name": "ocompleteness_aux", "text": "Lemma ocompleteness_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : OEnv w0), \u22a2 lift G =\u209a G0 \u2192 WP (osynth e G0) (fun _ _ '(t',e') => lift t =\u209a t' /\\\u209a Open.pure ee =\u209a e')%P.", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "osoundness", "text": "Lemma osoundness (e : Exp) {w} (\u0393 : OEnv w) \u03c4 e' : \u0393 |--\u2090 e \u2237 \u03c4 ~> e' \u22a2\u209a \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": ["osoundness_aux"], "retrieval": ["wlp_mono'", "wand_is_impl", "wp_impl"], "remove_type": "abort"}, {"name": "osoundness_aux", "text": "Lemma osoundness_aux e : \u2200 w (G : OEnv w), \u22a2 WLP (osynth e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Shallow/Gen/Check.v": [{"name": "correctness", "text": "Lemma correctness \u0393 e t ee : \u0393 |-- e \u2237 t ~> ee \u2194 \u0393 |--\u2090 e \u2237 t ~> ee.", "decomposition": ["completeness", "soundness"], "retrieval": [], "remove_type": "abort"}, {"name": "soundness", "text": "Lemma soundness (\u0393 : Env) (e : Exp) t ee : \u0393 |--\u2090 e \u2237 t ~> ee \u2192 \u0393 |-- e \u2237 t ~> ee.", "decomposition": [], "retrieval": ["wlp_mono", "wp_impl"], "remove_type": "abort"}, {"name": "completeness", "text": "Lemma completeness (\u0393 : Env) (e ee : Exp) (t : Ty) : \u0393 |-- e \u2237 t ~> ee \u2192 \u0393 |--\u2090 e \u2237 t ~> ee.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Gen/Check.v": [{"name": "ocorrectness", "text": "Lemma ocorrectness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": ["ocompleteness", "osoundness"], "retrieval": [], "remove_type": "abort"}, {"name": "ocompleteness", "text": "Lemma ocompleteness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a2\u209a \u0393 |--\u2090 e \u2237 \u03c4 ~> e'.", "decomposition": ["ocompleteness_aux"], "retrieval": ["wp_mono"], "remove_type": "abort"}, {"name": "ocompleteness_aux", "text": "Lemma ocompleteness_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : OEnv w0) (t0 : OTy w0), \u22a2 lift G =\u209a G0 ->\u209a lift t =\u209a t0 ->\u209a WP (ocheck e G0 t0) (fun _ _ e' => Open.pure ee =\u209a e')%P.", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "osoundness", "text": "Lemma osoundness (e : Exp) {w} (\u0393 : OEnv w) \u03c4 e' : \u0393 |--\u2090 e \u2237 \u03c4 ~> e' \u22a2\u209a \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": ["osoundness_aux"], "retrieval": ["wlp_mono'", "wp_impl"], "remove_type": "abort"}, {"name": "osoundness_aux", "text": "Lemma osoundness_aux e : \u2200 w (G : OEnv w) (t : OTy w), \u22a2 WLP (ocheck e G t) (fun w1 \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Related/Gen/Check.v": [{"name": "generate_correct_logrel", "text": "Lemma generate_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : otyping_algo (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2\u209a \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["correctness", "relatedness_of_algo_typing"], "remove_type": "abort"}, {"name": "relatedness_of_algo_typing", "text": "Lemma relatedness_of_algo_typing : \u211b\u27e6REnv \u21a3 RConst Exp \u21a3 RTy \u21a3 RExp \u21a3 RPred\u27e7 (otyping_algo (M := DM)) (typing_algo (M := SM)).", "decomposition": [], "retrieval": ["req", "relatedness_of_generators"], "remove_type": "abort"}, {"name": "relatedness_of_generators", "text": "Lemma relatedness_of_generators (e : Exp) : \u211b\u27e6REnv \u21a3 RTy \u21a3 RM RExp\u27e7 (ocheck e) (check e).", "decomposition": [], "retrieval": ["rlookup"], "remove_type": "abort"}], "theories/Related/Gen/Synthesise.v": [{"name": "generate_correct_logrel", "text": "Lemma generate_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : otyping_algo (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2\u209a \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["correctness", "relatedness_of_algo_typing"], "remove_type": "abort"}, {"name": "relatedness_of_algo_typing", "text": "Lemma relatedness_of_algo_typing : \u211b\u27e6REnv \u21a3 RConst Exp \u21a3 RTy \u21a3 RExp \u21a3 RPred\u27e7 (otyping_algo (M := DM)) (typing_algo (M := SM)).", "decomposition": [], "retrieval": ["req", "relatedness_of_generators", "rand"], "remove_type": "abort"}, {"name": "relatedness_of_generators", "text": "Lemma relatedness_of_generators (e : Exp) : \u211b\u27e6REnv \u21a3 RM (RProd RTy RExp)\u27e7 (osynth e) (synth e).", "decomposition": [], "retrieval": ["rlookup"], "remove_type": "abort"}], "theories/Gen/Bidirectional.v": [{"name": "ocorrectness", "text": "Lemma ocorrectness {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a \u0393 |--\u2090 e \u2193 \u03c4 ~> e'.", "decomposition": ["ocompleteness", "osoundness"], "retrieval": [], "remove_type": "abort"}, {"name": "ocompleteness", "text": "Lemma ocompleteness (e : Exp) (w0 : World) (G0 : OEnv w0) t0 e0 : G0 |--\u209a e; t0 ~> e0 \u22a2\u209a G0 |--\u2090 e \u2193 t0 ~> e0.", "decomposition": ["ocompleteness_aux"], "retrieval": ["wp_mono"], "remove_type": "abort"}, {"name": "ocompleteness_aux", "text": "Lemma ocompleteness_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : (\u2200 w0 (G0 : OEnv w0) (t0 : OTy w0), \u22a2 lift G =\u209a G0 ->\u209a lift t =\u209a t0 ->\u209a WP (ocheck e G0 t0) (fun _ _ e' => Open.pure ee =\u209a e')%P) /\\ (\u2200 w0 (G0 : OEnv w0), \u22a2 lift G =\u209a G0 \u2192 WP (osynth e G0) (fun _ _ '(t',e') => lift t =\u209a t' /\\\u209a Open.pure ee =\u209a e')%P).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "osoundness", "text": "Lemma osoundness (e : Exp) (w0 : World) (G0 : OEnv w0) t0 e0 : G0 |--\u2090 e \u2193 t0 ~> e0 \u22a2\u209a G0 |--\u209a e; t0 ~> e0.", "decomposition": ["osoundness_aux"], "retrieval": ["wlp_mono'", "wand_is_impl", "wp_impl"], "remove_type": "abort"}, {"name": "osoundness_aux", "text": "Lemma osoundness_aux e : (\u2200 w (G : OEnv w) (t : OTy w), \u22a2 WLP (ocheck e G t) (fun _ \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee)) /\\ (\u2200 w (G : OEnv w), \u22a2 WLP (osynth e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee)).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Related/Gen/Bidirectional.v": [{"name": "synth_correct_logrel", "text": "Lemma synth_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : otyping_algo_synth (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2\u209a \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": ["correctness_synth"], "retrieval": ["relatedness_of_algo_typing_synth"], "remove_type": "abort"}, {"name": "relatedness_of_algo_typing_synth", "text": "Lemma relatedness_of_algo_typing_synth : \u211b\u27e6REnv \u21a3 RConst Exp \u21a3 RTy \u21a3 RExp \u21a3 RPred\u27e7 (otyping_algo_synth (M := DM)) (typing_algo_synth (M := SM)).", "decomposition": [], "retrieval": ["req", "relatedness_of_generators", "rand"], "remove_type": "abort"}, {"name": "relatedness_of_generators", "text": "Lemma relatedness_of_generators (e : Exp) : \u211b\u27e6REnv \u21a3 RTy \u21a3 RM RExp\u27e7 (ocheck e) (check e) \u2227 \u211b\u27e6REnv \u21a3 RM (RProd RTy RExp)\u27e7 (osynth e) (synth e).", "decomposition": [], "retrieval": ["rlookup"], "remove_type": "abort"}], "theories/Composition.v": [{"name": "decidability", "text": "Lemma decidability \u0393 e \u03c4 : decidable (exists e', \u0393 |-- e \u2237 \u03c4 ~> e').", "decomposition": [], "retrieval": ["correctness", "decidable_type_instantiation"], "remove_type": "abort"}, {"name": "correctness", "text": "Theorem correctness (\u0393 : Env) (e : Exp) (\u03c4 : Ty) (e' : Exp) : typing_algo \u0393 e \u03c4 e' \u2194 tpb \u0393 e \u03c4 e'.", "decomposition": ["ocorrectness"], "retrieval": ["prenex_correct", "and_wp_l"], "remove_type": "abort"}]}, "b1802e0359e4a14c7a670353492709fe01e86ff7": {"theories/Context.v": [{"name": "in_at_exact", "text": "Lemma in_at_exact {\u0393 : Ctx B} (b1 b2 : B) (b1In : In b1 \u0393) (b2In : In b2 \u0393) : @in_at _ _ b1In = @in_at _ _ b2In -> b1 = b2 /\\ (nth_is \u0393 (@in_at _ _ b1In) b1 = nth_is \u0393 (@in_at _ _ b2In) b2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "In_eqb_spec", "text": "Lemma In_eqb_spec `{UIP B} {\u0393} {b1 b2 : B} (b1in\u0393 : In b1 \u0393) (b2in\u0393 : In b2 \u0393) : reflect (existT _ _ b1in\u0393 = existT _ _ b2in\u0393 :> sigT (fun b => In b \u0393)) (In_eqb b1in\u0393 b2in\u0393).", "decomposition": ["nth_is_right_exact"], "retrieval": [], "remove_type": "abort"}, {"name": "proof_irrelevance_nth_is_refl", "text": "Lemma proof_irrelevance_nth_is_refl {\u0393} (n : nat) (b : B) (p : nth_is \u0393 n b) : proof_irrelevance_nth_is n b p p = eq_refl.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "nth_is_right_exact", "text": "Lemma nth_is_right_exact {\u0393 : Ctx B} (n : nat) (b1 b2 : B) : nth_is \u0393 n b1 -> nth_is \u0393 n b2 -> b1 = b2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Prelude.v": [{"name": "forall_and_compat", "text": "Lemma forall_and_compat {A} (P Q : A -> Prop): (forall a, P a /\\ Q a) <-> (forall a, P a) /\\ (forall a, Q a).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exists_or_compat", "text": "Lemma exists_or_compat {A} (P Q : A -> Prop): (exists a, P a \\/ Q a) <-> (exists a, P a) \\/ (exists a, Q a).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leftid_true_and", "text": "Lemma leftid_true_and (A : Prop) : True /\\ A <-> A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rightid_and_true", "text": "Lemma rightid_and_true (A : Prop) : A /\\ True <-> A.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "imp_iff_compat_l'", "text": "Lemma imp_iff_compat_l' (A B C : Prop) : ((A -> B) <-> (A -> C)) <-> (A -> B <-> C).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and_iff_compat_l'", "text": "Lemma and_iff_compat_l' (A B C : Prop) : (A /\\ B <-> A /\\ C) <-> (A -> B <-> C).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "and_iff_compat_r'", "text": "Lemma and_iff_compat_r' (A B C : Prop) : (B /\\ A <-> C /\\ A) <-> (A -> B <-> C).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_monotonic", "text": "Lemma wlp_monotonic {A} (S1 S2 : A -> Prop) (fS : forall a, S1 a -> S2 a) : forall (o : option A), wlp S1 o -> wlp S2 o.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_map", "text": "Lemma wlp_map {A B S} (f : A -> B) (o : option A) : wlp S (map f o) <-> wlp (fun a => S (f a)) o.", "decomposition": ["wlp_match"], "retrieval": [], "remove_type": "admit"}, {"name": "wp_monotonic", "text": "Lemma wp_monotonic {A} (S1 S2 : A -> Prop) (fS : forall a, S1 a -> S2 a) : forall (o : option A), wp S1 o -> wp S2 o.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_map", "text": "Lemma wp_map {A B S} (f : A -> B) (o : option A) : wp S (map f o) <-> wp (fun a => S (f a)) o.", "decomposition": ["wp_match"], "retrieval": [], "remove_type": "admit"}, {"name": "spec_monotonic", "text": "Lemma spec_monotonic {A} (S1 S2 : A -> Prop) (N1 N2 : Prop) (fS : forall a, S1 a -> S2 a) (fN: N1 -> N2) : forall (o : option A), spec S1 N1 o -> spec S2 N2 o.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "spec_map", "text": "Lemma spec_map {A B S N} (f : A -> B) (o : option A) : spec S N (map f o) <-> spec (fun a => S (f a)) N o.", "decomposition": ["spec_match"], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_bind", "text": "Lemma wlp_bind : wlp S (bind o f) <-> wlp (fun a => wlp S (f a)) o.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_bind", "text": "Lemma wp_bind : wp S (bind o f) <-> wp (fun a => wp S (f a)) o.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "spec_bind", "text": "Lemma spec_bind : spec S N (bind o f) <-> spec (fun a => spec S N (f a)) N o.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wlp_forall", "text": "Lemma wlp_forall {A} (Q : A -> Prop) (o : option A) : wlp Q o <-> forall a, o = Some a -> Q a.", "decomposition": ["wlp_match"], "retrieval": [], "remove_type": "abort"}, {"name": "wlp_match", "text": "Lemma wlp_match {A S} (o : option A) : wlp S o <-> match o with | Some a => S a | None => True end.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_exists", "text": "Lemma wp_exists {A} (Q : A -> Prop) (o : option A) : wp Q o <-> exists a, o = Some a /\\ Q a.", "decomposition": ["wp_match"], "retrieval": [], "remove_type": "abort"}, {"name": "wp_match", "text": "Lemma wp_match {A S} (o : option A) : wp S o <-> match o with | Some a => S a | None => False end.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "spec_match", "text": "Lemma spec_match {A S N} (o : option A) : spec S N o <-> match o with | Some a => S a | None => N end.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "bind_eq_some", "text": "Lemma bind_eq_some {A B} (f : A -> option B) (o : option A) (b : B) : (exists a, o = Some a /\\ f a = Some b) <-> bind o f = Some b.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "map_eq_some", "text": "Lemma map_eq_some {A B} (f : A -> B) (o : option A) (a : A) : o = Some a -> map f o = Some (f a).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Environment.v": [{"name": "of_to_env", "text": "Lemma of_to_env (\u03c3s : Ctx B) (e : EnvRec D \u03c3s) : of_env (to_env \u03c3s e) = e.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "to_of_env", "text": "Lemma to_of_env (\u03c3s : Ctx B) (e : Env D \u03c3s) : to_env \u03c3s (of_env e) = e.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "map_ext", "text": "Lemma map_ext {D1 D2 : B -> Set} (f1 f2 : forall b, D1 b -> D2 b) {\u0393} (E : Env D1 \u0393) : (forall b d, f1 b d = f2 b d) -> map f1 E = map f2 E.", "decomposition": ["lookup_extensional", "lookup_map"], "retrieval": [], "remove_type": "abort"}, {"name": "map_id", "text": "Lemma map_id {D : B -> Set} {\u0393 : Ctx B} (E : Env D \u0393) : map (fun _ d => d) E = E.", "decomposition": ["map_id_eq"], "retrieval": [], "remove_type": "abort"}, {"name": "map_id_eq", "text": "Lemma map_id_eq {D : B -> Set} {\u0393 : Ctx B} (f : forall b, D b -> D b) (E : Env D \u0393) (hyp_f : forall b d, f b d = d) : map f E = E.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "map_map", "text": "Lemma map_map {\u0393} (E : Env D1 \u0393) : map g (map f E) = map (fun b d => g (f d)) E.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lookup_map", "text": "Lemma lookup_map {\u0393} (E : Env D1 \u0393) : forall {b} (bIn\u0393 : b \u2208 \u0393), lookup (map E) bIn\u0393 = f (lookup E bIn\u0393).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "map_tabulate", "text": "Lemma map_tabulate {\u0393} (g : forall b, b \u2208 \u0393 -> D1 b) : map (tabulate g) = tabulate (fun b bIn\u0393 => f (g b bIn\u0393)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "map_update", "text": "Lemma map_update {\u0393} (E : Env D1 \u0393) : forall {b} (bIn\u0393 : b \u2208 \u0393) (db : D1 b), map (update E bIn\u0393 db) = update (map E) bIn\u0393 (f db).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "map_drop", "text": "Lemma map_drop {\u0393 \u0394} (E\u0393\u0394 : Env D1 (\u0393 \u25bb\u25bb \u0394)) : map (drop \u0394 E\u0393\u0394) = drop \u0394 (map E\u0393\u0394).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "map_cat", "text": "Lemma map_cat {\u03931 \u03932} (E1 : Env D1 \u03931) (E2 : Env D1 \u03932) : map (cat E1 E2) = cat (map E1) (map E2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "uncurry_curry", "text": "Lemma uncurry_curry (\u0394 : Ctx B) (r : Type) (f : Env \u0394 -> r) : forall \u03b4, uncurry (curry f) \u03b4 = f \u03b4.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Exists_exists", "text": "Lemma Exists_exists (\u0394 : Ctx B) (P : Env \u0394 -> Prop) : (Exists P) <-> (exists E : Env \u0394, P E).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Forall_forall", "text": "Lemma Forall_forall (\u0394 : Ctx B) (P : Env \u0394 -> Prop) : (Forall P) <-> (forall E : Env \u0394, P E).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lookup_cat_right", "text": "Lemma lookup_cat_right {\u03931 \u03932 x} (xIn : x \u2208 \u03932) (E1 : Env \u03931) (E2 : Env \u03932) : lookup (cat E1 E2) (ctx.in_cat_right xIn) = lookup E2 xIn.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lookup_tabulate", "text": "Lemma lookup_tabulate {\u0393} (g : forall b, b \u2208 \u0393 -> D b) : forall {b} (bIn\u0393 : b \u2208 \u0393), lookup (tabulate g) bIn\u0393 = g b bIn\u0393.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lookup_extensional", "text": "Lemma lookup_extensional {\u0393} (E1 E2 : Env \u0393) : (forall {b} (bIn\u0393 : b \u2208 \u0393), lookup E1 bIn\u0393 = lookup E2 bIn\u0393) -> E1 = E2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "update_lookup", "text": "Lemma update_lookup {\u0393} (E : Env \u0393) : forall {b} (bIn\u0393 : b \u2208 \u0393), update E bIn\u0393 (lookup E bIn\u0393) = E.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "update_update", "text": "Lemma update_update {\u0393} (E : Env \u0393) : forall {b} (bIn\u0393 : b \u2208 \u0393) (d1 d2 : D b), update (update E bIn\u0393 d1) bIn\u0393 d2 = update E bIn\u0393 d2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "drop_cat", "text": "Lemma drop_cat {\u0393 \u0394} (\u03b4\u0394 : Env \u0394) (\u03b4\u0393 : Env \u0393) : drop \u0394 (cat \u03b4\u0393 \u03b4\u0394) = \u03b4\u0393.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "cat_split", "text": "Lemma cat_split {\u0393 \u0394} (E\u0393\u0394 : Env (\u0393 \u25bb\u25bb \u0394)) : E\u0393\u0394 = cat (fst (split _ E\u0393\u0394)) (snd (split _ E\u0393\u0394)).", "decomposition": ["split_cat"], "retrieval": [], "remove_type": "abort"}, {"name": "cat_split'", "text": "Lemma cat_split' {\u0393 \u0394} (E\u0393\u0394 : Env (\u0393 \u25bb\u25bb \u0394)) : let (E\u0393,E\u0394) := split _ E\u0393\u0394 in E\u0393\u0394 = cat E\u0393 E\u0394.", "decomposition": ["split_cat"], "retrieval": [], "remove_type": "abort"}, {"name": "split_cat", "text": "Lemma split_cat {\u0393 \u0394} (E\u0393 : Env \u0393) (E\u0394 : Env \u0394) : split \u0394 (cat E\u0393 E\u0394) = (E\u0393 , E\u0394).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "split_takedrop", "text": "Lemma split_takedrop {\u0393} \u0394 (E : Env (\u0393 \u25bb\u25bb \u0394)) : split \u0394 E = (drop \u0394 E , take \u0394 E).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "all_elim", "text": "Lemma all_elim {Q : forall [b], D b -> Type} {\u0393} {E : Env \u0393} (HE : All Q E) : forall b (bIn : b \u2208 \u0393), Q (lookup E bIn).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "all_intro", "text": "Lemma all_intro {Q : forall [b], D b -> Type} (HQ : forall b (d : D b), Q d) : forall \u0393 (E : Env \u0393), All Q E.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inversion_eq_cat", "text": "Lemma inversion_eq_cat {\u0393 \u0394 : Ctx B} (E\u03931 E\u03932 : Env \u0393) (E\u03941 E\u03942 : Env \u0394) : cat E\u03931 E\u03941 = cat E\u03932 E\u03942 <-> E\u03931 = E\u03932 /\\ E\u03941 = E\u03942.", "decomposition": ["inversion_eq_snoc"], "retrieval": [], "remove_type": "abort"}, {"name": "inversion_eq_snoc", "text": "Lemma inversion_eq_snoc {\u0393 : Ctx B} {b : B} (E1 E2 : Env \u0393) (v1 v2 : D b) : snoc E1 v1 = snoc E2 v2 <-> E1 = E2 /\\ v1 = v2.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "e120c7bc210e624e377f29da32e05116666d33fc": {"theories/Sub/Parallel.v": [{"name": "Ty_subterm_subst", "text": "Lemma Ty_subterm_subst {w1 w2} (s t : OTy w1) (\u03b8 : Par w1 w2) : oty.OTy_subterm s t -> oty.OTy_subterm (persist s \u03b8) (persist t \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "thin_thick_pointful", "text": "Lemma thin_thick_pointful {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (s : OTy (w - \u03b1)) (t : OTy (w - \u03b1)) : subst (subst t (thin \u03b1)) (thick \u03b1 s) = t.", "decomposition": [], "retrieval": ["comp_thin_thick"], "remove_type": "abort"}, {"name": "comp_thin_thick", "text": "Lemma comp_thin_thick {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (s : OTy (w - \u03b1)) : trans (thin \u03b1) (thick \u03b1 s) = refl.", "decomposition": [], "retrieval": ["lk_thin", "lk_trans", "lookup_extensional", "lk_thick", "occurs_check_view_thin", "lk_refl"], "remove_type": "abort"}], "theories/Gen/Bidirectional.v": [{"name": "correct", "text": "Lemma correct {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": [], "retrieval": ["complete", "sound"], "remove_type": "abort"}, {"name": "complete", "text": "Lemma complete (e : Exp) (w0 : World) (G0 : OEnv w0) t0 e0 : G0 |--\u209a e; t0 ~> e0 \u22a2\u209a TPB_algo G0 e t0 e0.", "decomposition": [], "retrieval": ["complete_aux"], "remove_type": "abort"}, {"name": "complete_aux", "text": "Lemma complete_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : (\u2200 w0 (G0 : OEnv w0) (t0 : OTy w0), \u22a2 lift G =\u209a G0 ->\u209a lift t =\u209a t0 ->\u209a WP (check e G0 t0) (fun _ _ e' => Open.pure ee =\u209a e')%P) /\\ (\u2200 w0 (G0 : OEnv w0), \u22a2 lift G =\u209a G0 \u2192 WP (synth e G0) (fun _ _ '(t',e') => lift t =\u209a t' /\\\u209a Open.pure ee =\u209a e')%P).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "sound", "text": "Lemma sound (e : Exp) (w0 : World) (G0 : OEnv w0) t0 e0 : TPB_algo G0 e t0 e0 \u22a2\u209a G0 |--\u209a e; t0 ~> e0.", "decomposition": [], "retrieval": ["wlp_mono'", "sound_aux"], "remove_type": "abort"}, {"name": "sound_aux", "text": "Lemma sound_aux e : (\u2200 w (G : OEnv w) (t : OTy w), \u22a2 WLP (check e G t) (fun _ \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee)) /\\ (\u2200 w (G : OEnv w), \u22a2 WLP (synth e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee)).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Persistence.v": [{"name": "persist_insert", "text": "Lemma persist_insert {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) (G : OEnv w0) (x : string) (t : OTy w0) : persist (insert x t G) \u03b8 = insert x (persist t \u03b8) (persist G \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "persist_empty", "text": "Lemma persist_empty {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) : persist (empty (A := OEnv w0)) \u03b8 = empty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lookup_persist", "text": "Lemma lookup_persist {\u0398 : SUB} {w0 w1} (\u03b8 : \u0398 w0 w1) (G : OEnv w0) (x : string) : lookup x (persist G \u03b8) = persist (lookup x G) \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Instantiation.v": [{"name": "lift_insert", "text": "Lemma lift_insert {w x t \u0393} : lift (insert (M := Env) x t \u0393) = insert (M := OEnv w) x (lift t) (lift \u0393).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inst_empty", "text": "Lemma inst_empty {w} (\u03b9 : Assignment w) : inst (A := OEnv) empty \u03b9 = empty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inst_insert", "text": "Lemma inst_insert {w} (\u0393 : OEnv w) (x : string) (t : OTy w) (\u03b9 : Assignment w) : inst (insert (M := OEnv w) x t \u0393) \u03b9 = inst \u0393 \u03b9 ,, x \u2237 inst t \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lookup_inst", "text": "Lemma lookup_inst (w : World) (\u0393 : OEnv w) (x : string) (\u03b9 : Assignment w) : lookup x (inst \u0393 \u03b9) = inst (lookup x \u0393) \u03b9.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inst_subterm", "text": "Lemma inst_subterm {w} (\u03b9 : Assignment w) (t1 t2 : OTy w) : oty.OTy_subterm t1 t2 -> ty.Ty_subterm (inst t1 \u03b9) (inst t2 \u03b9).", "decomposition": [], "retrieval": ["inst_direct_subterm"], "remove_type": "abort"}, {"name": "inst_direct_subterm", "text": "Lemma inst_direct_subterm {w} (t1 t2 : OTy w) (\u03b9 : Assignment w) : oty.OTy_direct_subterm t1 t2 -> ty.Ty_direct_subterm (inst t1 \u03b9) (inst t2 \u03b9).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inst_thick", "text": "Lemma inst_thick {\u0398} {thick\u0398 : Thick \u0398} {lkthick\u0398 : LkThick \u0398} : forall {w} {x} (xIn : x \u2208 w) (t : OTy (w - x)) (\u03b9 : Assignment (w - x)), inst (thick (\u0398 := \u0398) x t) \u03b9 = env.insert xIn \u03b9 (inst t \u03b9).", "decomposition": [], "retrieval": ["lookup_thin", "lookup_tabulate", "lookup_extensional", "lk_thick", "lookup_insert", "remove_insert"], "remove_type": "abort"}], "theories/Gen/Synthesise.v": [{"name": "generate_correct", "text": "Lemma generate_correct {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": [], "retrieval": ["generate_sound", "generate_complete"], "remove_type": "abort"}, {"name": "generate_complete", "text": "Lemma generate_complete {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": [], "retrieval": ["generate_complete_aux"], "remove_type": "abort"}, {"name": "generate_complete_aux", "text": "Lemma generate_complete_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : OEnv w0), \u22a2 lift G =\u209a G0 \u2192 WP (generate e G0) (fun _ _ '(t',e') => lift t =\u209a t' /\\\u209a Open.pure ee =\u209a e')%P.", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "generate_sound", "text": "Lemma generate_sound (e : Exp) {w0} (G0 : OEnv w0) t0 e0 : TPB_algo G0 e t0 e0 \u22a2\u209a G0 |--\u209a e; t0 ~> e0.", "decomposition": [], "retrieval": ["generate_sound_aux", "wlp_mono'"], "remove_type": "abort"}, {"name": "generate_sound_aux", "text": "Lemma generate_sound_aux e : \u2200 w (G : OEnv w), \u22a2 WLP (generate e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Unification.v": [{"name": "solve_correct", "text": "Lemma solve_correct `{LkHMap Tri \u0398} {w} (C : List (OTy * OTy) w) : instpred (solve (\u0398 := \u0398) C) \u22a3\u22a2\u209a instpred C.", "decomposition": [], "retrieval": ["asolve_correct"], "remove_type": "abort"}, {"name": "asolve_correct", "text": "Lemma asolve_correct {w0} (C : List (OTy * OTy) w0) : \u2200 w1 (\u03b81 : w0 \u2291\u207b w1), instpred (asolve C \u03b81) \u22a3\u22a2\u209a (instpred C)[\u03b81].", "decomposition": [], "retrieval": ["instpred_cand_intro", "instpred_ctrue", "amgu_correct"], "remove_type": "abort"}, {"name": "aflex_correct", "text": "Lemma aflex_correct {\u03b1} (\u03b1In : \u03b1 \u2208 w) (t : OTy w) w1 (\u03b81 : w \u2291\u207b w1) : instpred (aflex lamgu \u03b1 t \u03b81) \u22a3\u22a2\u209a (oty.var \u03b1In =\u209a t)[\u03b81].", "decomposition": [], "retrieval": ["flex_correct"], "remove_type": "abort"}, {"name": "flex_correct", "text": "Lemma flex_correct {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (t : OTy w) : instpred (flex \u03b1 t) \u22a3\u22a2\u209a oty.var \u03b1In =\u209a t.", "decomposition": [], "retrieval": ["occurs_check_spec", "lk_thin"], "remove_type": "abort"}, {"name": "atrav_elim", "text": "Lemma atrav_elim : \u2200 (t1 t2 : OTy w), P t1 t2 (atrav t1 t2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "occurs_check_spec", "text": "Lemma occurs_check_spec {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (t : OTy w) : match occurs_check t \u03b1In with | Some t' => t = t'[thin \u03b1] | None => t = oty.var \u03b1In \\/ oty.OTy_subterm (oty.var \u03b1In) t end.", "decomposition": [], "retrieval": ["lk_thin"], "remove_type": "abort"}], "theories/Gen/Check.v": [{"name": "correct", "text": "Lemma correct {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": [], "retrieval": ["complete", "sound"], "remove_type": "abort"}, {"name": "complete", "text": "Lemma complete (e : Exp) w0 (G0 : OEnv w0) t0 e0 : G0 |--\u209a e; t0 ~> e0 \u22a2\u209a TPB_algo G0 e t0 e0.", "decomposition": [], "retrieval": ["complete_aux"], "remove_type": "abort"}, {"name": "complete_aux", "text": "Lemma complete_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : OEnv w0) (t0 : OTy w0), \u22a2 lift G =\u209a G0 ->\u209a lift t =\u209a t0 ->\u209a WP (check e G0 t0) (fun _ _ e' => Open.pure ee =\u209a e')%P.", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "sound", "text": "Lemma sound (e : Exp) (w0 : World) (G0 : OEnv w0) t0 e0 : TPB_algo G0 e t0 e0 \u22a2\u209a G0 |--\u209a e; t0 ~> e0.", "decomposition": [], "retrieval": ["wlp_mono'", "sound_aux"], "remove_type": "abort"}, {"name": "sound_aux", "text": "Lemma sound_aux e : \u2200 w (G : OEnv w) (t : OTy w), \u22a2 WLP (check e G t) (fun w1 \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Worlds.v": [{"name": "no_cycle", "text": "Lemma no_cycle {w} (t : OTy w) : ~ OTy_subterm t t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Composition.v": [{"name": "decidable_type_instantiation", "text": "Lemma decidable_type_instantiation (\u03c4 : Ty) {w} (o\u03c4 : OTy w) : decidable (\u2203 \u03b9 : Assignment w, \u03c4 = inst o\u03c4 \u03b9).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "9ad27704a8cf0abafb864416d02e8a87820dd99f": {"theories/Sub/Parallel.v": [{"name": "persist_hmap", "text": "Lemma persist_hmap {\u0398 : SUB} {T} {persT : Persistent T} {persLT : PersistLaws T} [w0 w1] (\u03b8 : \u0398 w0 w1) : forall t, persist t (hmap \u03b8) = persist t \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "hmap_thick", "text": "Lemma hmap_thick {\u0398} {thick\u0398 : Thick \u0398} {lkThick\u0398 : LkThick \u0398} w \u03b1 (\u03b1In : \u03b1 \u2208 w) t : hmap (thick (\u0398 := \u0398) \u03b1 t) = thick (\u0398 := Par) \u03b1 t.", "decomposition": [], "retrieval": ["lookup_extensional", "lk_thick"], "remove_type": "abort"}, {"name": "hmap_step", "text": "Lemma hmap_step {\u0398} {step\u0398 : Step \u0398} {lkStep\u0398 : LkStep \u0398} w \u03b1 : hmap (@step \u0398 step\u0398 w \u03b1) = step (\u0398 := Par).", "decomposition": [], "retrieval": ["lookup_extensional"], "remove_type": "abort"}, {"name": "Ty_subterm_subst", "text": "Lemma Ty_subterm_subst {w1 w2} (s t : \u1e6ay w1) (\u03b8 : Par w1 w2) : \u1e6by.\u1e6ay_subterm s t -> \u1e6by.\u1e6ay_subterm (persist s \u03b8) (persist t \u03b8).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "comp_thin_thick", "text": "Lemma comp_thin_thick {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (s : \u1e6ay (w - \u03b1)) : trans (thin \u03b1) (thick \u03b1 s) = refl.", "decomposition": [], "retrieval": ["lk_thin", "lk_trans", "lookup_extensional", "lk_thick", "occurs_check_view_thin", "lk_refl"], "remove_type": "abort"}], "theories/Sub/Prefix.v": [{"name": "nil_unique", "text": "Lemma nil_unique {w} (\u03b8 : Prefix world.nil w) : nil = \u03b8.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Composition.v": [{"name": "decidability", "text": "Lemma decidability \u0393 e \u03c4 : decidable (exists e', \u0393 |-- e \u2237 \u03c4 ~> e').", "decomposition": ["decidable_type_instantiation"], "retrieval": ["correctness"], "remove_type": "abort"}, {"name": "decidable_type_instantiation", "text": "Lemma decidable_type_instantiation (\u03c4 : Ty) {w} (o\u03c4 : \u1e6ay w) : decidable (\u2203 \u03b9 : Assignment w, \u03c4 = inst o\u03c4 \u03b9).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "correctness", "text": "Lemma correctness (\u0393 : Env) (e : Exp) (\u03c4 : Ty) (e' : Exp) : algorithmic_typing \u0393 e \u03c4 e' <-> tpb \u0393 e \u03c4 e'.", "decomposition": ["solve_correct"], "retrieval": ["prenex_correct", "generate_correct"], "remove_type": "abort"}], "theories/Instantiation.v": [{"name": "lift_insert", "text": "Lemma lift_insert {w x t \u0393} : lift (insert (M := Env) x t \u0393) = insert (M := \u0116nv w) x (lift t) (lift \u0393).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inst_hmap", "text": "Lemma inst_hmap `{LkHMap \u03981 \u03982} {w1 w2} (\u03b8 : \u03981 w1 w2) (\u03b9 : Assignment w2) : inst (hmap \u03b8) \u03b9 = inst \u03b8 \u03b9.", "decomposition": [], "retrieval": ["lookup_extensional", "lookup_tabulate"], "remove_type": "abort"}], "theories/Unification.v": [{"name": "solve_correct", "text": "Lemma solve_correct `{LkHMap Tri \u0398} {w} (C : List (\u1e6ay * \u1e6ay) w) : instpred (solve (\u0398 := \u0398) C) \u22a3\u22a2\u209a instpred C.", "decomposition": [], "retrieval": ["asolve_correct"], "remove_type": "abort"}, {"name": "asolve_correct", "text": "Lemma asolve_correct {w0} (C : List (\u1e6ay * \u1e6ay) w0) : \u2200 w1 (\u03b81 : w0 \u2291\u207b w1), instpred (asolve C \u03b81) \u22a3\u22a2\u209a (instpred C)[\u03b81].", "decomposition": ["instpred_cand_intro", "instpred_ctrue", "amgu_correct"], "retrieval": [], "remove_type": "abort"}, {"name": "amgu_correct", "text": "Lemma amgu_correct : \u2200 w, BoxUnifierCorrect (@amgu w).", "decomposition": ["atrav_correct"], "retrieval": [], "remove_type": "admit"}, {"name": "atrav_correct", "text": "Lemma atrav_correct : BoxUnifierCorrect (atrav lamgu).", "decomposition": ["instpred_cand_intro", "instpred_ctrue", "atrav_elim"], "retrieval": ["aflex_correct"], "remove_type": "abort"}, {"name": "aflex_correct", "text": "Lemma aflex_correct {\u03b1} (\u03b1In : \u03b1 \u2208 w) (t : \u1e6ay w) w1 (\u03b81 : w \u2291\u207b w1) : instpred (aflex lamgu \u03b1 t \u03b81) \u22a3\u22a2\u209a (\u1e6by.var \u03b1In =\u209a t)[\u03b81].", "decomposition": ["flex_correct"], "retrieval": [], "remove_type": "abort"}, {"name": "flex_correct", "text": "Lemma flex_correct {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (t : \u1e6ay w) : instpred (flex \u03b1 t) \u22a3\u22a2\u209a \u1e6by.var \u03b1In =\u209a t.", "decomposition": [], "retrieval": ["occurs_check_spec", "lk_thin"], "remove_type": "abort"}, {"name": "instpred_cand_intro", "text": "Lemma instpred_cand_intro {w0} (c1 c2 : C w0) P Q : (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (c1 w1 \u03b81) \u22a3\u22a2\u209a P[\u03b81]) \u2192 (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (c2 w1 \u03b81) \u22a3\u22a2\u209a Q[\u03b81]) \u2192 (\u2200 w1 (\u03b81 : Tri w0 w1), instpred (cand c1 c2 \u03b81) \u22a3\u22a2\u209a (P /\\\u209a Q)[\u03b81]).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "instpred_cfalse", "text": "Lemma instpred_cfalse {w0 w1} (\u03b81 : Tri w0 w1) : instpred (cfalse \u03b81) \u22a3\u22a2\u209a \u22a5\u209a.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "instpred_ctrue", "text": "Lemma instpred_ctrue {w0 w1} (\u03b81 : Tri w0 w1) : instpred (ctrue \u03b81) \u22a3\u22a2\u209a \u22a4\u209a.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "atrav_elim", "text": "Lemma atrav_elim : \u2200 (t1 t2 : \u1e6ay w), P t1 t2 (atrav t1 t2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "occurs_check_spec", "text": "Lemma occurs_check_spec {w \u03b1} (\u03b1In : \u03b1 \u2208 w) (t : \u1e6ay w) : match occurs_check t \u03b1In with | Some t' => t = t'[thin \u03b1] | None => t = \u1e6by.var \u03b1In \\/ \u1e6by.\u1e6ay_subterm (\u1e6by.var \u03b1In) t end.", "decomposition": [], "retrieval": ["lk_thin"], "remove_type": "abort"}], "theories/PrenexConversion.v": [{"name": "prenex_correct", "text": "Lemma prenex_correct {A w} (m : Free A w) (Q : Box Prefix (A \u21e2 Pred) w) : WP (prenex m) Q \u22a3\u22a2\u209a WP m Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Monad/Interface.v": [{"name": "wlp_mono'", "text": "Lemma wlp_mono' `{TypeCheckLogicM \u0398 M} {A w} (m : M A w) (P Q : Box \u0398 (A \u21e2 Pred) w) : (WLP m P -\u2217 PBox (fun w1 \u03b81 => \u2200\u209a a1, P w1 \u03b81 a1 -\u2217 Q w1 \u03b81 a1) -\u2217 WLP m Q)%P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_mono'", "text": "Lemma wp_mono' `{TypeCheckLogicM \u0398 M} {A w} (m : M A w) (P Q : Box \u0398 (A \u21e2 Pred) w) : (WP m P -\u2217 PBox (fun w1 \u03b81 => \u2200\u209a a1, P w1 \u03b81 a1 -\u2217 Q w1 \u03b81 a1) -\u2217 WP m Q)%P.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "wp_fail", "text": "Lemma wp_fail `{TypeCheckLogicM \u0398 M} [A w] (Q : Box \u0398 (A \u21e2 Pred) w) : \u22a5\u209a \u22a2\u209a WP fail Q.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/Monad/Free.v": [{"name": "wlp_free_mono", "text": "Lemma wlp_free_mono [A w0] (m : Free A w0) (P Q : \u25fb(A \u21e2 Pred) w0) : PBox (fun w1 \u03b81 => \u2200\u209a a, P w1 \u03b81 a -\u2217 Q w1 \u03b81 a)%P \u22a2 (WLP m P -\u2217 WLP m Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "wp_free_mono", "text": "Lemma wp_free_mono [A w0] (m : Free A w0) (P Q : \u25fb(A \u21e2 Pred) w0) : PBox (fun w1 \u03b81 => \u2200\u209a a, P w1 \u03b81 a -\u2217 Q w1 \u03b81 a)%P \u22a2 (WP m P -\u2217 WP m Q).", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "4f5578913a2895d1bbe152c8426a70aa9c35f8d5": {"theories/Shallow/Gen/Bidirectional.v": [{"name": "synth_correct", "text": "Lemma synth_correct \u0393 e t ee : \u0393 |-- e \u2237 t ~> ee <-> \u0393 |--\u2090 e \u2237 t ~> ee.", "decomposition": [], "retrieval": ["complete", "synth_sound"], "remove_type": "abort"}, {"name": "check_correct", "text": "Lemma check_correct \u0393 e t ee : \u0393 |-- e \u2237 t ~> ee <-> tpb_algorithmic_check \u0393 e t ee.", "decomposition": [], "retrieval": ["complete", "check_sound"], "remove_type": "abort"}, {"name": "synth_sound", "text": "Lemma synth_sound (\u0393 : Env) (e : Exp) t ee : (\u0393 |--\u2090 e \u2237 t ~> ee) -> (\u0393 |-- e \u2237 t ~> ee).", "decomposition": [], "retrieval": ["wlp_mono", "wp_impl", "sound_aux"], "remove_type": "abort"}, {"name": "check_sound", "text": "Lemma check_sound (\u0393 : Env) (e : Exp) t ee : tpb_algorithmic_check \u0393 e t ee -> (\u0393 |-- e \u2237 t ~> ee).", "decomposition": [], "retrieval": ["wlp_mono", "wp_impl", "sound_aux"], "remove_type": "abort"}, {"name": "sound_aux", "text": "Lemma sound_aux e : (\u2200 \u0393 t, WLP (check e \u0393 t) (fun ee => \u0393 |-- e \u2237 t ~> ee)) /\\ (\u2200 \u0393, WLP (synth e \u0393) (fun '(t,ee) => \u0393 |-- e \u2237 t ~> ee)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "complete", "text": "Lemma complete (\u0393 : Env) (e ee : Exp) (t : Ty) : \u0393 |-- e \u2237 t ~> ee -> tpb_algorithmic_check \u0393 e t ee /\\ \u0393 |--\u2090 e \u2237 t ~> ee.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Related/Gen/Check.v": [{"name": "generate_correct_logrel", "text": "Lemma generate_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : TPB_algo (\u0398 := Prefix) (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2\u209a \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": [], "retrieval": ["check_correct", "relatedness_of_algo_typing"], "remove_type": "abort"}, {"name": "relatedness_of_algo_typing", "text": "Lemma relatedness_of_algo_typing : \u211b\u27e6REnv \u21a3 RConst Exp \u21a3 RTy \u21a3 RExp \u21a3 RPred\u27e7 (TPB_algo (M := DM)) (tpb_algorithmic (M := SM)).", "decomposition": [], "retrieval": ["req", "relatedness_of_generators"], "remove_type": "abort"}, {"name": "relatedness_of_generators", "text": "Lemma relatedness_of_generators (e : Exp) : \u211b\u27e6REnv \u21a3 RTy \u21a3 RM RExp\u27e7 (Em.Gen.Check.check e) (Em.Shallow.Gen.Check.check e).", "decomposition": [], "retrieval": ["rlookup"], "remove_type": "abort"}], "theories/Related/Gen/Bidirectional.v": [{"name": "synth_correct_logrel", "text": "Lemma synth_correct_logrel `{!Shallow.Monad.Interface.TypeCheckLogicM SM} {w} (\u0393 : OEnv w) (e : Exp) (\u03c4 : OTy w) (e' : OExp w) : TPB_algo (\u0398 := Prefix) (M := DM) \u0393 e \u03c4 e' \u22a3\u22a2\u209a \u0393 |--\u209a e; \u03c4 ~> e'.", "decomposition": ["relatedness_of_algo_typing_synth"], "retrieval": ["synth_correct"], "remove_type": "abort"}, {"name": "relatedness_of_algo_typing_synth", "text": "Lemma relatedness_of_algo_typing_synth : \u211b\u27e6REnv \u21a3 RConst Exp \u21a3 RTy \u21a3 RExp \u21a3 RPred\u27e7 (TPB_algo (M := DM)) (tpb_algorithmic_synth (M := SM)).", "decomposition": [], "retrieval": ["req", "relatedness_of_generators", "rand"], "remove_type": "abort"}, {"name": "relatedness_of_generators", "text": "Lemma relatedness_of_generators (e : Exp) : \u211b\u27e6REnv \u21a3 RTy \u21a3 RM RExp\u27e7 (Em.Gen.Bidirectional.check e) (Em.Shallow.Gen.Bidirectional.check e) /\\ \u211b\u27e6REnv \u21a3 RM (RProd RTy RExp)\u27e7 (Em.Gen.Bidirectional.synth e) (Em.Shallow.Gen.Bidirectional.synth e).", "decomposition": [], "retrieval": ["rlookup"], "remove_type": "abort"}], "theories/Related/Gen/Synthesise.v": [{"name": "relatedness_of_generators", "text": "Lemma relatedness_of_generators (e : Exp) : \u211b\u27e6REnv \u21a3 RM (RProd RTy RExp)\u27e7 (generate e) (synth e).", "decomposition": [], "retrieval": ["rlookup"], "remove_type": "abort"}], "theories/Gen/Synthesise.v": [{"name": "generate_sound_aux", "text": "Lemma generate_sound_aux e : \u2200 w (G : OEnv w), \u22a2 WLP (generate e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}]}, "23a75de329e28c3180bd435311ee7bc40c4edc38": {"theories/Gen/Synthesise.v": [{"name": "generate_correct", "text": "Lemma generate_correct {w} (\u0393 : \u0116nv w) (e : Exp) (\u03c4 : \u1e6ay w) (e' : \u0116xp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": ["generate_sound", "generate_complete"], "retrieval": [], "remove_type": "abort"}, {"name": "generate_complete", "text": "Lemma generate_complete {w} (\u0393 : \u0116nv w) (e : Exp) (\u03c4 : \u1e6ay w) (e' : \u0116xp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": ["generate_complete_aux"], "retrieval": [], "remove_type": "abort"}, {"name": "generate_complete_aux", "text": "Lemma generate_complete_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : \u0116nv w0), \u22a2 lift G =\u209a G0 \u2192 WP (generate e G0) (fun _ _ '(t',e') => lift t =\u209a t' /\\\u209a Open.pure ee =\u209a e')%P.", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "generate_sound", "text": "Lemma generate_sound (e : Exp) {w0} (G0 : \u0116nv w0) t0 e0 : TPB_algo G0 e t0 e0 \u22a2\u209a G0 |--\u209a e; t0 ~> e0.", "decomposition": ["generate_sound_aux"], "retrieval": ["wlp_mono'"], "remove_type": "abort"}, {"name": "generate_sound_aux", "text": "Lemma generate_sound_aux e : \u2200 w (G : \u0116nv w), \u22a2 WLP (generate e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Gen/Bidirectional.v": [{"name": "correct", "text": "Lemma correct {w} (\u0393 : \u0116nv w) (e : Exp) (\u03c4 : \u1e6ay w) (e' : \u0116xp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": ["complete", "sound"], "retrieval": [], "remove_type": "abort"}, {"name": "complete", "text": "Lemma complete (e : Exp) (w0 : World) (G0 : \u0116nv w0) t0 e0 : G0 |--\u209a e; t0 ~> e0 \u22a2\u209a TPB_algo G0 e t0 e0.", "decomposition": ["complete_aux"], "retrieval": [], "remove_type": "abort"}, {"name": "complete_aux", "text": "Lemma complete_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : (\u2200 w0 (G0 : \u0116nv w0) (t0 : \u1e6ay w0), \u22a2 lift G =\u209a G0 ->\u209a lift t =\u209a t0 ->\u209a WP (check e G0 t0) (fun _ _ e' => Open.pure ee =\u209a e')%P) /\\ (\u2200 w0 (G0 : \u0116nv w0), \u22a2 lift G =\u209a G0 \u2192 WP (synth e G0) (fun _ _ '(t',e') => lift t =\u209a t' /\\\u209a Open.pure ee =\u209a e')%P).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "sound", "text": "Lemma sound (e : Exp) (w0 : World) (G0 : \u0116nv w0) t0 e0 : TPB_algo G0 e t0 e0 \u22a2\u209a G0 |--\u209a e; t0 ~> e0.", "decomposition": ["sound_aux"], "retrieval": ["wlp_mono'"], "remove_type": "abort"}, {"name": "sound_aux", "text": "Lemma sound_aux e : (\u2200 w (G : \u0116nv w) (t : \u1e6ay w), \u22a2 WLP (check e G t) (fun _ \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee)) /\\ (\u2200 w (G : \u0116nv w), \u22a2 WLP (synth e G) (fun _ \u03b8 '(t,ee) => G[\u03b8] |--\u209a e; t ~> ee)).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}], "theories/Gen/Check.v": [{"name": "correct", "text": "Lemma correct {w} (\u0393 : \u0116nv w) (e : Exp) (\u03c4 : \u1e6ay w) (e' : \u0116xp w) : \u0393 |--\u209a e; \u03c4 ~> e' \u22a3\u22a2\u209a TPB_algo \u0393 e \u03c4 e'.", "decomposition": ["complete", "sound"], "retrieval": [], "remove_type": "abort"}, {"name": "complete", "text": "Lemma complete (e : Exp) w0 (G0 : \u0116nv w0) t0 e0 : G0 |--\u209a e; t0 ~> e0 \u22a2\u209a TPB_algo G0 e t0 e0.", "decomposition": ["complete_aux"], "retrieval": [], "remove_type": "abort"}, {"name": "complete_aux", "text": "Lemma complete_aux {G e t ee} (T : G |-- e \u2237 t ~> ee) : \u2200 w0 (G0 : \u0116nv w0) (t0 : \u1e6ay w0), \u22a2 lift G =\u209a G0 ->\u209a lift t =\u209a t0 ->\u209a WP (check e G0 t0) (fun _ _ e' => Open.pure ee =\u209a e')%P.", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}, {"name": "sound", "text": "Lemma sound (e : Exp) (w0 : World) (G0 : \u0116nv w0) t0 e0 : TPB_algo G0 e t0 e0 \u22a2\u209a G0 |--\u209a e; t0 ~> e0.", "decomposition": ["sound_aux"], "retrieval": ["wlp_mono'"], "remove_type": "abort"}, {"name": "sound_aux", "text": "Lemma sound_aux e : \u2200 w (G : \u0116nv w) (t : \u1e6ay w), \u22a2 WLP (check e G t) (fun w1 \u03b8 ee => G[\u03b8] |--\u209a e; t[\u03b8] ~> ee).", "decomposition": [], "retrieval": ["lookup_inst"], "remove_type": "abort"}]}, "40915e3c46d7c6b2d188e9a36fe5f0c8241cff9c": {}, "e6c9eaaec0f6e02a79605e17e4ac716d4dd2703a": {}, "77b48db5640f957106535bb38f4d6d0d71e6666f": {}, "1ba64056e38413dd9949451d094d5dabf5361f85": {}, "85fad0b582531046449fc5c55d2d30d63d58a7e3": {}, "1467be48c10e0b52e671da6de5a1f0259962e1a1": {}, "c30f0ee6cce7fcaedda493ecd5a1eb03e1fafdb7": {}, "b0037508d465a7876d1915f9ae4dfeb35fbab18a": {}, "dfad7bb48db60a43dfc7ac54d8d87e1b4e7092cc": {}, "27a977e7ddf09e14d0ddde9d454b8601c6fc34b6": {}, "ef22cd0b9530fd0b614de3b84b6848b21b3141b6": {}, "67ea7a1ff80d1e304aeb97e450bd536d8cbea6c6": {}, "311fd5c2c9d75798ac62ffa352286a69f5f6d6c6": {}, "066522e32757092814787639cb222d41dac7747b": {}, "47a0097cc53c15a6adb4f6f6b1e71cff9e06fdee": {}, "6fc0af444a781a5cbb01970e5761b1f07cced7cb": {}, "242235b7539ebd64fe9044d8bd730c983b7d23d2": {}, "1c8f6ecae7059e9a2fdcc355a7ed43bbd25b6728": {}, "5fc9855ab00f529feed7bbb22635f0551226bb50": {}, "6d8446f5e5aa9c29ba741b6f225cfb6def512a0d": {}, "e54cc22bbbdd3c75f73b66c88ee024b2ae22bad1": {}, "0eedef79559b5030a99b62cc9f9c0126ed9f648e": {}, "f140e3daa9b7101295a37e79c141cf8eb45b045e": {}, "95e52aa96ad1846cd1e4b534847afb2f17104174": {}, "f9f0558cbc28dd45b2ff475d0be20c248c358783": {}}