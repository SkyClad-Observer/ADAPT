{"3f75208812b667c542039b50084949bce69f80d1": {"theories/SwapUpdate.v": [{"name": "nthSwapExceptVariant", "text": "Lemma nthSwapExceptVariant {A : Type} (l : list A) (default : A) (i j uninvolved : nat) (hI : i < length l) (hJ : j < length l) (hUninvolvedI : uninvolved <> i) (hUninvolvedJ : uninvolved <> j) : nth uninvolved (swap l j i default) default = nth uninvolved l default.", "decomposition": ["nthSwapExcept", "swapIndices"], "retrieval": [], "remove_type": "abort"}, {"name": "nthSwapExcept", "text": "Lemma nthSwapExcept {A : Type} (l : list A) (default : A) (i j uninvolved : nat) (hI : i < length l) (hJ : j < length l) (hUninvolvedI : uninvolved <> i) (hUninvolvedJ : uninvolved <> j) : nth uninvolved (swap l i j default) default = nth uninvolved l default.", "decomposition": ["nthUpdateExcept"], "retrieval": [], "remove_type": "abort"}, {"name": "nthUpdateExcept", "text": "Lemma nthUpdateExcept {A : Type} (l : list A) (default : A) (i uninvolved : nat) (value : A) (hLt : i < length l) (hUninvolved : uninvolved <> i) : nth uninvolved (<[i := value]> l) default = nth uninvolved l default.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "nthUpdate", "text": "Lemma nthUpdate {A : Type} (l : list A) (default : A) (i : nat) (value : A) (hLt : i < length l) : nth i (<[i := value]> l) default = value.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "nthSwapVariant", "text": "Lemma nthSwapVariant {A : Type} (l : list A) (default : A) (i j : nat) (hI : i < length l) (hJ : j < length l) : nth i (swap l j i default) default = nth j l default.", "decomposition": ["swapIndices", "nthSwap"], "retrieval": [], "remove_type": "abort"}, {"name": "nthSwap", "text": "Lemma nthSwap {A : Type} (l : list A) (default : A) (i j : nat) (hI : i < length l) (hJ : j < length l) : nth i (swap l i j default) default = nth j l default.", "decomposition": ["swapTwice", "swapIndices", "nthSwap'"], "retrieval": ["swapSelf", "swapPreservesLength"], "remove_type": "abort"}, {"name": "nthSwap'", "text": "Lemma nthSwap' {A : Type} (l : list A) (default : A) (i j : nat) (hWlog : i < j) (hJ : j < length l) : nth i (swap l i j default) default = nth j l default.", "decomposition": ["nthTake", "nthConsDrop"], "retrieval": ["swapApp", "listDecomposition", "nthAppZero"], "remove_type": "abort"}, {"name": "swapTwiceVariant", "text": "Lemma swapTwiceVariant {A : Type} (l : list A) (default : A) (i j : nat) (hI : i < length l) (hJ : j < length l) : swap (swap l i j default) j i default = l.", "decomposition": ["swapTwice", "swapIndices"], "retrieval": [], "remove_type": "abort"}, {"name": "swapTwice", "text": "Lemma swapTwice {A : Type} (l : list A) (default : A) (i j : nat) (hI : i < length l) (hJ : j < length l) : swap (swap l i j default) i j default = l.", "decomposition": ["swapTwice'", "swapIndices"], "retrieval": ["swapSelf"], "remove_type": "abort"}, {"name": "swapTwice'", "text": "Lemma swapTwice' {A : Type} (l : list A) (default : A) (i j : nat) (hIJ : i < j) (hJ : j < length l) : swap (swap l i j default) i j default = l.", "decomposition": [], "retrieval": ["swapApp", "listDecomposition"], "remove_type": "abort"}, {"name": "swapIndices", "text": "Lemma swapIndices {A : Type} (l : list A) (default : A) (i j : nat) : swap l i j default = swap l j i default.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "nthConsDrop", "text": "Lemma nthConsDrop {A : Type} (l : list A) (default : A) (hNotNil : l <> []) (i : nat) (hLt : i < length l) : nth i l default :: drop (S i) l = drop i l.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "nthTake", "text": "Lemma nthTake {A : Type} (l : list A) (default : A) (i j : nat) (hLt : i < j) : nth i l default = nth i (take j l) default.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/PropertyPreservedAfterSorting.v": [{"name": "selectionSortCorrect", "text": "Lemma selectionSortCorrect {A : Type} (default : A) (comparator : Comparator A) (l : list A) : sorted default (compare _ comparator) (selectionSort default (compare _ comparator) l).", "decomposition": ["partialSelectionSortInvariant"], "retrieval": ["selectionSortPreservesLength"], "remove_type": "abort"}, {"name": "partialSelectionSortInvariant", "text": "Lemma partialSelectionSortInvariant {A : Type} (default : A) (comparator : Comparator A) (l : list A) (i : nat) (hLt : i < length l) : prefixSorted default (compare _ comparator) (partialSelectionSort default (compare _ comparator) l (S i)) (S i) /\\ partitioned default (compare _ comparator) (partialSelectionSort default (compare _ comparator) l (S i)) i.", "decomposition": ["partialSelectionSortZero", "nthSwapVariant", "nthSwap", "nthSwapExcept"], "retrieval": ["pickSmallestInRangeCompare", "swapPreservesLength", "partialSelectionSortPreservesLength", "iLessEqualPickSmallestInRange", "partialSelectionSortSucc", "pickSmallestInRangeUpperBound"], "remove_type": "abort"}, {"name": "partialSelectionSortZero", "text": "Lemma partialSelectionSortZero {A : Type} (default : A) (compare : A -> A -> bool) (l : list A) : partialSelectionSort default compare l 0 = l.", "decomposition": [], "retrieval": ["rangeZero"], "remove_type": "abort"}], "theories/ListDecomposition.v": [{"name": "listDecomposition", "text": "Lemma listDecomposition {A : Type} (l : list A) (i j : nat) (hLt : i < j) (hUpperBound : j < length l) (default : A) : l = take i l ++ [nth i l default] ++ drop (S i) (take j l) ++ [nth j l default] ++ drop (j + 1) l.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "630633d775b719ccf79eb6d1ba8fc2682fd23eb8": {}, "cf497b84bd12b052b038eeb7f21583d2bc5011b8": {}, "c208d9352e14c37a11eb534b658bdb71d804a005": {}, "760ecc73f14037edd908a0948810c6d0a9f4e50f": {}, "5e71fc1d1ec0ff81e7e5c151982b4a80f131711a": {}, "44c02c7d58c7f94e2e73304f9bf14247333bc416": {}, "629cb4ddb56f16198dc3845fd6d4046a3427a8c1": {}, "40f17c1e8acf38189522ee53d38969635b80770b": {}, "b90a40807be218b5d0a9daee3adb7235e3134a26": {"theories/PickSmallestInRangeProperties.v": [{"name": "pickSmallestInRangeCompare", "text": "Lemma pickSmallestInRangeCompare {A : Type} (default : A) (comparator : Comparator A) (l : list A) (i delta inBetween : nat) (hInBetween : inBetween <= delta) : ~compare _ comparator (nth (i + inBetween) l default) (nth (pickSmallestInRange default (compare _ comparator) i (i + delta) l) l default).", "decomposition": [], "retrieval": ["foldlSingleton", "range2LeftLeft", "negativelyTransitive", "range2LeftAdd", "pickSmallestInRangeFold"], "type": "proof", "remove_type": "abort"}, {"name": "pickSmallestInRangeSuccDelta", "text": "Lemma pickSmallestInRangeSuccDelta {A : Type} (default : A) (compare : A -> A -> bool) (l : list A) (i delta : nat) : pickSmallestInRange default compare i (i + S delta) l = pickSmallestInRange default compare i (i + delta) l \\/ pickSmallestInRange default compare i (i + S delta) l = i + S delta.", "decomposition": [], "retrieval": ["foldlSingleton", "range2LeftAdd"], "type": "proof", "remove_type": "abort"}, {"name": "pickSmallestInRangeInvariant", "text": "Lemma pickSmallestInRangeInvariant {A : Type} (default : A) (compare : A -> A -> bool) (l : list A) (i delta : nat) : i <= foldl (fun accumulated current => if compare (nth current l default) (nth accumulated l default) then current else accumulated) i (range2 i (i + delta)).", "decomposition": [], "retrieval": ["foldlSingleton", "range2LeftAdd", "range2LeftLeft"], "type": "proof", "remove_type": "abort"}], "theories/SwapUpdate.v": [{"name": "nthUpdateExcept", "text": "Lemma nthUpdateExcept {A : Type} (l : list A) (default : A) (i uninvolved : nat) (value : A) (hLt : i < length l) (hUninvolved : uninvolved <> i) : nth uninvolved (<[i := value]> l) default = nth uninvolved l default.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "nthUpdate", "text": "Lemma nthUpdate {A : Type} (l : list A) (default : A) (i : nat) (value : A) (hLt : i < length l) : nth i (<[i := value]> l) default = value.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "nthConsDrop", "text": "Lemma nthConsDrop {A : Type} (l : list A) (default : A) (hNotNil : l <> []) (i : nat) (hLt : i < length l) : nth i l default :: drop (S i) l = drop i l.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "nthTake", "text": "Lemma nthTake {A : Type} (l : list A) (default : A) (i j : nat) (hLt : i < j) : nth i l default = nth i (take j l) default.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "updateSelf", "text": "Lemma updateSelf {A : Type} (l : list A) (default : A) (i : nat) : <[i := nth i l default]> l = l.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "swapChopOff'", "text": "Lemma swapChopOff' {A : Type} (l1 l2 : list A) (j : nat) (default : A) : swap (l1 ++ l2) (length l1) (length l1 + j) default = l1 ++ swap l2 0 j default.", "decomposition": [], "retrieval": ["updateAtIndexLength", "nthApp", "updateAtIndexLengthPlusSomething", "updateAppZero", "nthAppZero", "updateApp"], "type": "proof", "remove_type": "abort"}, {"name": "swapChopOff", "text": "Lemma swapChopOff {A : Type} (l1 l2 : list A) (i j : nat) (default : A) : swap (l1 ++ l2) (length l1 + i) (length l1 + j) default = l1 ++ swap l2 i j default.", "decomposition": [], "retrieval": ["updateAtIndexLength", "nthApp", "updateAtIndexLengthPlusSomething", "updateAppZero", "nthAppZero", "updateApp"], "type": "proof", "remove_type": "abort"}, {"name": "nthAppZero", "text": "Lemma nthAppZero {A : Type} (l1 l2 : list A) (default : A) : nth (length l1) (l1 ++ l2) default = nth 0 l2 default.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "nthApp", "text": "Lemma nthApp {A : Type} (l1 l2 : list A) (i : nat) (default : A) : nth (length l1 + i) (l1 ++ l2) default = nth i l2 default.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "updateAppZero", "text": "Lemma updateAppZero {A : Type} (l1 l2 : list A) (value : A) : <[length l1 := value]> (l1 ++ l2) = l1 ++ <[0 := value]> l2.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "updateApp", "text": "Lemma updateApp {A : Type} (l1 l2 : list A) (value : A) (i : nat) : <[length l1 + i := value]> (l1 ++ l2) = l1 ++ <[i := value]> l2.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "updateAtIndexLengthPlusSomething", "text": "Lemma updateAtIndexLengthPlusSomething {A : Type} (l : list A) (value : A) (something : nat) : <[length l + something := value]> l = l.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "updateAtIndexLength", "text": "Lemma updateAtIndexLength {A : Type} (l : list A) (value : A) : <[length l := value]> l = l.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}], "theories/PropertyPreservedAfterSorting.v": [{"name": "propertyPreservedAfterPartialSorting", "text": "Lemma propertyPreservedAfterPartialSorting {A : Type} (default : A) (comparator : Comparator A) (l : list A) (property : list A -> Prop) (hPreserve : forall l1 l2 l3 a1 a2, compare _ comparator a2 a1 -> property (l1 ++ [a1] ++ l2 ++ [a2] ++ l3) -> property (l1 ++ [a2] ++ l2 ++ [a1] ++ l3)) (hProperty : property l) (iterationCount : nat) (hIterationCount : iterationCount <= length l) : property (partialSelectionSort default (compare _ comparator) l iterationCount).", "decomposition": [], "retrieval": ["swapSelf", "partialSelectionSortPreservesLength", "propertyPreservedAfterSwapping", "pickSmallestInRangeUpperBound", "pickSmallestInRangeInvariant", "partialSelectionSortSucc"], "type": "proof", "remove_type": "abort"}, {"name": "propertyPreservedAfterSwapping", "text": "Lemma propertyPreservedAfterSwapping {A : Type} (default : A) (comparator : Comparator A) (l : list A) (property : list A -> Prop) (hPreserve : forall l1 l2 l3 a1 a2, compare _ comparator a2 a1 -> property (l1 ++ [a1] ++ l2 ++ [a2] ++ l3) -> property (l1 ++ [a2] ++ l2 ++ [a1] ++ l3)) (hProperty : property l) (i : nat) (hInBounds : i < length l) : property (swap l i (pickSmallestInRange default (compare _ comparator) i (length l - 1) l) default).", "decomposition": [], "retrieval": ["swapSelf", "pickSmallestInRangeCompare", "swapApp", "listDecomposition", "pickSmallestInRangeUpperBound", "pickSmallestInRangeInvariant", "updateSelf", "lessThanOrEqual", "pickSmallestInRangeFold"], "type": "proof", "remove_type": "abort"}], "theories/SelectionSortProperties.v": [{"name": "selectionSortPermutation", "text": "Lemma selectionSortPermutation {A : Type} (default : A) (compare : A -> A -> bool) (l : list A) : Permutation l (selectionSort default compare l).", "decomposition": [], "retrieval": ["swapSelf", "partialSelectionSortPreservesLength", "selectionSortComplete", "iLessEqualPickSmallestInRange", "listDecomposition", "swapDecomposition", "pickSmallestInRangeUpperBound", "partialSelectionSortSucc"], "type": "proof", "remove_type": "abort"}, {"name": "selectionSortCorrect", "text": "Lemma selectionSortCorrect {A : Type} (default : A) (comparator : Comparator A) (l : list A) : sorted default (compare _ comparator) (selectionSort default (compare _ comparator) l).", "decomposition": [], "retrieval": ["selectionSortPreservesLength", "partialSelectionSortInvariant"], "type": "proof", "remove_type": "abort"}, {"name": "partialSelectionSortInvariant", "text": "Lemma partialSelectionSortInvariant {A : Type} (default : A) (comparator : Comparator A) (l : list A) (i : nat) (hLt : i < length l) : prefixSorted default (compare _ comparator) (partialSelectionSort default (compare _ comparator) l (S i)) (S i) /\\ partitioned default (compare _ comparator) (partialSelectionSort default (compare _ comparator) l (S i)) i.", "decomposition": [], "retrieval": ["partialSelectionSortZero", "pickSmallestInRangeCompare", "swapPreservesLength", "partialSelectionSortPreservesLength", "iLessEqualPickSmallestInRange", "partialSelectionSortSucc", "pickSmallestInRangeUpperBound", "nthSwapVariant", "nthSwap", "nthSwapExcept"], "type": "proof", "remove_type": "abort"}, {"name": "partialSelectionSortPreservesLength", "text": "Lemma partialSelectionSortPreservesLength {A : Type} (default : A) (compare : A -> A -> bool) (l : list A) (iterationCount : nat) : length (partialSelectionSort default compare l iterationCount) = length l.", "decomposition": [], "retrieval": ["swapPreservesLength"], "type": "proof", "remove_type": "abort"}, {"name": "selectionSortPreservesLength", "text": "Lemma selectionSortPreservesLength {A : Type} (default : A) (compare : A -> A -> bool) (l : list A) : length (selectionSort default compare l) = length l.", "decomposition": [], "retrieval": ["swapPreservesLength"], "type": "proof", "remove_type": "abort"}], "theories/SortedProperties.v": [{"name": "sortedArraysEqual", "text": "Lemma sortedArraysEqual [A : Type] [default : A] [l1 l2 : list A] [comparator : Comparator A] (hPermutation : Permutation l1 l2) (hL1Sorted : sorted default (compare _ comparator) l1) (hL2Sorted : sorted default (compare _ comparator) l2) (comparatorStrict : forall a b, compare _ comparator a b \\/ compare _ comparator b a \\/ a = b) : l1 = l2.", "decomposition": [], "retrieval": ["sortedCons", "elemOfIff"], "type": "proof", "remove_type": "abort"}]}, "0f1527020bd573730bb116c300d43f2f3be49aa3": {"theories/Completion.v": [{"name": "fillSplit", "text": "Lemma fillSplit (b : A) (s1 s2 : list A) (withBlanks : list (option A)) : length (s1 ++ [b] ++ s2) = count_occ decide withBlanks None -> exists wb1 wb2, withBlanks = wb1 ++ [None] ++ wb2 /\\ length s1 = count_occ decide wb1 None /\\ length s2 = count_occ decide wb2 None.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "extractAnswersCorrect", "text": "Lemma extractAnswersCorrect (s : list (option A)) (completed : list A) (h : isCompletion s completed) (h1 : length (extractAnswers s completed h) = count_occ decide s None) h2 : fill s (extractAnswers s completed h2) h1 = completed.", "decomposition": ["laxFillEqFill"], "retrieval": [], "remove_type": "abort"}, {"name": "extractAnswersLength", "text": "Lemma extractAnswersLength (s : list (option A)) (completed : list A) h : length (extractAnswers s completed h) = count_occ decide s None.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "partialCompletionTransitive", "text": "Lemma partialCompletionTransitive (s1 s2 s3 : list (option A)) (h1 : isPartialCompletion s1 s2) (h2 : isPartialCompletion s2 s3) : isPartialCompletion s1 s3.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fillApp", "text": "Lemma fillApp (w1 w2 : list (option A)) (s1 s2 : list A) h1 h2 h3 : fill (w1 ++ w2) (s1 ++ s2) h3 = fill w1 s1 h1 ++ fill w2 s2 h2.", "decomposition": ["laxFillApp", "laxFillEqFill"], "retrieval": [], "remove_type": "abort"}, {"name": "laxFillApp", "text": "Lemma laxFillApp (w1 w2 : list (option A)) (s1 s2 : list A) (h1 : length s1 = count_occ decide w1 None) (h2 : length s2 = count_occ decide w2 None) : laxFill (w1 ++ w2) (s1 ++ s2) = laxFill w1 s1 ++ laxFill w2 s2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "laxFillEqFill", "text": "Lemma laxFillEqFill (withBlanks : list (option A)) (toFill : list A) h : laxFill withBlanks toFill = fill withBlanks toFill h.", "decomposition": ["foldFill"], "retrieval": [], "remove_type": "abort"}, {"name": "foldFill", "text": "Lemma foldFill (withBlanks : list (option A)) (toFill : list A) h h' : fill withBlanks toFill h = stripOptions (fillPartial withBlanks toFill) h'.", "decomposition": ["stripOptionsProofIndependent"], "retrieval": [], "remove_type": "abort"}, {"name": "stripOptionsProofIndependent", "text": "Lemma stripOptionsProofIndependent (l : list (option A)) (h1 h2 : Forall is_Some l) : stripOptions l h1 = stripOptions l h2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rightLengthApp", "text": "Lemma rightLengthApp (w1 w2 : list (option A)) (s1 s2 : list A) : length s1 = count_occ decide w1 None -> length s2 = count_occ decide w2 None -> length (s1 ++ s2) = count_occ decide (w1 ++ w2) None.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stripOptionsPreservesLength", "text": "Lemma stripOptionsPreservesLength (l : list (option A)) (hNoOptions : Forall is_Some l) : length l = length (stripOptions l hNoOptions).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fillPartialPreservesLength", "text": "Lemma fillPartialPreservesLength : forall answers, length (fillPartial withBlanks answers) = length withBlanks.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "isPartialCompletionMeansLengthEqual", "text": "Lemma isPartialCompletionMeansLengthEqual : forall withBlanks, isPartialCompletion withBlanks partialFilled -> length withBlanks = length partialFilled.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "isCompletionMeansLengthEqual", "text": "Lemma isCompletionMeansLengthEqual : forall withBlanks, isCompletion withBlanks filled -> length withBlanks = length filled.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "noNoneIfCorrectLength", "text": "Lemma noNoneIfCorrectLength (h : length answers = count_occ decide withBlanks None) : Forall is_Some (fillPartial withBlanks answers).", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "86132edc9d77b2683af7025d89470b292a70e9ab": {}, "42b9bc185271cb05cd7522a26420a782f8a861fa": {"theories/ListDecomposition.v": [{"name": "listDecompositionSingle", "text": "Lemma listDecompositionSingle {A : Type} (l : list A) (i : nat) (hLt : i < length l) (default : A) : l = take i l ++ [nth i l default] ++ drop (S i) l.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "listDecomposition", "text": "Lemma listDecomposition {A : Type} (l : list A) (i j : nat) (hLt : i < j) (hUpperBound : j < length l) (default : A) : l = take i l ++ [nth i l default] ++ drop (S i) (take j l) ++ [nth j l default] ++ drop (j + 1) l.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}], "theories/Completion.v": [{"name": "fillInOneBlank", "text": "Lemma fillInOneBlank (withBlanks : list (option A)) (k : nat) (hReasonable : k < count_occ decide withBlanks None) (value : A) (answers : list A) h1 h2 : fill withBlanks (take k answers ++ [value] ++ drop k answers) h1 = fill (<[getKthBlank withBlanks k := Some value]> withBlanks) answers h2.", "decomposition": ["getKthBlankUpperBound", "listDecompositionSingle"], "retrieval": ["updateAppZero", "fillLaxEqFill", "fillLaxApp", "fillSplit"], "remove_type": "abort"}, {"name": "fillInOneBlank_h2Parameter", "text": "Lemma fillInOneBlank_h2Parameter (withBlanks : list (option A)) (k : nat) (hReasonable: k < count_occ decide withBlanks None) (value : A) (answers : list A) (h : length answers + 1 = count_occ decide withBlanks None) : length answers = count_occ decide (<[getKthBlank withBlanks k:= Some value]> withBlanks) None.", "decomposition": ["getKthBlankUpperBound", "nthGetKthBlank", "listDecompositionSingle"], "retrieval": ["updateAppZero"], "remove_type": "abort"}, {"name": "fillInOneBlank_h1Parameter", "text": "Lemma fillInOneBlank_h1Parameter (withBlanks : list (option A)) (k : nat) (hReasonable: k < count_occ decide withBlanks None) (value : A) (answers : list A) (h : length answers + 1 = count_occ decide withBlanks None) : length (take k answers ++ [value] ++ drop k answers) = count_occ decide withBlanks None.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fillSplit", "text": "Lemma fillSplit (b : A) (s1 s2 : list A) (withBlanks : list (option A)) k (hK : k = length s1) : length (s1 ++ [b] ++ s2) = count_occ decide withBlanks None -> withBlanks = take (getKthBlank withBlanks k) withBlanks ++ [None] ++ drop (S (getKthBlank withBlanks k)) withBlanks /\\ length s1 = count_occ decide (take (getKthBlank withBlanks k) withBlanks) None /\\ length s2 = count_occ decide (drop (S (getKthBlank withBlanks k)) withBlanks) None.", "decomposition": ["getKthBlankUpperBound", "nthGetKthBlank", "listDecompositionSingle"], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "getKthBlankUpperBound", "text": "Lemma getKthBlankUpperBound (withBlanks : list (option A)) (k : nat) (hReasonable : k < count_occ decide withBlanks None) : getKthBlank withBlanks k < length withBlanks.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "nthGetKthBlank", "text": "Lemma nthGetKthBlank (withBlanks : list (option A)) (k : nat) (default : option A) (hReasonable : k < count_occ decide withBlanks None) : nth (getKthBlank withBlanks k) withBlanks default = None.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/SwapUpdate.v": [{"name": "oneDifferentPlace", "text": "Lemma oneDifferentPlace {A : Type} `{EqDecision A} (l1 l2 : list A) (default : A) (hDiff : l1 <> l2) (hSameLength : length l1 = length l2) : exists i, i < length l1 /\\ nth i l1 default <> nth i l2 default.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "82b8832c3da303709ee98cd0862dbffcbc19ae12": {}, "41171ba4fd4d1463b29a963004b3a5ad9c5dba7c": {"theories/SwapUpdate.v": [{"name": "nthAppGeq", "text": "Lemma nthAppGeq {A : Type} (default : A) (l1 l2 : list A) (i : nat) (hI : length l1 <= i) : nth i (l1 ++ l2) default = nth (i - length l1) l2 default.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "nthAppLt", "text": "Lemma nthAppLt {A : Type} (default : A) (l1 l2 : list A) (i : nat) (hI : i < length l1) : nth i (l1 ++ l2) default = nth i l1 default.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/Completion.v": [{"name": "fillInOneBlank", "text": "Lemma fillInOneBlank (withBlanks : list (option A)) (k : nat) (hReasonable : k < count_occ decide withBlanks None) (value : A) (answers : list A) (h : length answers + 1 = count_occ decide withBlanks None) : fill withBlanks (take k answers ++ [value] ++ drop k answers) = fill (<[getKthBlank withBlanks k := Some value]> withBlanks) answers.", "decomposition": ["takeKthBlankCountOcc"], "retrieval": ["fillApp", "getKthBlankUpperBound", "updateAppZero", "fillInOneBlank_h1Parameter", "fillSplit", "listDecompositionSingle"], "type": "both", "remove_type": "abort"}, {"name": "dropSuccKthBlankCountOcc", "text": "Lemma dropSuccKthBlankCountOcc (withBlanks : list (option A)) (k : nat) : count_occ decide (drop (S (getKthBlank withBlanks k)) withBlanks) None = count_occ decide withBlanks None - k - 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "dropKthBlankCountOcc", "text": "Lemma dropKthBlankCountOcc (withBlanks : list (option A)) (k : nat) : count_occ decide (drop (getKthBlank withBlanks k) withBlanks) None = count_occ decide withBlanks None - k.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "takeKthBlankCountOcc", "text": "Lemma takeKthBlankCountOcc (withBlanks : list (option A)) (k : nat) (hReasonable : k < count_occ decide withBlanks None) : count_occ decide (take (getKthBlank withBlanks k) withBlanks) None = k.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fillIsCompletion", "text": "Lemma fillIsCompletion (withBlanks : list (option A)) (answers : list A) (h : length answers = count_occ decide withBlanks None) : isCompletion withBlanks (fill withBlanks answers).", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "extractAnswersCorrect", "text": "Lemma extractAnswersCorrect (s : list (option A)) (completed : list A) (h : isCompletion s completed) (h1 : length (extractAnswers s completed) = count_occ decide s None) : fill s (extractAnswers s completed) = completed.", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "extractAnswersLength", "text": "Lemma extractAnswersLength (s : list (option A)) (completed : list A) (h : isCompletion s completed): length (extractAnswers s completed) = count_occ decide s None.", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "fillApp", "text": "Lemma fillApp (w1 w2 : list (option A)) (s1 s2 : list A) (h1 : length s1 = count_occ decide w1 None) (h2 : length s2 = count_occ decide w2 None) : fill (w1 ++ w2) (s1 ++ s2) = fill w1 s1 ++ fill w2 s2.", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "noNoneIfCorrectLength", "text": "Lemma noNoneIfCorrectLength withBlanks answers (h : length answers = count_occ decide withBlanks None) : Forall is_Some (fillPartial withBlanks answers).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "stripOptionsPreservesLength", "text": "Lemma stripOptionsPreservesLength (l : list (option A)) (default : A) : length l = length (stripOptions l default).", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "fillPartialPreservesLength", "text": "Lemma fillPartialPreservesLength withBlanks : forall answers, length (fillPartial withBlanks answers) = length withBlanks.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "isPartialCompletionMeansLengthEqual", "text": "Lemma isPartialCompletionMeansLengthEqual : forall withBlanks partialFilled, isPartialCompletion withBlanks partialFilled -> length withBlanks = length partialFilled.", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "isCompletionMeansLengthEqual", "text": "Lemma isCompletionMeansLengthEqual : forall withBlanks filled, isCompletion withBlanks filled -> length withBlanks = length filled.", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}]}, "76b8878bd8a3b2a9a4a1dda0dd2b10aca8165ce1": {"theories/DisjointSetUnion.v": [{"name": "rule2_a1", "text": "Lemma rule2_a1 (a b c d : Tree) : encodeToNat (Unite (Unite a b) (Unite c d)) > encodeToNat (Unite (Unite (Unite a b) c) d).", "decomposition": ["listToNatFalse", "listToNatAppLt", "listToNatAppFirst", "encodeToListFirstTrue"], "retrieval": [], "remove_type": "abort"}, {"name": "rule1_a1", "text": "Lemma rule1_a1 (a b : Tree) : encodeToNat (Unite Unit (Unite a b)) > encodeToNat (Unite (Unite a b) Unit).", "decomposition": ["listToNatFalse", "listToNatFalseTrue"], "retrieval": [], "remove_type": "abort"}, {"name": "listToNatAppFirst", "text": "Lemma listToNatAppFirst (x a : list bool) : listToNat a <= listToNat (x ++ a).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "listToNatAppLt", "text": "Lemma listToNatAppLt (x a b : list bool) (h : listToNat a < listToNat b) : listToNat (x ++ a) < listToNat (x ++ b).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "listToNatFalseTrue", "text": "Lemma listToNatFalseTrue (x : list bool) : listToNat ((x ++ [false]) ++ [true]) > listToNat x + listToNat x + 1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "listToNatTrue", "text": "Lemma listToNatTrue (x : list bool) : listToNat (x ++ [true]) > listToNat x + listToNat x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "listToNatFalse", "text": "Lemma listToNatFalse (x : list bool) : listToNat (x ++ [false]) = listToNat x.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "zeroLtEncodeToNat", "text": "Lemma zeroLtEncodeToNat (x : Tree) : 0 < encodeToNat x.", "decomposition": ["encodeToListFirstTrue"], "retrieval": [], "remove_type": "abort"}, {"name": "encodeToListFirstTrue", "text": "Lemma encodeToListFirstTrue (x : Tree) : exists s, encodeToList x = true :: s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}}