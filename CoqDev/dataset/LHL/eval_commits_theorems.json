{"658bb86cd7610b37cbf6aa91e49b3b2b9dfad610": {"Examples/LockSpec.v": [{"name": "LockStepActiveMapStep", "text": "Lemma LockStepActiveMapStep {T} : forall s1 s2 (te: @ThreadEvent T LockSig), LockStep s1 te s2 -> ActiveMapStep (LockActiveMap s1) te (LockActiveMap s2).", "decomposition": [], "retrieval": ["eqb_id", "differ_pointwise_trivial", "eqb_nid"], "remove_type": "admit"}, {"name": "LockActiveMapSound", "text": "Global Lemma LockActiveMapSound {T} : @acf_sound T LockSig lockSpec LockActiveMap.", "decomposition": ["LockStepActiveMapStep"], "retrieval": [], "remove_type": "abort"}], "Core/UBLayer.v": [{"name": "PossSetEmbedForgetUB", "text": "Lemma PossSetEmbedForgetUB {T F} {spec: Spec T F} (acf: ActiveF spec.(Step)) (HAcf: acf_sound acf) : forall \u03c1s, PossSetRemoveUB acf HAcf (PossSetWithUB acf HAcf \u03c1s) = \u03c1s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reltUBEmbedding", "text": "Lemma reltUBEmbedding {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall (R: Relt VE VF) s \u03c1s t \u03c3s, R s \u03c1s t \u03c3s -> ReltWithUBFull acf HAcf R s (PossSetWithUB acf HAcf \u03c1s) t (PossSetWithUB acf HAcf \u03c3s).", "decomposition": ["PossSetEmbedForgetUB"], "retrieval": [], "remove_type": "abort"}, {"name": "reltCompUB", "text": "Lemma reltCompUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall R1 R2 : Relt VE VF, ReltWithUBFull acf HAcf (R1 ->> R2) = ReltWithUBFull acf HAcf R1 ->> ReltWithUBFull acf HAcf R2.", "decomposition": ["PossSetEmbedForgetUB"], "retrieval": [], "remove_type": "admit"}, {"name": "precToReltUB", "text": "Lemma precToReltUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall P : Prec VE VF, PrecToRelt (PrecWithUB acf HAcf P) ==> ReltWithUBFull acf HAcf (PrecToRelt P).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reltToPrecUB", "text": "Lemma reltToPrecUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall R : Relt VE VF, ReltToPrec (ReltWithUBFull acf HAcf R) = PrecWithUB acf HAcf (ReltToPrec R).", "decomposition": ["PossSetEmbedForgetUB"], "retrieval": [], "remove_type": "abort"}, {"name": "ReltPostUBEmbedding", "text": "Lemma ReltPostUBEmbedding {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall (R : Relt VE VF) Ret (Q: Post VE VF Ret) (v: Ret), R ==> (Q v) -> ReltWithUBFull acf HAcf R ==> (PostWithUBFull acf HAcf Q v).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "PostValueUB", "text": "Lemma PostValueUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall A (Q: Post VE VF A) v, (PostWithUBFull acf HAcf Q) v = ReltWithUBFull acf HAcf (Q v).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reltSubUB", "text": "Lemma reltSubUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall (R Q : Relt VE VF), R ==> Q -> ReltWithUBFull acf HAcf R ==> ReltWithUBFull acf HAcf Q.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "silentStepUB", "text": "Lemma silentStepUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall (i: Name T) (G: Relt VE VF) P Q, SilentStep i G P Q -> SilentStep i (ReltWithUBFull acf HAcf G) (PrecWithUB acf HAcf P) (ReltWithUBFull acf HAcf Q).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "commitUB", "text": "Lemma commitUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall i (e: Event E) (G: Relt VE VF) P Q, Commit i G P e Q -> Commit i (ReltWithUBFull acf HAcf G) (PrecWithUB acf HAcf P) e (ReltWithUBFull acf HAcf Q).", "decomposition": ["PossSetEmbedForgetUB"], "retrieval": ["possStepsUB", "PossWithUBUnfold", "PossSetEmbedding"], "remove_type": "abort"}, {"name": "SafeProgUB", "text": "Lemma SafeProgUB {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall i A (R: Relt VE VF) (G: Relt VE VF) P (Q: Post VE VF A) prog, SafeProg i R G P prog Q -> SafeProg i (ReltWithUBFull acf HAcf R) (ReltWithUBFull acf HAcf G) (ReltWithUBFull acf HAcf P) prog (PostWithUBFull acf HAcf Q).", "decomposition": [], "retrieval": ["reltToPrecUB", "paco_eqv", "ReltPostUBEmbedding", "commitUB", "PostValueUB", "stablePostUB", "reltCompUB", "stableReltUB", "silentStepUB"], "remove_type": "abort"}, {"name": "VerifyWithUB", "text": "Lemma VerifyWithUB {T E F} {VE : Spec T E} {VF : Spec T F} {R G : Name T -> Relt VE VF} {P : Name T -> forall Ret, F Ret -> Prec VE VF} {impl : Impl E F} {Q : Name T -> forall Ret, F Ret -> Post VE VF Ret} acf HAcf i A m : (VerifyProg i (R i) (G i) (prComp (P i A m) (TInvoke impl i _ m) ->> R i) (impl _ m) (Q i A m)) -> (VerifyProg i (RelyWithUB acf HAcf R i) (GuarWithUB acf HAcf G i) (prComp (PrecWithUB acf HAcf (P i A m)) (TInvoke impl i _ m) ->> (RelyWithUB acf HAcf R i)) (impl _ m) (PostWithUBFull acf HAcf (Q i A m))).", "decomposition": ["SafeProgUB", "reltComposeMono1"], "retrieval": ["precToReltUB", "precToReltComp", "reltCompInvokeUB", "reltCompUB"], "remove_type": "abort"}, {"name": "coClientSpecIdem", "text": "Lemma coClientSpecIdem {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf (client: ClientSpec VF) i A (m: F A) : (ReltWithUBFull acf HAcf (coClientSpecRelt (E:=E) (VE:=VE) i A m client)) ->> ReltWithUBFull acf HAcf (coClientSpecRelt (E:=E) (VE:=VE) i A m client) = ReltWithUBFull acf HAcf (coClientSpecRelt (E:=E) (VE:=VE) i A m client).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stableReltStablePost", "text": "Lemma stableReltStablePost {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf (client: ClientSpec VF) i A B (m: F A) (R: Name T -> Relt VE VF): stableRelt (R i) (coClientSpecRelt i A m client) -> stablePost (ReltWithUBFull acf HAcf (R i)) (PostWithUBFull acf HAcf (coClientSpecPost i A B m client)).", "decomposition": [], "retrieval": ["stableReltUB"], "remove_type": "abort"}, {"name": "UBReltStable", "text": "Lemma UBReltStable {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf (R: Relt VE (SpecWithUB VF acf HAcf)) i: R ==> RelyUBCom acf HAcf i -> stableRelt R (UBRelt acf HAcf).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "UBPostStable", "text": "Lemma UBPostStable {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf A (R: Relt VE (SpecWithUB VF acf HAcf)) i: R ==> RelyUBCom acf HAcf i -> stablePost R (UBPost acf HAcf A).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "UBPostUBRelt", "text": "Lemma UBPostUBRelt {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall A (v: A), (@UBPost T E F VE VF acf HAcf A v) = UBRelt acf HAcf.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "UBReltID", "text": "Lemma UBReltID {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: forall s \u03c1s t, (exists \u03c1, \u03c1s \u03c1) -> (forall \u03c1: Poss(SpecWithUB VF acf HAcf), \u03c1s \u03c1 -> exists a, (PState \u03c1) = inr (UBState_, a)) -> (@UBRelt T E F VE VF acf HAcf) s \u03c1s t \u03c1s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "UBPostId", "text": "Lemma UBPostId {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf A: forall v s \u03c1s t, (exists \u03c1, \u03c1s \u03c1) -> (forall \u03c1: Poss(SpecWithUB VF acf HAcf), \u03c1s \u03c1 -> exists a, (PState \u03c1) = inr (UBState_, a)) -> (@UBPost T E F VE VF acf HAcf A) v s \u03c1s t \u03c1s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "UBReltIdem", "text": "Lemma UBReltIdem {T E F} {VE: Spec T E} {VF: Spec T F} acf HAcf: (@UBRelt T E F VE VF acf HAcf) ->> (UBRelt acf HAcf) = UBRelt acf HAcf.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "UB_verify_UB", "text": "Lemma UB_verify_UB {T E F} {VE : Spec T E} {VF : Spec T F} {acf HAcf} (R G : Relt VE (SpecWithUB VF acf HAcf)) (P : Relt VE (SpecWithUB VF acf HAcf)) : forall A (prog : Prog E A) (i: Name T), P ==> UBRelt acf HAcf -> R ==> RelyUBCom acf HAcf i -> GuarUBCom acf HAcf i ==> G -> VerifyProg i R G P prog (UBPost acf HAcf A).", "decomposition": ["UBReltIdem", "UBReltStable", "UBPostId", "subReltTrans", "UBReltID", "reltComposeMono1", "UBPostUBRelt", "UBPostStable"], "retrieval": ["paco_eqv"], "remove_type": "admit"}], "Core/LogicFacts.v": [{"name": "reltComposeMono1", "text": "Lemma reltComposeMono1 {T E F} {VE: Spec T E} {VF: Spec T F} : forall (R1 R2 Q : Relt VE VF), R1 ==> R2 -> R1 ->> Q ==> R2 ->> Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reltComposeMono2", "text": "Lemma reltComposeMono2 {T E F} {VE: Spec T E} {VF: Spec T F} : forall (P R1 R2 : Relt VE VF), R1 ==> R2 -> P ->> R1 ==> P ->> R2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subReltTrans", "text": "Lemma subReltTrans {T E F} {VE: Spec T E} {VF: Spec T F} : forall (R1 R2 R3 : Relt VE VF), R1 ==> R2 -> R2 ==> R3 -> R1 ==> R3.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "comp_commit", "text": "Lemma comp_commit {T E F} {VE : Spec T E} {VF : Spec T F} {M : Impl E F} i e : (forall st p, InterSteps M (allIdle, Init VE) p st -> exists st' q, projOver p = projOver q /\\ FullPossSteps (VF:=VF) initPoss q st') -> Commit i (comp_guar VE VF M i) (comp_inv VE VF M) e (fun _ _ => comp_inv VE VF M).", "decomposition": [], "retrieval": ["Steps_app", "projOver_app", "full_to_local"], "remove_type": "admit"}]}, "0cda85adc4e81e7e10288029e3438ce0e6682462": {"Util/Util.v": [{"name": "insert_perm", "text": "Lemma insert_perm : forall {A} (s : set A) x y, insert x (insert y s) = insert y (insert x s).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "insert_unique", "text": "Lemma insert_unique : forall {A} (s : set A) x, insert x (insert x s) = insert x s.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "help", "text": "Lemma help : forall P Q, P = Q -> P <-> Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "insert_cong1", "text": "Lemma insert_cong1 : forall {A} (x y : A), insert x emp = insert y emp -> x = y.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "insert_cong2", "text": "Lemma insert_cong2 : forall {A} (x y z w : A), x <> y -> insert x (insert y emp) = insert z (insert w emp) -> x = z /\\ y = w \\/ x = w /\\ y = z.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "insert_cong2_left", "text": "Lemma insert_cong2_left : forall {I A} (i j k l : I) (x y z w : A), i <> j -> j <> k -> insert (i, x) (insert (j, y) emp) = insert (k, z) (insert (l, w) emp) -> (i, x) = (k, z) /\\ insert (j, y) emp = insert (l, w) emp.", "decomposition": ["insert_cong2"], "retrieval": [], "remove_type": "abort"}, {"name": "insert_cong2_pad", "text": "Lemma insert_cong2_pad : forall {I A} (i j k : I) (x y z : A), i <> j -> insert (i, x) (insert (j, y) emp) = insert (i, x) (insert (k, z) emp) -> (j, y) = (k, z).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "disj_cons", "text": "Lemma disj_cons : forall {A} (s : set A) x, insert x s <> emp.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "disj_cons2", "text": "Lemma disj_cons2 : forall {I A} (i j : I) (x y : A), i <> j -> insert (i, x) (insert (j, y) emp) <> (insert (i, x) emp).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "contains_triv", "text": "Lemma contains_triv : forall {A} (s : set A) x, contains x (insert x s).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "contains_contr", "text": "Lemma contains_contr : forall {A} (x : A), ~contains x emp.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "contains_invert", "text": "Lemma contains_invert : forall {A} (s : set A) x y, contains x (insert y s) -> x = y \\/ contains x s.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "8422229fe62b30117fbc20bb4b9541f5c6f6ba37": {"Core/Eutt.v": [{"name": "Symmetric_eutt_", "text": "Lemma Symmetric_eutt_ {M1 M2} (RR : IRel M1 M2) (RR' : IRel M2 M1) {R} (SYM : forall X m1 m2, RR X m1 m2 -> RR' X m2 m1) : forall (p1 : Prog M1 R) (p2 : Prog M2 R), eutt RR p1 p2 -> eutt RR' p2 p1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Symmetric_eutt", "text": "Lemma Symmetric_eutt {M} (RR : IRel M M) {R} (SYM : forall X m1 m2, RR X m1 m2 -> RR X m2 m1) : forall (p1 : Prog M R) (p2 : Prog M R), eutt RR p1 p2 -> eutt RR p2 p1.", "decomposition": ["Symmetric_eutt_"], "retrieval": [], "remove_type": "abort"}, {"name": "Symmetric_eutt_ieq", "text": "Lemma Symmetric_eutt_ieq {M} {R} : forall (p1 : Prog M R) (p2 : Prog M R), eutt ieq p1 p2 -> eutt ieq p2 p1.", "decomposition": ["Symmetric_eutt"], "retrieval": [], "remove_type": "abort"}, {"name": "inv_eutt_Noop_left", "text": "Lemma inv_eutt_Noop_left {R} : forall (p1 : Prog E2 R) (p2 : Prog E3 R), euttF R23 (upaco2 (euttF R23 (Ret := R)) bot2) (NoOp p1) p2 -> euttF R23 (upaco2 (euttF R23 (Ret := R)) bot2) p1 p2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "inv_eutt_Noop_right", "text": "Lemma inv_eutt_Noop_right {R} : forall (p1 : Prog E1 R) (p2 : Prog E2 R), euttF R12 (upaco2 (euttF R12 (Ret := R)) bot2) p1 (NoOp p2) -> euttF R12 (upaco2 (euttF R12 (Ret := R)) bot2) p1 p2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Transitive_eutt", "text": "Lemma Transitive_eutt {R} : forall (p1 : Prog E1 R) (p2 : Prog E2 R) (p3 : Prog E3 R), eutt R12 p1 p2 -> eutt R23 p2 p3 -> eutt R13 p1 p3.", "decomposition": ["inv_eutt_Noop_right", "inv_eutt_Noop_left"], "retrieval": [], "remove_type": "abort"}, {"name": "Transitive_eutt_ieq", "text": "Lemma Transitive_eutt_ieq {M R} : forall (p1 : Prog M R) (p2 : Prog M R) (p3 : Prog M R), eutt ieq p1 p2 -> eutt ieq p2 p3 -> eutt ieq p1 p3.", "decomposition": ["Transitive_eutt"], "retrieval": [], "remove_type": "abort"}], "Util/TransUtil.v": [{"name": "Steps_nil", "text": "Lemma Steps_nil {E A} (step : A -> E -> A -> Prop) x y : Steps step x nil y <-> x = y.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Steps_app", "text": "Lemma Steps_app {E A} (step : A -> E -> A -> Prop) (xs ys : list E) s s' s'' : Steps step s xs s' -> Steps step s' ys s'' -> Steps step s (xs ++ ys) s''.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "Core/TracesFacts.v": [{"name": "nil_IsTraceOfSpec", "text": "Lemma nil_IsTraceOfSpec {E} : forall (spec : Spec E), IsTraceOfSpec nil spec.", "decomposition": [], "retrieval": [], "remove_type": "admit"}]}, "e3ad277d62b92a9e9c0ca85384ee0ff3a2334933": {"Core/LogicFacts.v": [{"name": "reltCompIdLeft", "text": "Lemma reltCompIdLeft {Q : Relt VE VF} : Q ->> id = Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reltCompIdRight", "text": "Lemma reltCompIdRight {Q : Relt VE VF} : id ->> Q = Q.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "reltStabilizedStable", "text": "Lemma reltStabilizedStable {Q} : (R ->> R ==> R) -> Stable R (R ->> Q ->> R).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rtcTrans", "text": "Lemma rtcTrans {E F VE VF} {R : @Relt E F VE VF} : (RTC R ->> RTC R) ==> RTC R.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rtcTransTac", "text": "Lemma rtcTransTac {E F VE VF} {R : @Relt E F VE VF} {s \u03c1 t \u03c3 r \u03c4} : RTC R s \u03c1 t \u03c3 -> RTC R t \u03c3 r \u03c4 -> RTC R s \u03c1 r \u03c4.", "decomposition": [], "retrieval": ["rtcTrans"], "remove_type": "admit"}, {"name": "extendRtcLeft", "text": "Lemma extendRtcLeft {E F VE VF} {R : @Relt E F VE VF} {s \u03c1 t \u03c3 r \u03c4} : R s \u03c1 t \u03c3 -> RTC R t \u03c3 r \u03c4 -> RTC R s \u03c1 r \u03c4.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "extendRtcRight", "text": "Lemma extendRtcRight {E F VE VF} {R : @Relt E F VE VF} {s \u03c1 t \u03c3 r \u03c4} : RTC R s \u03c1 t \u03c3 -> R t \u03c3 r \u03c4 -> RTC R s \u03c1 r \u03c4.", "decomposition": [], "retrieval": ["rtcTrans"], "remove_type": "admit"}, {"name": "spStable", "text": "Lemma spStable {E F VE VF impl i} {e : @Event E} {R : @Relt E F VE VF} : Stable R (sp e impl i R).", "decomposition": [], "retrieval": ["rtcTrans"], "remove_type": "abort"}, {"name": "spStrong", "text": "Lemma spStrong {E VE F VF impl i P} {e : @Event E} {R G : @Relt E F VE VF} : prComp P (sp e impl i R) ==> G -> Commit i impl G P e (sp e impl i R).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "cbcb2d22fd711a1a231173c5dbb2abb2057209ba": {"Core/ProgramFacts.v": [{"name": "eqProgEq", "text": "Lemma eqProgEq: forall E Ret p, @progEq E Ret p p.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "eqProgEq'", "text": "Lemma eqProgEq': forall E Ret p1 p2, p1 = p2 -> @progEq E Ret p1 p2.", "decomposition": ["eqProgEq"], "retrieval": [], "remove_type": "abort"}, {"name": "progEqSym", "text": "Lemma progEqSym: forall E Ret p1 p2, @progEq E Ret p1 p2 -> @progEq E Ret p2 p1.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "progEqTrans", "text": "Lemma progEqTrans: forall E Ret p1 p2 p3, @progEq E Ret p1 p2 -> @progEq E Ret p2 p3 -> @progEq E Ret p1 p3.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "mapProgProgEq", "text": "Lemma mapProgProgEq: forall (E F : Type -> Type) (f : forall Ret : Type, E Ret -> F Ret) (Ret : Type) (x y : Prog E Ret), progEq x y -> progEq (mapProg f x) (mapProg f y).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "implEqRefl", "text": "Lemma implEqRefl : forall E F impl, @implEq E F impl impl.", "decomposition": ["eqProgEq"], "retrieval": [], "remove_type": "abort"}, {"name": "implEqSym", "text": "Lemma implEqSym : forall E F impl impl', @implEq E F impl impl' -> @implEq E F impl' impl.", "decomposition": ["progEqSym"], "retrieval": [], "remove_type": "abort"}, {"name": "implEqTrans", "text": "Lemma implEqTrans : forall E F impl impl' impl'', @implEq E F impl impl' -> @implEq E F impl' impl'' -> @implEq E F impl impl''.", "decomposition": ["progEqTrans"], "retrieval": [], "remove_type": "admit"}], "Core/RefinesFacts.v": [{"name": "specRefines_trans", "text": "Lemma specRefines_trans {E} : forall (spec1 : Spec E) (spec2 : Spec E) (spec3 : Spec E), specRefines spec1 spec2 -> specRefines spec2 spec3 -> specRefines spec1 spec3.", "decomposition": [], "retrieval": ["Incl_trans"], "remove_type": "abort"}]}, "5e3785090697c3566b857760d9854a12c2dbc842": {"Core/EuttRefinesSetup.v": [{"name": "get_nones_nil", "text": "Lemma get_nones_nil {T E F} : forall i j p, i <> j -> projPoint i eqb (fst (@get_nones T E F j p)) = nil.", "decomposition": [], "retrieval": ["eqb_nid"], "remove_type": "abort"}, {"name": "help37", "text": "Lemma help37 {T E F} : forall i n qc t0 p l, i <> n -> projPoint i eqb (@interleave T E F (dedup l) p (fun j => if n =? j then t0 else qc j)) = projPoint i eqb (interleave (dedup l) p qc).", "decomposition": [], "retrieval": ["eqb_id", "get_nones_nil", "projPoint_app", "eqb_nid"], "remove_type": "admit"}, {"name": "beq_comm", "text": "Lemma beq_comm {A} : forall n m : A, n =? m = (m =? n).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "help12", "text": "Lemma help12 {T E F} : forall (p : Trace (ThreadLEvent T E F)), forall (qc : Name T -> Trace (LEvent E F)), (forall i, ~In i (dedup (map fst p)) -> qc i = nil) -> (forall i, euttTrace (projPoint i eqb p) (qc i)) -> exists q, euttThreadTrace p q /\\ forall i, projPoint i eqb q = qc i.", "decomposition": [], "retrieval": ["eqb_id", "help22", "beq_comm", "help23", "euttTraceThread_app", "eqb_nid", "help23_t", "euttTraceEvt", "projInterleave", "get_nones_beh"], "remove_type": "admit"}]}, "ba2315fcda91ccbbbaf2804431a81c4d4bab63d4": {"Core/UBLayer.v": [{"name": "possSetUBInv", "text": "Lemma possSetUBInv {T F} {spec: Spec T F} {cspec} (acf: ActiveF spec.(Step)) (HAcf: acf_sound acf) : forall \u03c1s1 \u03c1s2, PossSetWithUB cspec acf HAcf \u03c1s1 = PossSetWithUB cspec acf HAcf \u03c1s2 -> \u03c1s1 = \u03c1s2.", "decomposition": [], "retrieval": ["possSetUBInv_aux"], "remove_type": "abort"}, {"name": "reltCompUB", "text": "Lemma reltCompUB {T E F} {VE: Spec T E} {VF: Spec T F} {cspec} acf HAcf: forall R1 R2 : Relt VE VF, ReltWithUBFull cspec acf HAcf (R1 ->> R2) = ReltWithUBFull cspec acf HAcf R1 ->> ReltWithUBFull cspec acf HAcf R2.", "decomposition": [], "retrieval": ["PossSetEmbedForgetUB"], "remove_type": "admit"}, {"name": "reltToPrecUB", "text": "Lemma reltToPrecUB {T E F} {VE: Spec T E} {VF: Spec T F} {cspec} acf HAcf: forall R : Relt VE VF, ReltToPrec (ReltWithUBFull cspec acf HAcf R) = PrecWithUB cspec acf HAcf (ReltToPrec R).", "decomposition": [], "retrieval": ["PossSetEmbedForgetUB"], "remove_type": "admit"}, {"name": "stepSpecCallUB", "text": "Lemma stepSpecCallUB {T F} {spec: Spec T F} {cspec} (acf: ActiveF spec.(Step)) (HAcf: acf_sound acf) : forall \u03c1 \u03c3 A i (m : F A), spec.(Step) (PState \u03c1) (i, CallEv m) (PState \u03c3) -> StepWithUB cspec spec.(Step) acf (PState (PossWithUB cspec acf HAcf \u03c1)) (i, CallEv m) (PState (PossWithUB cspec acf HAcf \u03c3)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stepSpecRetUB", "text": "Lemma stepSpecRetUB {T F} {spec: Spec T F} {cspec} (acf: ActiveF spec.(Step)) (HAcf: acf_sound acf) : forall \u03c1 \u03c3 A i (m : F A) v, spec.(Step) (PState \u03c1) (i, RetEv m v) (PState \u03c3) -> StepWithUB cspec spec.(Step) acf (PState (PossWithUB cspec acf HAcf \u03c1)) (i, RetEv m v) (PState (PossWithUB cspec acf HAcf \u03c3)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stepSpecUB", "text": "Lemma stepSpecUB {T F} {spec: Spec T F} {cspec} (acf: ActiveF spec.(Step)) (HAcf: acf_sound acf) : forall \u03c1 \u03c3 te, spec.(Step) (PState \u03c1) te (PState \u03c3) -> StepWithUB cspec spec.(Step) acf (PState (PossWithUB cspec acf HAcf \u03c1)) te (PState (PossWithUB cspec acf HAcf \u03c3)).", "decomposition": [], "retrieval": ["stepSpecRetUB", "stepSpecCallUB"], "remove_type": "admit"}, {"name": "commitUB", "text": "Lemma commitUB {T E F} {VE: Spec T E} {VF: Spec T F} {cspec} acf HAcf: forall i (e: Event E) (G: Relt VE VF) P Q, Commit i G P e Q -> Commit i (ReltWithUBFull cspec acf HAcf G) (PrecWithUB cspec acf HAcf P) e (ReltWithUBFull cspec acf HAcf Q).", "decomposition": [], "retrieval": ["possStepsUB", "PossSetEmbedForgetUB", "PossWithUBUnfold", "PossSetEmbedding"], "remove_type": "admit"}, {"name": "VerifyWithUB", "text": "Lemma VerifyWithUB {T E F} {VE : Spec T E} {VF : Spec T F} {cspec} {R G : Name T -> Relt VE VF} {P : Name T -> forall Ret, F Ret -> Prec VE VF} {impl : Impl E F} {Q : Name T -> forall Ret, F Ret -> Post VE VF Ret} acf HAcf i A m : (VerifyProg i (R i) (G i) (prComp (P i A m) (TInvoke impl i _ m) ->> R i) (impl _ m) (Q i A m)) -> (VerifyProg i (RelyWithUB acf HAcf R i) (GuarWithUB acf HAcf G i) (prComp (PrecWithUB cspec acf HAcf (P i A m)) (TInvoke impl i _ m) ->> (RelyWithUB acf HAcf R i)) (impl _ m) (PostWithUBFull cspec acf HAcf (Q i A m))).", "decomposition": [], "retrieval": ["SafeProgUB", "precToReltUB", "reltComposeMono1", "precToReltComp", "reltCompUB"], "remove_type": "abort"}]}, "9c87346765c682069af3b6f865279127670523a2": {"Core/TracesFacts.v": [{"name": "IsTraceOf_iso", "text": "Lemma IsTraceOf_iso {E} t spec : IsTraceOfSpec (E:=E) t spec -> IsTraceOfSpecBwd (to_bwd t) spec.", "decomposition": ["Steps_iso"], "retrieval": [], "remove_type": "abort"}, {"name": "BwdIsTraceOf_iso", "text": "Lemma BwdIsTraceOf_iso {E} t spec : IsTraceOfSpecBwd (E:=E) (to_bwd t) spec -> IsTraceOfSpec t spec.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "decompUnderSteps", "text": "Lemma decompUnderSteps {E F : ESig} {spec : Spec E} : InterUSteps (F:=F) (spec:=spec) = fun s p t => Steps (Step spec) (snd s) (projSilent p) (snd t) /\\ Steps (PointStep UnderThreadStep) (fst s) p (fst t).", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "Core/RefinesFacts.v": [{"name": "help", "text": "Lemma help {E F} : forall (p : Trace (ThreadLEvent E F)), projSilent (projUnder p) = projUnderThr p.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "mkLayer_monotonic", "text": "Theorem mkLayer_monotonic {E F} : forall (spec spec' : Spec E) (impl : Impl E F), specRefines spec' spec -> layerRefines (spec' :> impl) (spec :> impl).", "decomposition": ["decompUnderSteps"], "retrieval": [], "remove_type": "abort"}], "Util/TransUtil.v": [{"name": "BwdSteps_app", "text": "Lemma BwdSteps_app {E A} (step : A -> E -> A -> Prop) (xs ys : bwd_list E) s s' s'' : BwdSteps step s xs s' -> BwdSteps step s' ys s'' -> BwdSteps step s (bwd_app xs ys) s''.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Steps_iso", "text": "Lemma Steps_iso {Ev State} {step : State -> Ev -> State -> Prop} (st st' : State) (xs : list Ev) : Steps step st xs st' -> BwdSteps step st (to_bwd xs) st'.", "decomposition": ["BwdSteps_app"], "retrieval": [], "remove_type": "abort"}]}, "17178dbd53ce3e2042164080d946652be790f689": {"Core/RefinesFacts.v": [{"name": "projUnderSteps", "text": "Lemma projUnderSteps {E F} {lay : Layer E F} : forall s p t, BwdSteps (Step (overObj lay)) s p t -> exists q, BwdSteps (Step lay.(USpec)) (snd s) q (snd t).", "decomposition": [], "retrieval": ["BwdSteps_app", "decompUnderSteps", "Steps_iso"], "remove_type": "abort"}], "Core/TracesFacts.v": [{"name": "projUnderThr_app", "text": "Lemma projUnderThr_app {E F} {p q : Trace (ThreadLEvent E F)} : projUnderThr (p ++ q)%list = (projUnderThr p ++ projUnderThr q)%list.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "projOver_app", "text": "Lemma projOver_app {E F} {p q : Trace (ThreadLEvent E F)} : projOver (p ++ q)%list = (projOver p ++ projOver q)%list.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "projSilent_help", "text": "Lemma projSilent_help {E F} {p : Trace (ThreadName * option (Event E))} : projUnderThr (F:=F) (decompOverObjLift p) = projSilent p.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "projOverUnder", "text": "Lemma projOverUnder {E F} {p : Trace (ThreadLEvent E F)} : IsUnderTrace p -> projOver p = nil.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "decompOverObj", "text": "Lemma decompOverObj {E F} {lay : Layer E F} : Steps (Step (overObj lay)) = fun s p t => exists (q : Trace (ThreadLEvent E F)), p = projOver q /\\ Steps (Step lay.(USpec)) (snd s) (projUnderThr q) (snd t) /\\ Steps (ThreadsStep lay.(LImpl)) (fst s) q (fst t) /\\ IsOverObjTrace q.", "decomposition": ["projOverUnder", "projUnderThr_app", "projOver_app", "projSilent_help"], "retrieval": ["decompUnderSteps", "Steps_app"], "remove_type": "admit"}], "Util/TransUtil.v": [{"name": "Steps_app", "text": "Lemma Steps_app {E A} (step : A -> E -> A -> Prop) (xs ys : list E) s s'' : (exists s', Steps step s xs s' /\\ Steps step s' ys s'') = Steps step s (xs ++ ys) s''.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "3b83352cf7b6bf42bad333b4d67ae0b195119ad0": {"Util/TransUtil.v": [{"name": "bwd_app_nil", "text": "Lemma bwd_app_nil {A} (xs : bwd_list A) : bwd_app Start xs = xs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "BwdSteps_app_inv", "text": "Lemma BwdSteps_app_inv {E A} (step : A -> E -> A -> Prop) (xs ys : bwd_list E) s s'' : BwdSteps step s (bwd_app xs ys) s'' -> exists s', BwdSteps step s xs s' /\\ BwdSteps step s' ys s''.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "BwdSteps_iso", "text": "Lemma BwdSteps_iso {Ev State} {step : State -> Ev -> State -> Prop} (st st' : State) (xs : list Ev) : BwdSteps step st (to_bwd xs) st' -> Steps step st xs st'.", "decomposition": ["BwdSteps_app_inv"], "retrieval": [], "remove_type": "abort"}, {"name": "help10", "text": "Lemma help10 : forall (P Q : nat -> Prop), (forall i, P i /\\ Q i) -> ((forall i, P i) /\\ (forall i, Q i)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eqbT", "text": "Lemma eqbT : forall n, eqb n n = true.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eqbF", "text": "Lemma eqbF : forall n m, n <> m -> n =? m = false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "decompPointSteps", "text": "Lemma decompPointSteps {E A : Type} (step : A -> E -> A -> Prop) : forall s p t, Steps (PointStep (Index:=nat) step) s p t = forall i, Steps step (s i) (projPoint i p) (t i).", "decomposition": ["help10", "eqbF", "eqbT"], "retrieval": ["Steps_nil"], "remove_type": "abort"}]}, "52e348cbf6af0f189c4015ea13f09dde224d42cb": {"Examples/SpinLock.v": [{"name": "Poss_eq_inv", "text": "Lemma Poss_eq_inv: forall {T F} {VF: Spec T F} (i: Name T) (\u03c10: Poss VF) pcall pret, (fun \u03c3 => exists \u03c1, \u03c10 = \u03c1 /\\ PState \u03c3 = PState \u03c1 /\\ PCalls \u03c3 i = pcall /\\ PRets \u03c3 i = pret /\\ differ_pointwise (PCalls \u03c1) (PCalls \u03c3) i /\\ differ_pointwise (PRets \u03c1) (PRets \u03c3) i) = eq ({| PState := PState \u03c10; PCalls := fun k : Name T => if i =? k then pcall else PCalls \u03c10 k; PRets := fun k : Name T => if i =? k then pret else PRets \u03c10 k |} : Poss VF).", "decomposition": [], "retrieval": ["eqb_id", "differ_pointwise_trivial", "eqb_nid"], "remove_type": "admit"}, {"name": "Poss_eq_inv2", "text": "Lemma Poss_eq_inv2: forall {T F} {VF: Spec T F} (i: Name T) (\u03c1: Poss VF) (st: State VF) pcall pret, (fun \u03c3 => PState \u03c3 = st /\\ PCalls \u03c3 i = pcall /\\ PRets \u03c3 i = pret /\\ differ_pointwise (PCalls \u03c1) (PCalls \u03c3) i /\\ differ_pointwise (PRets \u03c1) (PRets \u03c3) i) = eq ({| PState := st; PCalls := fun k : Name T => if i =? k then pcall else PCalls \u03c1 k; PRets := fun k : Name T => if i =? k then pret else PRets \u03c1 k |} : Poss VF).", "decomposition": [], "retrieval": ["eqb_id", "differ_pointwise_trivial", "eqb_nid"], "remove_type": "abort"}, {"name": "Poss_eq_inv3", "text": "Lemma Poss_eq_inv3: forall {T F} {VF: Spec T F} (i: Name T) (\u03c10: Poss VF) \u03c1s pcall pret, \u03c1s = eq \u03c10 -> (fun \u03c3 => exists \u03c1, \u03c1s \u03c1 /\\ PState \u03c3 = PState \u03c1 /\\ PCalls \u03c3 i = pcall /\\ PRets \u03c3 i = pret /\\ differ_pointwise (PCalls \u03c1) (PCalls \u03c3) i /\\ differ_pointwise (PRets \u03c1) (PRets \u03c3) i) = eq ({| PState := PState \u03c10; PCalls := fun k : Name T => if i =? k then pcall else PCalls \u03c10 k; PRets := fun k : Name T => if i =? k then pret else PRets \u03c10 k |} : Poss VF).", "decomposition": [], "retrieval": ["Poss_eq_inv"], "remove_type": "abort"}, {"name": "SpinLock_all_return", "text": "Lemma SpinLock_all_return {T} : forall (i: Name T) A m v, ReturnStep i (Guar i) (Precs i A m <<- Posts i A m v) m v (CSs i A m v).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "SpinLock_Rel_verified", "text": "Lemma SpinLock_Rel_verified {T} : forall (i: Name T), VerifyProg i (Rely i) (Guar i) (prComp (Precs i unit Rel) (TInvoke SpinLockImpl i _ Rel) ->> Rely i) (SpinLockImpl _ Rel) (Posts i unit Rel).", "decomposition": [], "retrieval": ["eqb_id", "Poss_eq_unique2", "lemCall", "lemRet", "inotowns_iownsrel_exclusive", "lemBind", "weakenPrec", "stateStepToUBPossSteps", "eqb_nid", "Poss_eq_unique3", "SpinLock_verify_aux", "is_ub_state_easy", "differ_pointwise_other"], "remove_type": "abort"}, {"name": "SpinLock_all_verified", "text": "Lemma SpinLock_all_verified {T A} : forall (i: Name T) (m: F A), VerifyProg i (Rely i) (Guar i) (prComp (Precs i A m) (TInvoke SpinLockImpl i _ m) ->> Rely i) (SpinLockImpl _ m) (Posts i A m).", "decomposition": [], "retrieval": ["SpinLock_Rel_verified", "SpinLock_Acq_verified"], "remove_type": "admit"}]}}