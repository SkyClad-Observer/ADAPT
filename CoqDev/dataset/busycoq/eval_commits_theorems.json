{"df3e56baf38ba25dd87c5ee0e6fe16b519de4dcb": {}, "e70ab949054069d27019c484c861110bae07a30b": {}, "85163ad79500394196e9eedb661fadb16ae78697": {}, "b65660437012bc868c59833003fac32cc2e44be3": {}, "2e45a81e9f1ec69342b15f4673c2612a24c9e841": {}, "b8747014f2658503db4d82b6047386ce061e5e0a": {}, "9f8fedf71ab8bf911981e8e2a992c788a6555234": {}, "c727b9a045f1775d62cc23537aa675189737c8f3": {}, "a53a8e6698f43808dadf738deab63233adc79577": {}, "4334c70e86c79bea0741f298b8db554944fa7ac5": {}, "c3c45ba1f0695dbc7ece0fa2c260f279a6ae2989": {}, "d9492220e9d08b3fa55c0ef2162b3766dd6b92d8": {}, "9e14392a4e2782205a0fd9c173ea4d7782c9f3de": {}, "cc6aace48a150a9dcd284a604201dc2cbb3e5021": {"verify/TM.v": [{"name": "progress_nonhalt", "text": "Lemma progress_nonhalt : forall tm (P : Q * tape -> Prop) c, (forall c, P c -> exists c', P c' /\\ c -[ tm ]->+ c') -> P c -> ~ halts tm c.", "decomposition": ["progress_nonhalt'"], "retrieval": [], "remove_type": "abort"}, {"name": "progress_nonhalt'", "text": "Lemma progress_nonhalt' : forall tm (P : Q * tape -> Prop), (forall c, P c -> exists c', P c' /\\ c -[ tm ]->+ c') -> forall k c, P c -> ~ halts_in tm c k.", "decomposition": ["preceeds_halt", "strong_induction", "progress_multistep"], "retrieval": ["exceeds_halt"], "remove_type": "abort"}, {"name": "skip_halts", "text": "Lemma skip_halts: forall tm c c' n, c -[ tm ]->> n / c' -> ~ halts tm c' -> ~ halts tm c.", "decomposition": ["preceeds_halt"], "retrieval": ["exceeds_halt"], "type": "proof", "remove_type": "abort"}, {"name": "preceeds_halt", "text": "Lemma preceeds_halt : forall tm c c' n k, halts_in tm c k -> c -[ tm ]->> n / c' -> n <= k -> halts_in tm c' (k - n).", "decomposition": [], "retrieval": ["multistep_deterministic", "rewind_split"], "remove_type": "abort"}, {"name": "progress_evstep_trans", "text": "Lemma progress_evstep_trans : forall tm c c' c'', c -[ tm ]->+ c' -> c' -[ tm ]->* c'' -> c -[ tm ]->+ c''.", "decomposition": ["multistep_progress"], "retrieval": ["with_counter"], "remove_type": "abort"}, {"name": "evstep_progress_trans", "text": "Lemma evstep_progress_trans : forall tm c c' c'', c -[ tm ]->* c' -> c' -[ tm ]->+ c'' -> c -[ tm ]->+ c''.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "evstep_progress", "text": "Lemma evstep_progress : forall tm c c', c -[ tm ]->* c' -> c <> c' -> c -[ tm ]->+ c'.", "decomposition": ["multistep_progress"], "retrieval": ["with_counter"], "remove_type": "abort"}, {"name": "progress_multistep", "text": "Lemma progress_multistep : forall tm c c', c -[ tm ]->+ c' -> exists n, c -[ tm ]->> S n / c'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "multistep_progress", "text": "Lemma multistep_progress : forall tm n c c', c -[ tm ]->> S n / c' -> c -[ tm ]->+ c'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "progress_trans", "text": "Lemma progress_trans : forall tm c c' c'', c -[ tm ]->+ c' -> c' -[ tm ]->+ c'' -> c -[ tm ]->+ c''.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "verify/Skelet34.v": [{"name": "nonhalt", "text": "Corollary nonhalt : ~ halts tm c0.", "decomposition": ["D_nonhalt"], "retrieval": ["with_counter", "skip_halts"], "remove_type": "abort"}, {"name": "D_nonhalt", "text": "Theorem D_nonhalt : forall m, ~ halts tm (D 0 m).", "decomposition": ["progress_nonhalt"], "retrieval": [], "remove_type": "abort"}, {"name": "N_strong_induction", "text": "Lemma N_strong_induction : forall (P : N -> Prop), (forall n, (forall k, (k < n)%N -> P k) -> P n) -> forall n, P n.", "decomposition": ["strong_induction"], "retrieval": [], "remove_type": "abort"}, {"name": "prepare_K", "text": "Lemma prepare_K : forall (n : N), (n > 0)%N -> exists (k : nat) (n' : N), K n = Lk (bin_min k) (K n' << 0 << 1 << 0 << 0) /\\ (n = pow2 k + pow2 (S k) * n')%N.", "decomposition": [], "retrieval": ["const_unfold"], "type": "both", "remove_type": "abort"}, {"name": "drop_KI", "text": "Lemma drop_KI : forall l m k a, (pow2 k - 1 <= b m)%N -> Lk (bin_min k) (l << 0 << 1 << 0 << 0) <{{C}} 1 >> 0 >> 1 >> a >> R m -->* l <{{C}} 1 >> 0 >> 1 >> 0 >> R (pow4 k (P (f m a k))).", "decomposition": [], "retrieval": ["eat_bin_max", "LaR_max"], "type": "both", "remove_type": "abort"}, {"name": "LaR_max", "text": "Corollary LaR_max : forall l k a m, (pow2 k - 1 <= b m)%N -> Lk (bin_min k) l <{{C}} 1 >> 0 >> 1 >> a >> R m -->* Lk (bin_max k) l <{{C}} 1 >> 0 >> 1 >> a >> R (pow2 k - 1 :+ m).", "decomposition": [], "retrieval": ["LaR_incs", "inc_to_max"], "type": "stmt", "remove_type": "abort"}, {"name": "inc_to_max", "text": "Lemma inc_to_max : forall k, bin_plus (pow2 k - 1) (bin_min k) (bin_max k).", "decomposition": ["pow2_S"], "retrieval": ["bin_plus_b0", "plus_S'", "pow2_gt0"], "type": "both", "remove_type": "abort"}, {"name": "pow2_gt0", "text": "Lemma pow2_gt0 : forall k, (pow2 k > 0)%N.", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "pow2_S", "text": "Lemma pow2_S : forall k, pow2 (S k) = N.double (pow2 k).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bin_plus_b0", "text": "Lemma bin_plus_b0 : forall k u (n n' : bin k), bin_plus u n n' -> bin_plus (N.double u) (b0 n) (b0 n').", "decomposition": [], "retrieval": [], "type": "both", "remove_type": "abort"}, {"name": "plus_S'", "text": "Lemma plus_S' : forall k u (n n' n'' : bin k), bin_plus u n n' -> n' -S-> n'' -> bin_plus (N.succ u) n n''.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "b0_succ", "text": "Lemma b0_succ : forall n, b n = 0%N -> b (P n) = (Npos n).", "decomposition": ["b0_all1"], "retrieval": [], "remove_type": "abort"}, {"name": "b_add_self", "text": "Corollary b_add_self : forall n, b (b n :+ n) = 0%N.", "decomposition": ["b_add"], "retrieval": [], "remove_type": "abort"}, {"name": "b_add", "text": "Lemma b_add : forall u n, (u <= b n -> b (u :+ n) = b n - u)%N.", "decomposition": ["b_succ", "het_add_succ_l"], "retrieval": [], "remove_type": "abort"}, {"name": "b_succ", "text": "Lemma b_succ : forall n, (b n > 0)%N -> b (P n) = N.pred (b n).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "bn0_has0", "text": "Lemma bn0_has0 : forall n, (b n > 0)%N -> has0 n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "b0_all1", "text": "Lemma b0_all1 : forall n, b n = N0 -> all1 n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pos_het_add", "text": "Lemma pos_het_add : forall a b, (N.pos (a :+ b) = a + N.pos b)%N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "het_add_succ_l", "text": "Lemma het_add_succ_l : forall a b, N.succ a :+ b = P (a :+ b).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "het_add_succ", "text": "Lemma het_add_succ : forall a b, N.succ a :+ b = a :+ P b.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "verify/Helper.v": [{"name": "strong_induction", "text": "Lemma strong_induction : forall (P : nat -> Prop), (forall n, (forall k, k < n -> P k) -> P n) -> forall n, P n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "9f05168506c13012372c01a53fefb2c7d788c77f": {}, "2d11a77fef4ec772dada5eb15b476f71b1fdcc57": {}, "2acfcef27f8e3e4ccf6b16d582bf59f147491139": {}, "a371f51ad4c0d50058f2a4785563d9cbf7871fdb": {"verify/Skelet1.v": [{"name": "lift_rxs", "text": "Lemma lift_rxs : forall n r, lift_right (rxs n r) = repeat (N.to_nat n) x :> lift_right r.", "decomposition": ["repeat_add"], "retrieval": [], "remove_type": "admit"}, {"name": "lift_lxs", "text": "Lemma lift_lxs : forall n l, lift_left (lxs n l) = lift_left l <: repeat (N.to_nat n) x.", "decomposition": ["repeat_add"], "retrieval": [], "remove_type": "admit"}, {"name": "decr_nat", "text": "Lemma decr_nat : forall n, N.to_nat (decr (Pos.of_succ_nat n)) = n.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "rule_P_xn", "text": "Lemma rule_P_xn : forall n l r, l |> P :> repeat n x :> r -->* l <: repeat n x |> P :> r.", "decomposition": ["repeat_shift", "rule_P_x"], "retrieval": [], "remove_type": "abort"}, {"name": "rule_xn_right", "text": "Lemma rule_xn_right : forall n l r, l |> repeat n x :> r -->* l <: repeat n x |> r.", "decomposition": ["repeat_shift"], "retrieval": [], "remove_type": "abort"}, {"name": "rule_xn_left", "text": "Lemma rule_xn_left : forall n l r, l <: repeat n x <| r -->* l <| repeat n x :> r.", "decomposition": ["repeat_shift"], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_DCx", "text": "Lemma rule_P_DCx : forall l r, l |> P :> Dr :> C :> x :> r -->* l <: G1 <: Dl |> P :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_DDx", "text": "Lemma rule_P_DDx : forall l r, l |> P :> Dr :> Dr :> x :> r -->* l <: C2 <: C1 <: Dl |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_DP", "text": "Lemma rule_P_DP : forall l r, l |> P :> Dr :> P :> r -->* l <: C1 <: Dl |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_Cx", "text": "Lemma rule_P_Cx : forall l r, l |> P :> C :> x :> r -->* l <| P :> Dr :> P :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_Dx", "text": "Lemma rule_P_Dx : forall l r, l |> P :> Dr :> x :> r -->* l <: C1 <: Dl |> P :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_R", "text": "Lemma rule_P_R : forall l, l |> P :> R -->* l <| C :> x :> R.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_x", "text": "Lemma rule_P_x : forall l r, l |> P :> x :> r -->* l <: x |> P :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_P", "text": "Lemma rule_P_P : forall l r, l |> P :> P :> r -->* l <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_P_left", "text": "Lemma rule_P_left : forall l r, l <: P <| r -->* l <| P :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_G2", "text": "Lemma rule_G2 : forall l r, l <: G2 <| r -->* l <: P <: Dl <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_G1", "text": "Lemma rule_G1 : forall l r, l <: G1 <| r -->* l <: G2 |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_G0", "text": "Lemma rule_G0 : forall l r, l <: G0 <| r -->* l <: G1 <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_C03", "text": "Lemma rule_C03 : forall l r, l <: C0 |> C :> r -->* l <: G0 |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_F3", "text": "Lemma rule_F3 : forall l r, l <: x <: F3 <| r -->* l <: P <: C1 <: Dl |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_F2", "text": "Lemma rule_F2 : forall l r, l <: F2 <| r -->* l <: F3 <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_F1", "text": "Lemma rule_F1 : forall l r, l <: F1 <| r -->* l <: F2 |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_F0", "text": "Lemma rule_F0 : forall l r, l <: F0 <| r -->* l <: F1 <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_C20", "text": "Lemma rule_C20 : forall l r, l <: C2 |> C :> r -->* l <: F0 |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_DC", "text": "Lemma rule_DC : forall l r, l <: Dl |> C :> r -->* l <: P <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_C23", "text": "Lemma rule_C23 : forall l r, l <: C2 <| r -->* l <: C <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_C12", "text": "Lemma rule_C12 : forall l r, l <: C1 <| r -->* l <: C2 |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_C01", "text": "Lemma rule_C01 : forall l r, l <: C0 <| r -->* l <: C1 <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_C30", "text": "Lemma rule_C30 : forall l r, l <: x |> C :> r -->* l <: C0 |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_L", "text": "Lemma rule_L : forall r, L <| C :> x :> r -->* L <: C1 <: Dl |> P :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_R", "text": "Lemma rule_R : forall l, l |> R -->* l <| R.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_D_right", "text": "Lemma rule_D_right : forall l r, l |> Dr :> r -->* l <: Dl |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_x_right", "text": "Lemma rule_x_right : forall l r, l |> x :> r -->* l <: x |> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_C_left", "text": "Lemma rule_C_left : forall l r, l <: C <| r -->* l <| C :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_D_left", "text": "Lemma rule_D_left : forall l r, l <: Dl <| r -->* l <| Dr :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "rule_x_left", "text": "Lemma rule_x_left : forall l r, l <: x <| r -->* l <| x :> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "repeat_add", "text": "Lemma repeat_add : forall A n m f (a : A), repeat (n + m) f a = repeat n f (repeat m f a).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "repeat_shift", "text": "Lemma repeat_shift : forall A n f (a : A), f (repeat n f a) = repeat n f (f a).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "d5e9f9dabc65298bde7442b9ba0cd4eca44f049e": {}, "1d15941b0452b2ea2c12a1fa697e6d796575fe68": {}, "9f5c43f7b1bf25bcb744274c7e1a9798beec9276": {}, "30eb3953dd63cdeeb8c0f764f3240d7fad90a8f8": {}, "ba49113f7d6a44353b29cf365cd37f0a6ae8fb77": {}, "2d403b937494430ee346ab61ebdb8024621757bd": {}, "4bc5227cc2a4b0ad4ec353e3f34bb6ec33721eb2": {}, "6c627a2768a027b47a9dc26d52fa4718bce32e74": {"verify/Skelet1.v": [{"name": "is_cycling_spec", "text": "Theorem is_cycling_spec : forall c, is_cycling c = true -> ~ halts tm (lift c).", "decomposition": ["cycle_nonhalt", "eqb_rtape_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "cycle_nonhalt", "text": "Lemma cycle_nonhalt : forall l, ~ halts tm (lift (right, l_C0 :: l, K)).", "decomposition": [], "retrieval": ["progress_nonhalt"], "remove_type": "abort"}, {"name": "eqb_rtape_spec", "text": "Lemma eqb_rtape_spec : forall xs ys, reflect (xs = ys) (eqb_rtape xs ys).", "decomposition": ["eqb_r_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "uni_cycle_count_spec", "text": "Lemma uni_cycle_count_spec : forall xs r, (uni_cycle_count xs r * N.pos uni_P < N.pos xs)%N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "strip_prefix_spec", "text": "Lemma strip_prefix_spec : forall xs ys zs, strip_prefix xs ys = Some zs -> ys = xs ++ zs.", "decomposition": ["eqb_l_spec"], "retrieval": [], "remove_type": "abort"}, {"name": "uni_cycles", "text": "Corollary uni_cycles : forall n l r r' xs, stride 0 (n * uni_T) r = Some r' -> lift (right, l_D :: l_C1 :: l_xs (xs :+ (n * uni_P + 1)) :: J ++ l, r) -->* lift (right, l_D :: l_C1 :: l_xs (xs :+ 1) :: J ++ Fls (N.pos n) l, Grs (N.pos n) r').", "decomposition": ["het_add_assoc", "Fls_Fls", "Grs_Grs", "stride_Grs", "uni_cycle'"], "retrieval": ["stride_add"], "remove_type": "abort"}, {"name": "het_add_assoc", "text": "Lemma het_add_assoc : forall a b c, (a + N.pos b) :+ c = a :+ (b + c).", "decomposition": [], "retrieval": ["pos_het_add"], "remove_type": "abort"}, {"name": "uni_cycle'", "text": "Corollary uni_cycle' : forall l r r' xs, stride 0 uni_T r = Some r' -> lift (right, l_D :: l_C1 :: l_xs (xs :+ (uni_P + 1)) :: J ++ l, r) -->* lift (right, l_D :: l_C1 :: l_xs (xs :+ 1) :: J ++ Fls 1 l, Grs 1 r').", "decomposition": ["lift_Fls", "lift_Grs"], "retrieval": ["lift_left", "lift_right"], "remove_type": "abort"}, {"name": "stride_correct'", "text": "Theorem stride_correct' : forall k t t' xs l, stride_level t = k -> stride xs 1 t = Some t' -> l <: repeat (N.to_nat xs) x |> lift_right t -->* l <| lift_right t'.", "decomposition": ["rule_Gn_right", "rule_Gn_left"], "retrieval": ["rule_x_left", "rule_C12", "rule_xn_left", "repeat_add", "rule_D_left", "rule_C_left", "stride_add", "rule_x_right", "lift_right", "rule_C01", "rule_D_right", "stride_same_level", "rule_C30", "rule_C23", "rule_P_R", "rule_xn_right"], "type": "proof", "remove_type": "abort"}, {"name": "stride_same_level", "text": "Lemma stride_same_level : forall t t' xs n, stride xs n t = Some t' -> stride_level t = stride_level t'.", "decomposition": ["stride_level_Grs"], "retrieval": ["stride_level_rxs"], "type": "proof", "remove_type": "abort"}, {"name": "stride_level_Grs", "text": "Lemma stride_level_Grs : forall xs t, stride_level (Grs xs t) = stride_level t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stride_add", "text": "Lemma stride_add : forall t t2 xs n m, stride xs (n + m) t = Some t2 -> exists t1, stride xs n t = Some t1 /\\ stride 0 m t1 = Some t2.", "decomposition": ["stride_Grs"], "retrieval": ["rxs_rxs", "stride_more", "stride_rxs"], "type": "proof", "remove_type": "abort"}, {"name": "stride_Grs", "text": "Lemma stride_Grs : forall t t' xs gs n, stride 0 n t = Some t' -> stride xs n (Grs gs t) = Some (rxs xs (Grs gs t')).", "decomposition": ["Grs_Grs"], "retrieval": ["stride_more"], "remove_type": "abort"}, {"name": "stride_more", "text": "Lemma stride_more : forall t t' xs xs' n, stride xs' n t = Some t' -> stride (xs + xs') n t = Some (rxs xs t').", "decomposition": [], "retrieval": ["rxs_rxs"], "type": "proof", "remove_type": "abort"}, {"name": "stride'_spec", "text": "Lemma stride'_spec : forall t xs n k, stride' xs n t k = option_map k (stride xs n t).", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}, {"name": "Grs_Grs", "text": "Lemma Grs_Grs : forall n m t, Grs n (Grs m t) = Grs (n + m) t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "Fls_Fls", "text": "Lemma Fls_Fls : forall n m t, Fls n (Fls m t) = Fls (n + m) t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "unrxs_spec", "text": "Lemma unrxs_spec : forall r r', unrxs r = Some r' -> lift_right r = x :> lift_right r'.", "decomposition": ["lift_Grs"], "retrieval": ["lift_right"], "remove_type": "admit"}, {"name": "lift_Hls", "text": "Lemma lift_Hls : forall n l, lift_left (Hls n l) = lift_left l <: repeat (N.to_nat n) Hl.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "lift_Grs", "text": "Lemma lift_Grs : forall n r, lift_right (Grs n r) = repeat (N.to_nat n) Gr :> lift_right r.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "lift_Gls", "text": "Lemma lift_Gls : forall n l, lift_left (Gls n l) = lift_left l <: repeat (N.to_nat n) Gl.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "lift_Fls", "text": "Lemma lift_Fls : forall n l, lift_left (Fls n l) = lift_left l <: repeat (N.to_nat n) Fl.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "lift_rxs", "text": "Lemma lift_rxs : forall n r, lift_right (rxs n r) = repeat (N.to_nat n) x :> lift_right r.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "admit"}, {"name": "lift_lxs", "text": "Lemma lift_lxs : forall n l, lift_left (lxs n l) = lift_left l <: repeat (N.to_nat n) x.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "admit"}, {"name": "eqb_r_spec", "text": "Lemma eqb_r_spec : forall a b, reflect (a = b) (eqb_r a b).", "decomposition": [], "retrieval": ["eqb_spec"], "remove_type": "abort"}, {"name": "eqb_l_spec", "text": "Lemma eqb_l_spec : forall a b, reflect (a = b) (eqb_l a b).", "decomposition": [], "retrieval": ["eqb_spec"], "remove_type": "abort"}, {"name": "rule_Gn_left", "text": "Lemma rule_Gn_left : forall n l r, l <: repeat n Gl <| r -->* l <| repeat n Gr :> r.", "decomposition": ["rule_G_left"], "retrieval": ["repeat_shift"], "remove_type": "abort"}, {"name": "rule_G_left", "text": "Lemma rule_G_left : forall l r, l <: Gl <| r -->* l <| Gr :> r.", "decomposition": [], "retrieval": ["rule_xn_left", "rule_D_left"], "remove_type": "abort"}, {"name": "rule_Gn_right", "text": "Lemma rule_Gn_right : forall n l r, l |> repeat n Gr :> r -->* l <: repeat n Gl |> r.", "decomposition": ["rule_G_right"], "retrieval": ["repeat_shift"], "remove_type": "abort"}, {"name": "rule_G_right", "text": "Lemma rule_G_right : forall l r, l |> Gr :> r -->* l <: Gl |> r.", "decomposition": [], "retrieval": ["rule_D_right", "rule_xn_right"], "remove_type": "abort"}, {"name": "rule_P_DGn", "text": "Lemma rule_P_DGn : forall n l r, l |> P :> Dr :> repeat n Gr :> r -->* l <: repeat n Hl |> P :> Dr :> r.", "decomposition": ["rule_P_DG"], "retrieval": ["repeat_shift"], "remove_type": "abort"}, {"name": "rule_P_DG", "text": "Lemma rule_P_DG : forall l r, l |> P :> Dr :> Gr :> r -->* l <: Hl |> P :> Dr :> r.", "decomposition": ["repeat_S"], "retrieval": ["rule_P_xn", "rule_P_Dx"], "remove_type": "abort"}, {"name": "repeat_S", "text": "Lemma repeat_S : forall {A} n f (a : A), repeat (S n) f a = f (repeat n f a).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "2486d362f6d534a279cddef304d8b040a39f628f": {}, "83bc6322e5876b21f10bfc7c1e7a3f4f9b94a3c0": {}, "428ca5a8be8e48f99a856114f2f3a6bbfd3bc895": {}, "f4419e2cdf6f0de774b5db31edc51a23a6c17ca7": {}, "36ee921ae57397e2e44e82ec5b86ee4a07188dc8": {}, "87883994aa7e62c42b6a04e9c70a5cd804a19d44": {}, "f2c159cd318db5b29087a1ec7a9a8e218d36ef82": {}, "010f290db4f152a3050e1259a9f3b2fac5d6815a": {}, "22e50e786fcfb9a52625506b9f7bf5fcc96913ac": {}, "149b02f658acde0532e270c59a1eca75eb756740": {}, "7bb7c754e8b601020dd60c621b60836d90717e14": {"verify/Skelet33.v": [{"name": "nonhalt", "text": "Theorem nonhalt : ~ halts tm c0.", "decomposition": [], "retrieval": ["multistep_nonhalt", "progress_nonhalt"], "remove_type": "abort"}, {"name": "all1_P_pow2", "text": "Lemma all1_P_pow2 : forall n, all1 n -> exists k, (P n = pow2' k)%N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "n0_1_2", "text": "Lemma n0_1_2 : forall n, (n = 0)%N \\/ (n = 1)%N \\/ (n > 1)%N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leads_3_pow2", "text": "Lemma leads_3_pow2 : forall q r, (r < pow2 q)%N -> leads (3 * pow2 q + r).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leads_pow2_sub1", "text": "Lemma leads_pow2_sub1 : forall k n, leads n -> leads (pow2 k * (n + 1) - 1).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leads_add1_rev", "text": "Lemma leads_add1_rev : forall n, (n > 0)%N -> leads (2 * n + 1) -> leads n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "leads_pow2_rev", "text": "Lemma leads_pow2_rev : forall k n, leads (pow2 k * n) -> leads n.", "decomposition": ["leads_add0_rev"], "retrieval": [], "remove_type": "abort"}, {"name": "leads_add0_rev", "text": "Lemma leads_add0_rev : forall n, leads (2 * n) -> leads n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "not_leads_2", "text": "Lemma not_leads_2 : ~ leads 2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pow2_add", "text": "Lemma pow2_add : forall n m, (pow2 (n + m) = pow2 n * pow2 m)%N.", "decomposition": [], "retrieval": ["pow2_S"], "remove_type": "abort"}, {"name": "b_pow2", "text": "Lemma b_pow2 : forall k, (b (pow2' k) = pow2 k - 1)%N.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "b_pow4_f", "text": "Lemma b_pow4_f : forall m k k', (b (pow4 k (f m k')~1) > 0)%N.", "decomposition": [], "retrieval": ["b_pow4"], "remove_type": "abort"}, {"name": "b_pow4", "text": "Lemma b_pow4 : forall k n, (b (pow4 k n) = pow2 (2 * k) * (b n + 1) - 1)%N.", "decomposition": [], "retrieval": ["pow4_shift"], "remove_type": "abort"}, {"name": "pow4_shift", "text": "Lemma pow4_shift : forall k n, (pow4 k n~0~0 = (pow4 k n)~0~0)%positive.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "prepare_K", "text": "Lemma prepare_K : forall (n : N), (n > 1)%N -> exists (k : nat) (n' : N), K n = Lk (bin_min k) (K n' << 0 << 1 << 0 << 0) /\\ (n = pow2 k + pow2 (S k) * n')%N.", "decomposition": [], "retrieval": ["const_unfold"], "remove_type": "abort"}, {"name": "drop_KI", "text": "Lemma drop_KI : forall l m k, (2 * (pow2 k - 1) <= b m)%N -> Lk (bin_min k) (l << 0 << 1 << 0 << 0) <{{C}} 1 >> 0 >> 1 >> 0 >> R m -->* l <{{C}} 1 >> 0 >> 1 >> 0 >> R (P (pow4 k (f m k)~1)).", "decomposition": [], "retrieval": ["eat_bin_max", "has0_f", "LaR_max"], "remove_type": "abort"}, {"name": "has0_f", "text": "Lemma has0_f : forall m k, has0 (f m k).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "eat_bin_max", "text": "Lemma eat_bin_max : forall k l t, has0 t -> has0 (P t) -> Lk (bin_max k) (l << 0 << 1 << 0 << 0) <{{C}} R t -->* l <{{C}} 1 >> 0 >> 1 >> 0 >> R (P (pow4 k (P t))).", "decomposition": [], "retrieval": ["eat_LI", "eat_KI"], "remove_type": "abort"}, {"name": "LaR_max", "text": "Corollary LaR_max : forall l k m, (2 * (pow2 k - 1) <= b m)%N -> Lk (bin_min k) l <{{C}} 1 >> 0 >> 1 >> 0 >> R m -->* Lk (bin_max k) l <{{C}} 1 >> 0 >> 1 >> 0 >> R (2 * (pow2 k - 1) :+ m).", "decomposition": [], "retrieval": ["LaR_incs", "inc_to_max"], "remove_type": "abort"}, {"name": "LaR_incs", "text": "Lemma LaR_incs : forall l k u (n n' : bin k) m, bin_plus u n n' -> (2 * u <= b m)%N -> Lk n l <{{C}} 1 >> 0 >> 1 >> 0 >> R m -->* Lk n' l <{{C}} 1 >> 0 >> 1 >> 0 >> R (2 * u :+ m).", "decomposition": [], "retrieval": ["LaR_inc", "b_succ", "bgt0_has0"], "remove_type": "abort"}, {"name": "LaR_inc", "text": "Lemma LaR_inc : forall l k (n n' : bin k) m, has0 m -> has0 (P m) -> n -S-> n' -> Lk n l <{{C}} 1 >> 0 >> 1 >> 0 >> R m -->* Lk n' l <{{C}} 1 >> 0 >> 1 >> 0 >> R (P (P m)).", "decomposition": [], "retrieval": ["R_inc_has0"], "remove_type": "abort"}, {"name": "eat_KI", "text": "Lemma eat_KI : forall l t, has0 t -> has0 (P t) -> l << 0 << 1 << 0 << 0 <{{C}} R t -->* l <{{C}} R (P (P t))~0~0.", "decomposition": [], "retrieval": ["R_inc_has0"], "remove_type": "abort"}, {"name": "eat_LI", "text": "Lemma eat_LI : forall l t, l << 1 << 0 << 0 << 0 <{{C}} R t -->* l <{{C}} R (t~1~1).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "L_as_K", "text": "Lemma L_as_K : forall n, L n = K n << 0.", "decomposition": [], "retrieval": ["const_unfold"], "remove_type": "abort"}, {"name": "R_inc_all1", "text": "Lemma R_inc_all1 : forall n l, all1 n -> l << 1 {{E}}> R n -->* l <{{C}} R (P n).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "R_inc_has0", "text": "Lemma R_inc_has0 : forall n l, has0 n -> l << 1 {{E}}> R n -->* l <{{A}} 0 >> R (P n).", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "7e8130131854290b842128897860437499aa7c47": {}, "efddfcb08e30b9260b5b6a03ae328817ef6e49e4": {}, "8550d7db7ef88e90330e6fb66bd1d98275438f89": {}, "41b3abe4822fb5792390777b398703ba06288f60": {}, "7f49d9eff3213f323feb546c3c2bd0d0302ffc87": {}, "095c22b0a28a8f9b24f45aa08b2e31d1364063de": {}, "6acc00e3d8ae032053906ec75feaabd53de42535": {}, "3882efa37f78f5ec70b45caf5cf9277aa389b888": {}, "eb3d723a7fc427958b704f389d4448bd84809baf": {}, "6bff99da50cfa8a8263cd02c31228a14b96cca26": {}, "979611edb7364ed99de1d160f69611620c6f7d8c": {"verify/ShiftOverflowBins.v": [{"name": "L_as_K", "text": "Lemma L_as_K : forall n, L n = K n << 0.", "decomposition": [], "retrieval": ["const_unfold"], "remove_type": "abort"}], "verify/Skelet26.v": [{"name": "prepare_J", "text": "Lemma prepare_J : forall (n : N) (k : nat) (n' : N), (n = pow2 k + pow2 (S k) * n')%N -> J n = Lk (bin_min k) (J n' << 0 << 0 << 0 << 1).", "decomposition": [], "retrieval": ["const_unfold"], "remove_type": "abort"}, {"name": "prepare_K", "text": "Lemma prepare_K : forall (n : N), (n > 0)%N -> exists (k : nat) (n' : N), K n = Lk (bin_min k) (K n' << 0 << 1 << 0 << 0) /\\ (n = pow2 k + pow2 (S k) * n')%N.", "decomposition": [], "retrieval": ["const_unfold"], "remove_type": "abort"}, {"name": "drop_JI", "text": "Lemma drop_JI : forall l m k a, (pow2 k - 1 <= b m)%N -> Lk (bin_min k) (l << 0 << 1) <{{D}} 1 >> 0 >> 1 >> a >> R m -->* l <{{D}} 1 >> 0 >> R (pow4 k (P (f m a k))).", "decomposition": [], "retrieval": ["eat_bin_max1", "LaR_max"], "remove_type": "abort"}, {"name": "drop_KI", "text": "Lemma drop_KI : forall l m k a, (pow2 k - 1 <= b m)%N -> Lk (bin_min k) (l << 0 << 1 << 0 << 0) <{{D}} 1 >> 0 >> 1 >> a >> R m -->* l <{{D}} 1 >> 0 >> 1 >> 1 >> R (pow4 k (P (f m a k))).", "decomposition": [], "retrieval": ["LaR_max", "eat_bin_max0"], "remove_type": "abort"}, {"name": "eat_bin_max1", "text": "Lemma eat_bin_max1 : forall k l t, has0 t -> Lk (bin_max k) (l << 0 << 1) <{{D}} R t -->* l <{{D}} 1 >> 0 >> R (pow4 k (P t)).", "decomposition": ["eat_JI"], "retrieval": ["eat_LI"], "type": "proof", "remove_type": "abort"}, {"name": "eat_bin_max0", "text": "Lemma eat_bin_max0 : forall k l t, has0 t -> Lk (bin_max k) (l << 0 << 1 << 0 << 0) <{{D}} R t -->* l <{{D}} 1 >> 0 >> 1 >> 1 >> R (pow4 k (P t)).", "decomposition": [], "retrieval": ["eat_LI", "eat_KI"], "type": "proof", "remove_type": "abort"}, {"name": "eat_JI", "text": "Lemma eat_JI : forall l t, has0 t -> l << 0 << 1 <{{D}} R t -->* l <{{D}} R (P t)~0.", "decomposition": [], "retrieval": ["R_inc_has0"], "remove_type": "abort"}, {"name": "eat_KI", "text": "Lemma eat_KI : forall l t, has0 t -> l << 0 << 1 << 0 << 0 <{{D}} R t -->* l <{{D}} R (P t)~1~0.", "decomposition": [], "retrieval": ["R_inc_has0"], "remove_type": "abort"}, {"name": "K_as_J", "text": "Lemma K_as_J : forall n, K n = J n << 0 << 0.", "decomposition": [], "retrieval": ["const_unfold"], "remove_type": "abort"}, {"name": "L_as_J", "text": "Lemma L_as_J : forall n, L n = J n << 0 << 0 << 0.", "decomposition": [], "retrieval": ["const_unfold"], "remove_type": "abort"}], "verify/Individual.v": [{"name": "lpow_S", "text": "Lemma lpow_S : forall {A} n (xs : list A), xs^^(S n) = xs +> xs^^n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lpow_shift'", "text": "Lemma lpow_shift' : forall A n (xs : list A) ys, xs^^n *> xs *> ys = xs *> xs^^n *> ys.", "decomposition": ["lpow_shift", "Str_app_assoc"], "retrieval": [], "remove_type": "admit"}], "verify/Skelet34.v": [{"name": "prepare_K", "text": "Lemma prepare_K : forall (n : N), (n > 0)%N -> exists (k : nat) (n' : N), K n = K n' <* <[0; 1; 0; 0] <* Lk (bin_min k) /\\ (n = pow2 k + pow2 (S k) * n')%N.", "decomposition": [], "retrieval": ["const_unfold"], "type": "stmt", "remove_type": "abort"}, {"name": "drop_KI", "text": "Lemma drop_KI : forall l m k a, (pow2 k - 1 <= b m)%N -> l <* <[0; 1; 0; 0] <* Lk (bin_min k) <{{C}} [1; 0; 1; a] *> R m -->* l <{{C}} [1; 0; 1; 0] *> R (pow4 k (P (f m a k))).", "decomposition": [], "retrieval": ["eat_bin_max", "LaR_max"], "type": "both", "remove_type": "abort"}, {"name": "eat_bin_max", "text": "Lemma eat_bin_max : forall k l t, has0 t -> l <* <[0; 1; 0; 0] <* Lk (bin_max k) <{{C}} R t -->* l <{{C}} [1; 0; 1; 0] *> R (pow4 k (P t)).", "decomposition": [], "retrieval": ["eat_LI", "eat_KI"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_max", "text": "Corollary LaR_max : forall l k a m, (pow2 k - 1 <= b m)%N -> l <* Lk (bin_min k) <{{C}} [1; 0; 1; a] *> R m -->* l <* Lk (bin_max k) <{{C}} [1; 0; 1; a] *> R (pow2 k - 1 :+ m).", "decomposition": [], "retrieval": ["LaR_incs", "inc_to_max"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_incs", "text": "Lemma LaR_incs : forall l k u (n n' : bin k) a m, bin_plus u n n' -> (u <= b m)%N -> l <* Lk n <{{C}} [1; 0; 1; a] *> R m -->* l <* Lk n' <{{C}} [1; 0; 1; a] *> R (u :+ m).", "decomposition": [], "retrieval": ["LaR_inc", "b_succ"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_inc", "text": "Lemma LaR_inc : forall l k (n n' : bin k) a m, has0 m -> n -S-> n' -> l <* Lk n <{{C}} [1; 0; 1; a] *> R m -->* l <* Lk n' <{{C}} [1; 0; 1; a] *> R (P m).", "decomposition": ["Lk_inc"], "retrieval": ["R_inc_has0"], "type": "stmt", "remove_type": "abort"}, {"name": "Lk_inc", "text": "Lemma Lk_inc : forall k (n n' : bin k), n -S-> n' -> forall l r, l <* Lk n <{{C}} r -->* l <* Lk n' {{B}}> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eat_KI", "text": "Lemma eat_KI : forall l t, has0 t -> l <* <[0; 1; 0; 0] <{{C}} R t -->* l <{{C}} R (4 * P t).", "decomposition": [], "retrieval": ["R_inc_has0"], "type": "stmt", "remove_type": "abort"}, {"name": "eat_LI", "text": "Lemma eat_LI : forall l t, l <* <[1; 0; 0; 0] <{{C}} R t -->* l <{{C}} R (t~1~1).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}], "verify/Skelet33.v": [{"name": "prepare_K", "text": "Lemma prepare_K : forall (n : positive), exists (k : nat) (n' : N), K' n = K n' <* <[0; 1; 0; 0] <* Lk (bin_min k) /\\ n = pow2 (S k) * n' :+ pow2' k.", "decomposition": [], "retrieval": ["const_unfold"], "type": "stmt", "remove_type": "abort"}, {"name": "drop_KI", "text": "Lemma drop_KI : forall l m k, (2 * (pow2 k - 1) <= b m)%N -> l <* <[0; 1; 0; 0] <* Lk (bin_min k) <{{C}} [1; 0; 1; 0] *> R m -->* l <{{C}} [1; 0; 1; 0] *> R (P (pow4 k (f m k)~1)).", "decomposition": [], "retrieval": ["eat_bin_max", "LaR_max"], "type": "both", "remove_type": "abort"}, {"name": "eat_bin_max", "text": "Lemma eat_bin_max : forall k l t, has0 t -> has0 (P t) -> l <* <[0; 1; 0; 0] <* Lk (bin_max k) <{{C}} R t -->* l <{{C}} [1; 0; 1; 0] *> R (P (pow4 k (P t))).", "decomposition": [], "retrieval": ["eat_LI", "eat_KI"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_max", "text": "Corollary LaR_max : forall l k m, (2 * (pow2 k - 1) <= b m)%N -> l <* Lk (bin_min k) <{{C}} [1; 0; 1; 0] *> R m -->* l <* Lk (bin_max k) <{{C}} [1; 0; 1; 0] *> R (2 * (pow2 k - 1) :+ m).", "decomposition": [], "retrieval": ["LaR_incs", "inc_to_max"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_incs", "text": "Lemma LaR_incs : forall l k u (n n' : bin k) m, bin_plus u n n' -> (2 * u <= b m)%N -> l <* Lk n <{{C}} [1; 0; 1; 0] *> R m -->* l <* Lk n' <{{C}} [1; 0; 1; 0] *> R (2 * u :+ m).", "decomposition": [], "retrieval": ["LaR_inc", "b_succ", "bgt0_has0"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_inc", "text": "Lemma LaR_inc : forall l k (n n' : bin k) m, has0 m -> has0 (P m) -> n -S-> n' -> l <* Lk n <{{C}} [1; 0; 1; 0] *> R m -->* l <* Lk n' <{{C}} [1; 0; 1; 0] *> R (P (P m)).", "decomposition": ["Lk_inc"], "retrieval": ["R_inc_has0"], "type": "stmt", "remove_type": "abort"}, {"name": "Lk_inc", "text": "Lemma Lk_inc : forall k (n n' : bin k), n -S-> n' -> forall l r, l <* Lk n <{{C}} r -->* l <* Lk n' {{B}}> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eat_KI", "text": "Lemma eat_KI : forall l t, has0 t -> has0 (P t) -> l <* <[0; 1; 0; 0] <{{C}} R t -->* l <{{C}} R (P (P t))~0~0.", "decomposition": [], "retrieval": ["R_inc_has0"], "type": "stmt", "remove_type": "abort"}, {"name": "eat_LI", "text": "Lemma eat_LI : forall l t, l <* <[1; 0; 0; 0] <{{C}} R t -->* l <{{C}} R (t~1~1).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}], "verify/Helper.v": [{"name": "Str_app_assoc", "text": "Lemma Str_app_assoc {A} (xs ys : list A) (zs : Stream A) : (xs ++ ys) *> zs = xs *> ys *> zs.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lpow_add", "text": "Lemma lpow_add : forall A n m (xs : list A), xs^^(n + m) = xs^^n ++ xs^^m.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "lpow_shift", "text": "Lemma lpow_shift : forall {A} (xs : list A) n, xs^^n ++ xs = xs ++ xs^^n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "verify/Skelet35.v": [{"name": "prepare_K", "text": "Lemma prepare_K : forall (n : N), (n > 0)%N -> exists (k : nat) (n' : N), K n = K n' <* <[0; 1; 0; 0] <* Lk (bin_min k) /\\ (n = pow2 k + pow2 (S k) * n')%N.", "decomposition": [], "retrieval": ["const_unfold"], "type": "stmt", "remove_type": "abort"}, {"name": "drop_KI", "text": "Lemma drop_KI : forall l m k a, (pow2 k - 1 <= b m)%N -> l <* <[0; 1; 0; 0] <* Lk (bin_min k) <{{C}} [1; 0; 1; a] *> R m -->* l <{{C}} [1; 0; 1; 0] *> R (pow4 k (P (f m a k))).", "decomposition": [], "retrieval": ["eat_bin_max", "LaR_max"], "type": "both", "remove_type": "abort"}, {"name": "eat_bin_max", "text": "Lemma eat_bin_max : forall k l t, has0 t -> l <* <[0; 1; 0; 0] <* Lk (bin_max k) <{{C}} R t -->* l <{{C}} [1; 0; 1; 0] *> R (pow4 k (P t)).", "decomposition": [], "retrieval": ["eat_LI", "eat_KI"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_max", "text": "Corollary LaR_max : forall l k a m, (pow2 k - 1 <= b m)%N -> l <* Lk (bin_min k) <{{C}} [1; 0; 1; a] *> R m -->* l <* Lk (bin_max k) <{{C}} [1; 0; 1; a] *> R (pow2 k - 1 :+ m).", "decomposition": [], "retrieval": ["LaR_incs", "inc_to_max"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_incs", "text": "Lemma LaR_incs : forall l k u (n n' : bin k) a m, bin_plus u n n' -> (u <= b m)%N -> l <* Lk n <{{C}} [1; 0; 1; a] *> R m -->* l <* Lk n' <{{C}} [1; 0; 1; a] *> R (u :+ m).", "decomposition": [], "retrieval": ["LaR_inc", "b_succ"], "type": "stmt", "remove_type": "abort"}, {"name": "LaR_inc", "text": "Lemma LaR_inc : forall l k (n n' : bin k) a m, has0 m -> n -S-> n' -> l <* Lk n <{{C}} [1; 0; 1; a] *> R m -->* l <* Lk n' <{{C}} [1; 0; 1; a] *> R (P m).", "decomposition": ["Lk_inc"], "retrieval": ["R_inc_has0"], "type": "stmt", "remove_type": "abort"}, {"name": "Lk_inc", "text": "Lemma Lk_inc : forall k (n n' : bin k), n -S-> n' -> forall l r, l <* Lk n <{{C}} r -->* l <* Lk n' {{B}}> r.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eat_KI", "text": "Lemma eat_KI : forall l t, has0 t -> l <* <[0; 1; 0; 0] <{{C}} R t -->* l <{{C}} R (4 * P t).", "decomposition": [], "retrieval": ["R_inc_has0"], "type": "stmt", "remove_type": "abort"}, {"name": "eat_LI", "text": "Lemma eat_LI : forall l t, l <* <[1; 0; 0; 0] <{{C}} R t -->* l <{{C}} R (t~1~1).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}], "verify/Skelet1.v": [{"name": "stride_correct", "text": "Corollary stride_correct : forall t t' xs l, stride xs 1 t = Some t' -> l <* x^^(N.to_nat xs) |> lift_right t -->* l <| lift_right t'.", "decomposition": [], "retrieval": ["stride_correct'"], "type": "stmt", "remove_type": "abort"}, {"name": "stride_correct'", "text": "Theorem stride_correct' : forall k t t' xs l, stride_level t = k -> stride xs 1 t = Some t' -> l <* x^^(N.to_nat xs) |> lift_right t -->* l <| lift_right t'.", "decomposition": ["Str_app_assoc", "lpow_add"], "retrieval": ["rule_x_right", "rule_C01", "rule_D_right", "stride_same_level", "rule_C30", "rule_xn_left", "rule_Gn_right", "rule_D_left", "stride_add", "rule_P_R", "rule_xn_right", "rule_x_left", "rule_C_left", "rule_C12", "lift_right", "rule_Gn_left", "rule_C23"], "type": "both", "remove_type": "abort"}, {"name": "stride_same_level", "text": "Lemma stride_same_level : forall t t' xs n, stride xs n t = Some t' -> stride_level t = stride_level t'.", "decomposition": [], "retrieval": ["stride_level_Grs", "stride_level_rxs"], "type": "proof", "remove_type": "abort"}, {"name": "stride_add", "text": "Lemma stride_add : forall t t2 xs n m, stride xs (n + m) t = Some t2 -> exists t1, stride xs n t = Some t1 /\\ stride 0 m t1 = Some t2.", "decomposition": [], "retrieval": ["stride_Grs", "rxs_rxs", "stride_more", "stride_rxs"], "type": "proof", "remove_type": "abort"}, {"name": "stride_more", "text": "Lemma stride_more : forall t t' xs xs' n, stride xs' n t = Some t' -> stride (xs + xs') n t = Some (rxs xs t').", "decomposition": [], "retrieval": ["rxs_rxs"], "type": "proof", "remove_type": "abort"}, {"name": "unrxs_spec", "text": "Lemma unrxs_spec : forall r r', unrxs r = Some r' -> lift_right r = x *> lift_right r'.", "decomposition": [], "retrieval": ["lift_right", "lift_Grs"], "type": "both", "remove_type": "admit"}, {"name": "lift_Hls", "text": "Lemma lift_Hls : forall n l, lift_left (Hls n l) = lift_left l <* Hl^^(N.to_nat n).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "admit"}, {"name": "lift_Grs", "text": "Lemma lift_Grs : forall n r, lift_right (Grs n r) = Gr^^(N.to_nat n) *> lift_right r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "admit"}, {"name": "lift_Gls", "text": "Lemma lift_Gls : forall n l, lift_left (Gls n l) = lift_left l <* Gl^^(N.to_nat n).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "admit"}, {"name": "lift_Fls", "text": "Lemma lift_Fls : forall n l, lift_left (Fls n l) = lift_left l <* Fl^^(N.to_nat n).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "admit"}, {"name": "lift_rxs", "text": "Lemma lift_rxs : forall n r, lift_right (rxs n r) = x^^(N.to_nat n) *> lift_right r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "admit"}, {"name": "lift_lxs", "text": "Lemma lift_lxs : forall n l, lift_left (lxs n l) = lift_left l <* x^^(N.to_nat n).", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "admit"}, {"name": "rule_Gn_left", "text": "Lemma rule_Gn_left : forall n l r, l <* Gl^^n <| r -->* l <| Gr^^n *> r.", "decomposition": [], "retrieval": ["rule_G_left"], "type": "both", "remove_type": "abort"}, {"name": "rule_G_left", "text": "Lemma rule_G_left : forall l r, l <* Gl <| r -->* l <| Gr *> r.", "decomposition": [], "retrieval": ["rule_xn_left", "rule_D_left"], "type": "both", "remove_type": "abort"}, {"name": "rule_Gn_right", "text": "Lemma rule_Gn_right : forall n l r, l |> Gr^^n *> r -->* l <* Gl^^n |> r.", "decomposition": [], "retrieval": ["rule_G_right"], "type": "both", "remove_type": "abort"}, {"name": "rule_G_right", "text": "Lemma rule_G_right : forall l r, l |> Gr *> r -->* l <* Gl |> r.", "decomposition": [], "retrieval": ["rule_D_right", "rule_xn_right"], "type": "both", "remove_type": "abort"}, {"name": "rule_P_DGn", "text": "Lemma rule_P_DGn : forall n l r, l |> P *> Dr *> Gr^^n *> r -->* l <* Hl^^n |> P *> Dr *> r.", "decomposition": [], "retrieval": ["rule_P_DG"], "type": "both", "remove_type": "abort"}, {"name": "rule_P_DG", "text": "Lemma rule_P_DG : forall l r, l |> P *> Dr *> Gr *> r -->* l <* Hl |> P *> Dr *> r.", "decomposition": ["lpow_S"], "retrieval": ["rule_P_xn", "rule_P_Dx"], "type": "both", "remove_type": "abort"}, {"name": "rule_P_xn", "text": "Lemma rule_P_xn : forall n l r, l |> P *> x^^n *> r -->* l <* x^^n |> P *> r.", "decomposition": [], "retrieval": ["rule_P_x"], "type": "both", "remove_type": "abort"}, {"name": "rule_xn_right", "text": "Lemma rule_xn_right : forall n l r, l |> x^^n *> r -->* l <* x^^n |> r.", "decomposition": [], "retrieval": ["rule_x_right"], "type": "both", "remove_type": "abort"}, {"name": "rule_xn_left", "text": "Lemma rule_xn_left : forall n l r, l <* x^^n <| r -->* l <| x^^n *> r.", "decomposition": [], "retrieval": ["rule_x_left"], "type": "both", "remove_type": "abort"}, {"name": "rule_P_DCx", "text": "Lemma rule_P_DCx : forall l r, l |> P *> Dr *> C *> x *> r -->* l <* G1 <* Dl |> P *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_DDx", "text": "Lemma rule_P_DDx : forall l r, l |> P *> Dr *> Dr *> x *> r -->* l <* C2 <* C1 <* Dl |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_DP", "text": "Lemma rule_P_DP : forall l r, l |> P *> Dr *> P *> r -->* l <* C1 <* Dl |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_Cx", "text": "Lemma rule_P_Cx : forall l r, l |> P *> C *> x *> r -->* l <| P *> Dr *> P *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_Dx", "text": "Lemma rule_P_Dx : forall l r, l |> P *> Dr *> x *> r -->* l <* C1 <* Dl |> P *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_R", "text": "Lemma rule_P_R : forall l, l |> P *> R -->* l <| P *> R.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_x", "text": "Lemma rule_P_x : forall l r, l |> P *> x *> r -->* l <* x |> P *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_P", "text": "Lemma rule_P_P : forall l r, l |> P *> P *> r -->* l <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_P_left", "text": "Lemma rule_P_left : forall l r, l <* P <| r -->* l <| P *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_G2", "text": "Lemma rule_G2 : forall l r, l <* G2 <| r -->* l <* P <* Dl <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_G1", "text": "Lemma rule_G1 : forall l r, l <* G1 <| r -->* l <* G2 |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_G0", "text": "Lemma rule_G0 : forall l r, l <* G0 <| r -->* l <* G1 <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_C03", "text": "Lemma rule_C03 : forall l r, l <* C0 |> C *> r -->* l <* G0 |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_F3", "text": "Lemma rule_F3 : forall l r, l <* x <* F3 <| r -->* l <* P <* C1 <* Dl |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_F2", "text": "Lemma rule_F2 : forall l r, l <* F2 <| r -->* l <* F3 <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_F1", "text": "Lemma rule_F1 : forall l r, l <* F1 <| r -->* l <* F2 |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_F0", "text": "Lemma rule_F0 : forall l r, l <* F0 <| r -->* l <* F1 <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_C2_C", "text": "Lemma rule_C2_C : forall l r, l <* C2 |> C *> r -->* l <* F0 |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_DC", "text": "Lemma rule_DC : forall l r, l <* Dl |> C *> r -->* l <* P <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_C23", "text": "Lemma rule_C23 : forall l r, l <* C2 <| r -->* l <* C <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_C12", "text": "Lemma rule_C12 : forall l r, l <* C1 <| r -->* l <* C2 |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_C01", "text": "Lemma rule_C01 : forall l r, l <* C0 <| r -->* l <* C1 <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_C30", "text": "Lemma rule_C30 : forall l r, l <* x |> C *> r -->* l <* C0 |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_L", "text": "Lemma rule_L : forall r, L <| C *> x *> r -->* L <* C1 <* Dl |> P *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_DR", "text": "Lemma rule_DR : forall l, l <* Dl |> R -->* l <| x *> R.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_xR", "text": "Lemma rule_xR : forall l, l <* x |> R -->* l <| C *> x *> P *> R.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_D_right", "text": "Lemma rule_D_right : forall l r, l |> Dr *> r -->* l <* Dl |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_x_right", "text": "Lemma rule_x_right : forall l r, l |> x *> r -->* l <* x |> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_C_left", "text": "Lemma rule_C_left : forall l r, l <* C <| r -->* l <| C *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_D_left", "text": "Lemma rule_D_left : forall l r, l <* Dl <| r -->* l <| Dr *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}, {"name": "rule_x_left", "text": "Lemma rule_x_left : forall l r, l <* x <| r -->* l <| x *> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}], "verify/Skelet10.v": [{"name": "incr_left", "text": "Lemma incr_left : forall n r, T n <{{D}} [1; 1] *> r -->* T (zI n) {{A}}> r.", "decomposition": [], "retrieval": [], "type": "stmt", "remove_type": "abort"}], "verify/TM.v": [{"name": "no_halted_step", "text": "Lemma no_halted_step : forall tm c, ~ halted tm c -> exists c', c -[ tm ]-> c'.", "decomposition": [], "retrieval": [], "type": "proof", "remove_type": "abort"}]}}