{"67e49e33419feee5ef1c29c809ccb7f2da3aa21a": {"theories/examples/while.v": [{"name": "WHILE_eq", "text": "Lemma WHILE_eq \u03b1 \u03b2 : WHILE \u03b1 \u03b2 \u2261 IF \u03b1 (SEQ \u03b2 (Tick (WHILE \u03b1 \u03b2))) (Ret ()).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/input_lang/logrel.v": [{"name": "adequacy", "text": "Theorem adequacy (e : expr []) (k : nat) \u03c3 \u03c3' n : typed empC e Tnat \u2192 ssteps (gReifiers_sReifier rs) (interp_expr rs e ()) (\u03c3,()) (Nat k) \u03c3' n \u2192 \u2203 mm \u03c3', prim_steps e \u03c3 (Val $ Lit k) \u03c3' mm.", "decomposition": [], "retrieval": ["logrel_nat_adequacy", "subst_expr_idsub", "subs_of_emp_subs2", "fundamental"], "remove_type": "abort"}, {"name": "logrel_nat_adequacy", "text": "Lemma logrel_nat_adequacy \u03a3 `{!invGpreS \u03a3}`{!statePreG rs natO \u03a3} {S} (\u03b1 : IT (gReifiers_ops rs) natO) (e : expr S) n \u03c3 \u03c3' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs natO \u03a3}, (True \u22a2 logrel rs Tnat \u03b1 e)%I) \u2192 ssteps (gReifiers_sReifier rs) \u03b1 (\u03c3,()) (Ret n) \u03c3' k \u2192 \u2203 m \u03c3', prim_steps e \u03c3 (Val $ Lit n) \u03c3' m.", "decomposition": ["IT_of_V_Ret"], "retrieval": ["wp_adequacy", "IT_ret_fun_ne", "wp_wand", "Ret_inj'"], "remove_type": "abort"}, {"name": "\u03ba_Ret", "text": "Lemma \u03ba_Ret {S} {E} n : \u03ba ((RetV n) : ITV E natO) = (Lit n : val S).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "compat_natop", "text": "Lemma compat_natop {S} (\u0393 : tyctx S) e1 e2 \u03b11 \u03b12 op : \u22a2 logrel_valid \u0393 e1 \u03b11 Tnat -\u2217 logrel_valid \u0393 e2 \u03b12 Tnat -\u2217 logrel_valid \u0393 (NatOp op e1 e2) (interp_natop rs op \u03b11 \u03b12) Tnat.", "decomposition": ["NATOP_Ret"], "retrieval": ["logrel_step_pure", "Ectx_step'", "logrel_bind", "logrel_of_val"], "remove_type": "abort"}], "theories/affine_lang/logrel2.v": [{"name": "logrel2_safety", "text": "Lemma logrel2_safety e \u03c4 (\u03b2 : IT (gReifiers_ops rs) R) st st' k : typed_glued empC e \u03c4 \u2192 ssteps (gReifiers_sReifier rs) (interp_expr rs e ()) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier rs) \u03b2 st' \u03b21 st1) \u2228 (\u03b2 \u2261 Err OtherError) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["logrel2_adequacy", "fundamental_affine_glued"], "remove_type": "abort"}, {"name": "logrel2_adequacy", "text": "Lemma logrel2_adequacy cr R `{!Cofe R, !SubOfe natO R, !SubOfe unitO R} \u03a3 `{!invGpreS \u03a3}`{!statePreG rs R \u03a3} `{!heapPreG rs R \u03a3} `{!na_invG \u03a3} \u03c4 (\u03b1 : unitO -n> IT (gReifiers_ops rs) R) (\u03b2 : IT (gReifiers_ops rs) R) st st' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs R \u03a3} `{H3: !heapG rs R \u03a3} p, (\u00a3 cr \u22a2 valid2 rs p empC \u03b1 \u03c4)%I) \u2192 ssteps (gReifiers_sReifier rs) (\u03b1 ()) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier rs) \u03b2 st' \u03b21 st1) \u2228 (\u03b2 \u2261 Err OtherError) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["IT_of_to_V'", "ssubst_valid_nil", "fupd_wp", "wp_safety", "new_heapG", "wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_to_affine_fun", "text": "Lemma compat_glue_to_affine_fun {S} (\u03a9 : tyctx S) (\u03c41 \u03c42 : ty) (\u03c41' \u03c42' : io_lang.ty) \u03b1 (glue_to_affine glue_from_affine : IT -n> IT) : (\u2200 \u03b1, io_valid empC \u03b1 \u03c42' \u22a2 valid2 \u03a9 (constO (glue_to_affine (\u03b1 ()))) \u03c42) \u2192 (\u2200 \u03b1, valid2 empC (constO \u03b1) \u03c41 \u22a2 heap_ctx -\u2217 io_valid empC (constO (glue_from_affine \u03b1)) \u03c41') \u2192 io_valid empC \u03b1 (Tarr (Tarr Tnat \u03c41') \u03c42') \u22a2 valid2 \u03a9 (constO (glue_to_affine_fun _ glue_from_affine glue_to_affine (\u03b1 ()))) (tArr \u03c41 \u03c42).", "decomposition": ["IF_True", "IF_False"], "retrieval": ["wp_seq", "wp_write", "wp_read_atomic", "ssubst_valid_nil", "wp_val", "wp_Thunk", "fupd_wp", "wp_lam", "wp_bind", "wp_write_atomic", "wp_err", "expr_pred_ret", "wp_let", "wp_read", "wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_from_affine_fun", "text": "Lemma compat_glue_from_affine_fun (\u03c41 \u03c42 : ty) (\u03c41' \u03c42' : io_lang.ty) \u03b1 (glue_to_affine glue_from_affine : IT -n> IT) : (\u2200 \u03b1, io_valid empC \u03b1 \u03c41' \u22a2 valid2 empC (constO (glue_to_affine (\u03b1 ()))) \u03c41) \u2192 (\u2200 \u03b1, valid2 empC (constO \u03b1) \u03c42 \u22a2 heap_ctx -\u2217 io_valid empC (constO (glue_from_affine \u03b1)) \u03c42') \u2192 valid2 empC (constO \u03b1) (tArr \u03c41 \u03c42) \u22a2 heap_ctx -\u2217 io_valid empC (constO (glue_from_affine_fun _ glue_from_affine glue_to_affine \u03b1)) (Tarr (Tarr Tnat \u03c41') \u03c42').", "decomposition": ["IF_True", "IF_False"], "retrieval": ["wp_seq", "wp_write", "wp_val", "ssubst_valid_nil", "wp_Thunk", "fupd_wp", "wp_err", "wp_bind", "wp_read", "wp_let", "expr_pred_ret", "wp_lam", "wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_from_affine_unit", "text": "Lemma compat_glue_from_affine_unit \u03b1 : valid2 empC \u03b1 tUnit \u22a2 heap_ctx -\u2217 io_valid empC (constO (glue_from_affine _ ty_conv_unit (\u03b1 ()))) Tnat.", "decomposition": [], "retrieval": ["wp_val", "ssubst_valid_nil", "wp_wand"], "remove_type": "abort"}], "theories/examples/factorial.v": [{"name": "wp_fact_imp", "text": "Lemma wp_fact_imp (n : nat) : heap_ctx \u22a2 WP@{rs} fact_imp \u2299 (Ret n) {{ \u03b2v, \u03b2v \u2261 RetV (fact n) }}.", "decomposition": [], "retrieval": ["wp_seq", "wp_val", "wp_fact_imp_bod", "wp_read", "wp_alloc", "get_ret_ret", "wp_lam", "wp_wand"], "remove_type": "abort"}, {"name": "wp_fact_imp_bod", "text": "Lemma wp_fact_imp_bod n m acc \u2113 : heap_ctx -\u2217 pointsto acc (Ret m) -\u2217 pointsto \u2113 (Ret n) -\u2217 WP@{rs} fact_imp_body acc \u2113 {{ _, pointsto acc (Ret (m * fact n)) }}.", "decomposition": ["IF_False", "IF_True", "IT_of_V_Ret", "NATOP_Ret"], "retrieval": ["wp_seq", "wp_write", "wp_val", "wp_bind", "wp_let", "WHILE_eq", "wp_read", "wp_wand"], "remove_type": "abort"}], "theories/input_lang/logpred.v": [{"name": "io_lang_safety", "text": "Lemma io_lang_safety e \u03c4 \u03c3 st' (\u03b2 : IT (sReifier_ops (gReifiers_sReifier rs)) natO) k : typed empC e \u03c4 \u2192 ssteps (gReifiers_sReifier rs) (interp_expr _ e ()) (\u03c3,()) \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier rs) \u03b2 st' \u03b21 st1) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["logpred_adequacy", "fundamental"], "remove_type": "abort"}, {"name": "logpred_adequacy", "text": "Lemma logpred_adequacy cr \u03a3 R `{!Cofe R, SubOfe natO R}`{!invGpreS \u03a3}`{!statePreG rs R \u03a3} \u03c4 (\u03b1 : unitO -n> IT (gReifiers_ops rs) R) (\u03b2 : IT (gReifiers_ops rs) R) st st' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs R \u03a3}, (\u00a3 cr \u22a2 valid1 rs notStuck (\u03bb _:unitO, True)%I empC \u03b1 \u03c4)%I) \u2192 ssteps (gReifiers_sReifier rs) (\u03b1 ()) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier rs) \u03b2 st' \u03b21 st1) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["IT_of_to_V'", "wp_safety", "ssubst_valid_nil", "wp_wand"], "remove_type": "abort"}], "theories/affine_lang/logrel1.v": [], "theories/examples/store.v": [{"name": "wp_dealloc", "text": "Lemma wp_dealloc (l : loc) \u03b1 s \u03a6 : heap_ctx -\u2217 \u25b7 pointsto l \u03b1 -\u2217 \u25b7 \u25b7 \u03a6 (RetV ()) -\u2217 WP@{rs} DEALLOC l @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["wp_dealloc_atomic"], "remove_type": "abort"}, {"name": "wp_dealloc_atomic", "text": "Lemma wp_dealloc_atomic (l : loc) E1 E2 s \u03a6 : nclose (nroot.@\"storeE\") ## E1 \u2192 heap_ctx -\u2217 (|={E1,E2}=> \u2203 \u03b1, \u25b7 pointsto l \u03b1 \u2217 \u25b7 \u25b7 (|={E2,E1}=> \u03a6 (RetV ()))) -\u2217 WP@{rs} DEALLOC l @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["istate_loc_dom", "wp_subreify'", "wp_val", "istate_delete"], "remove_type": "abort"}, {"name": "wp_alloc", "text": "Lemma wp_alloc (\u03b1 : IT) (k : locO -n> IT) s \u03a6 `{!NonExpansive \u03a6} : heap_ctx -\u2217 \u25b7\u25b7 (\u2200 l, pointsto l \u03b1 -\u2217 WP@{rs} k l @ s {{ \u03a6 }}) -\u2217 WP@{rs} ALLOC \u03b1 k @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["wp_subreify'", "istate_alloc"], "remove_type": "abort"}, {"name": "wp_write", "text": "Lemma wp_write (l : loc) (\u03b1 \u03b2 : IT) s \u03a6 : heap_ctx -\u2217 \u25b7 pointsto l \u03b1 -\u2217 \u25b7\u25b7 (pointsto l \u03b2 -\u2217 \u03a6 (RetV ())) -\u2217 WP@{rs} WRITE l \u03b2 @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["wp_write_atomic"], "remove_type": "abort"}, {"name": "wp_write_atomic", "text": "Lemma wp_write_atomic (l : loc) E1 E2 \u03b2 s \u03a6 : nclose (nroot.@\"storeE\") ## E1 \u2192 heap_ctx -\u2217 (|={E1,E2}=> \u2203 \u03b1, \u25b7 pointsto l \u03b1 \u2217 \u25b7 \u25b7 (pointsto l \u03b2 ={E2,E1}=\u2217 \u03a6 (RetV ()))) -\u2217 WP@{rs} WRITE l \u03b2 @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["istate_loc_dom", "wp_subreify'", "wp_val", "istate_write"], "remove_type": "abort"}], "theories/gitree/weakestpre.v": [{"name": "wp_safety", "text": "Lemma wp_safety cr \u03a3 `{!invGpreS \u03a3} n (rs : gReifiers n) {A} `{!Cofe A} `{!statePreG rs A \u03a3} s k (\u03b1 \u03b2 : IT (gReifiers_ops rs) A) (\u03c3 \u03c3' : gReifiers_state rs \u266f IT (gReifiers_ops rs) A) : (\u2200 \u03a3 P Q, @disjunction_property \u03a3 P Q) \u2192 ssteps (gReifiers_sReifier rs) \u03b1 \u03c3 \u03b2 \u03c3' k \u2192 IT_to_V \u03b2 \u2261 None \u2192 (\u2200 `{H1 : !invGS_gen HasLc \u03a3} `{H2: !stateG rs A \u03a3}, \u2203 \u03a6, NonExpansive \u03a6 \u2227 (\u00a3 cr \u2217 has_full_state \u03c3 \u22a2 WP@{rs} \u03b1 @ s {{ \u03a6 }})%I) \u2192 ((\u2203 \u03b21 \u03c31, sstep (gReifiers_sReifier rs) \u03b2 \u03c3' \u03b21 \u03c31) \u2228 (\u2203 e, \u03b2 \u2261 Err e \u2227 s e)).", "decomposition": [], "retrieval": ["IT_vis_err_ne", "IT_tick_err_ne", "istep_safe_sstep", "wp_ssteps_isafe", "Err_inj'", "IT_dont_confuse", "IT_fun_err_ne", "IT_ret_err_ne", "new_state_interp"], "remove_type": "abort"}, {"name": "wp_adequacy", "text": "Lemma wp_adequacy cr \u03a3 `{!invGpreS \u03a3} n (rs : gReifiers n) {A} `{!Cofe A} `{!statePreG rs A \u03a3} (\u03b1 : IT _ A) \u03c3 \u03b2v \u03c3' s k (\u03c8 : (ITV (gReifiers_ops rs) A) \u2192 Prop) : ssteps (gReifiers_sReifier rs) \u03b1 \u03c3 (IT_of_V \u03b2v) \u03c3' k \u2192 (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs A \u03a3}, \u2203 \u03a6, NonExpansive \u03a6 \u2227 (\u2200 \u03b2v, \u03a6 \u03b2v \u22a2 \u231c\u03c8 \u03b2v\u231d) \u2227 (\u00a3 cr \u2217 has_full_state \u03c3 \u22a2 WP@{rs} \u03b1 @ s {{ \u03a6 }})%I) \u2192 \u03c8 \u03b2v.", "decomposition": [], "retrieval": ["wp_val_inv", "wp_ssteps", "new_state_interp"], "remove_type": "abort"}], "theories/input_lang/interp.v": [{"name": "interp_expr_fill_yes_reify", "text": "Lemma interp_expr_fill_yes_reify {S} K env (e e' : expr S) (\u03c3 \u03c3' : stateO) (\u03c3r : gState_rest sR_idx rs \u266f IT) n : head_step e \u03c3 e' \u03c3' (n,1) \u2192 reify (gReifiers_sReifier rs) (interp_expr (fill K e) env) (gState_recomp \u03c3r (sR_state \u03c3)) \u2261 (gState_recomp \u03c3r (sR_state \u03c3'), Tick_n n $ interp_expr (fill K e') env).", "decomposition": [], "retrieval": ["subReifier_reify", "interp_ectx_fill", "hom_INPUT", "Tick_eq", "get_ret_ret", "reify_vis_eq", "hom_OUTPUT_"], "remove_type": "abort"}], "theories/gitree/lambda.v": [{"name": "LET_Val", "text": "Lemma LET_Val \u03b1 f `{!AsVal \u03b1} : LET \u03b1 f \u2261 f \u03b1.", "decomposition": [], "retrieval": ["get_val_ITV"], "remove_type": "abort"}, {"name": "SEQ_Val", "text": "Lemma SEQ_Val \u03b1 \u03b2 `{!AsVal \u03b1} : SEQ \u03b1 \u03b2 \u2261 \u03b2.", "decomposition": [], "retrieval": ["get_val_ITV"], "remove_type": "abort"}, {"name": "NATOP_ITV_Vis_l", "text": "Lemma NATOP_ITV_Vis_l `{!SubOfe natO A} op i k \u03b2 f : AsVal \u03b2 \u2192 NATOP f (Vis op i k) \u03b2 \u2261 Vis op i (laterO_map (flipO (NATOP f) \u03b2) \u25ce k).", "decomposition": [], "retrieval": ["get_val_vis", "get_val_ITV"], "remove_type": "abort"}, {"name": "NATOP_Vis_r", "text": "Lemma NATOP_Vis_r `{!SubOfe natO A} t1 op i k f : NATOP f t1 (Vis op i k) \u2261 Vis op i (laterO_map (NATOP f t1) \u25ce k).", "decomposition": [], "retrieval": ["get_val_vis"], "remove_type": "abort"}, {"name": "NATOP_ITV_Tick_n_l", "text": "Lemma NATOP_ITV_Tick_n_l `{!SubOfe natO A} t1 \u03b2 f n : AsVal \u03b2 \u2192 NATOP f (Tick_n n t1) \u03b2 \u2261 Tick_n n $ NATOP f t1 \u03b2.", "decomposition": ["NATOP_ITV_Tick_l"], "retrieval": [], "remove_type": "abort"}, {"name": "NATOP_ITV_Tick_l", "text": "Lemma NATOP_ITV_Tick_l `{!SubOfe natO A} t1 \u03b2 f : AsVal \u03b2 \u2192 NATOP f (Tick t1) \u03b2 \u2261 Tick $ NATOP f t1 \u03b2.", "decomposition": [], "retrieval": ["get_val_tick", "get_val_ITV"], "remove_type": "abort"}, {"name": "NATOP_Tick_n_r", "text": "Lemma NATOP_Tick_n_r `{!SubOfe natO A} t1 t2 f n : NATOP f t1 (Tick_n n t2) \u2261 Tick_n n $ NATOP f t1 t2.", "decomposition": ["NATOP_Tick_r"], "retrieval": [], "remove_type": "abort"}, {"name": "NATOP_Tick_r", "text": "Lemma NATOP_Tick_r `{!SubOfe natO A} t1 t2 f : NATOP f t1 (Tick t2) \u2261 Tick $ NATOP f t1 t2.", "decomposition": [], "retrieval": ["get_val_tick"], "remove_type": "abort"}, {"name": "NATOP_Ret", "text": "Lemma NATOP_Ret `{!SubOfe natO A} n1 n2 f : NATOP f (Ret n1) (Ret n2) \u2261 Ret (f n1 n2).", "decomposition": [], "retrieval": ["get_ret_ret", "get_val_ret"], "remove_type": "abort"}, {"name": "NATOP_Err_l", "text": "Lemma NATOP_Err_l `{!SubOfe natO A} f e \u03b2 : AsVal \u03b2 \u2192 NATOP f (Err e) \u03b2 \u2261 Err e.", "decomposition": [], "retrieval": ["get_val_err", "get_val_ITV"], "remove_type": "abort"}, {"name": "NATOP_Err_r", "text": "Lemma NATOP_Err_r `{!SubOfe natO A} f e t1 : NATOP f t1 (Err e) \u2261 Err e.", "decomposition": [], "retrieval": ["get_val_err"], "remove_type": "abort"}, {"name": "IF_Vis", "text": "Lemma IF_Vis `{!SubOfe natO A} op i k t1 t2 : IF (Vis op i k) t1 t2 \u2261 Vis op i (laterO_map (IF_last t1 t2) \u25ce k).", "decomposition": [], "retrieval": ["get_ret_vis"], "remove_type": "abort"}, {"name": "IF_Tick_n", "text": "Lemma IF_Tick_n `{!SubOfe natO A} n t t1 t2 : IF (Tick_n n t) t1 t2 \u2261 Tick_n n (IF t t1 t2).", "decomposition": ["IF_Tick"], "retrieval": [], "remove_type": "abort"}, {"name": "IF_Tick", "text": "Lemma IF_Tick `{!SubOfe natO A} t t1 t2 : IF (Tick t) t1 t2 \u2261 Tick (IF t t1 t2).", "decomposition": [], "retrieval": ["get_ret_tick"], "remove_type": "abort"}, {"name": "IF_False", "text": "Lemma IF_False `{!SubOfe natO A} n t1 t2 : 0 \u2265 n \u2192 IF (Ret n) t1 t2 \u2261 t2.", "decomposition": [], "retrieval": ["get_ret_ret"], "remove_type": "abort"}, {"name": "IF_True", "text": "Lemma IF_True `{!SubOfe natO A} n t1 t2 : 0 < n \u2192 IF (Ret n) t1 t2 \u2261 t1.", "decomposition": [], "retrieval": ["get_ret_ret"], "remove_type": "abort"}, {"name": "IF_Err", "text": "Lemma IF_Err `{!SubOfe natO A} e t1 t2 : IF (Err e) t1 t2 \u2261 Err e.", "decomposition": [], "retrieval": ["get_ret_err"], "remove_type": "abort"}, {"name": "APP'_Fun_l", "text": "Lemma APP'_Fun_l f x `{!AsVal x} : APP' (Fun f) x \u2261 Tau $ laterO_ap f (Next x).", "decomposition": ["APP_APP'_ITV", "APP_Fun"], "retrieval": [], "remove_type": "abort"}, {"name": "APP'_Ret_l", "text": "Lemma APP'_Ret_l x t `{!AsVal t}: APP' (core.Ret x) t \u2261 Err RuntimeErr.", "decomposition": ["APP_Ret", "APP_APP'_ITV"], "retrieval": [], "remove_type": "abort"}, {"name": "APP'_Err_l", "text": "Lemma APP'_Err_l e x `{!AsVal x}: APP' (Err e) x \u2261 Err e.", "decomposition": ["APP_Err", "APP_APP'_ITV"], "retrieval": [], "remove_type": "abort"}, {"name": "APP'_Tick_l_n", "text": "Lemma APP'_Tick_l_n \u03b1 n \u03b2 `{!AsVal \u03b2} : APP' (Tick_n n \u03b1) \u03b2 \u2261 Tick_n n $ APP' \u03b1 \u03b2.", "decomposition": ["APP'_Tick_l"], "retrieval": [], "remove_type": "abort"}, {"name": "APP'_Tick_l", "text": "Lemma APP'_Tick_l \u03b1 \u03b2 `{!AsVal \u03b2} : APP' (Tick \u03b1) \u03b2 \u2261 Tick $ APP' \u03b1 \u03b2.", "decomposition": ["APP_Tick", "APP_APP'_ITV"], "retrieval": [], "remove_type": "abort"}, {"name": "APP'_Vis_l", "text": "Lemma APP'_Vis_l \u03b2 op i k `{!AsVal \u03b2} : APP' (Vis op i k) \u03b2 \u2261 Vis op i (laterO_map (flipO APP' \u03b2) \u25ce k).", "decomposition": ["APP_APP'_ITV", "APP_Vis"], "retrieval": [], "remove_type": "abort"}, {"name": "APP_APP'_ITV", "text": "Lemma APP_APP'_ITV \u03b1 \u03b2 : AsVal \u03b2 \u2192 APP' \u03b1 \u03b2 \u2261 APP \u03b1 (Next \u03b2).", "decomposition": ["APP_APP'_ITV'"], "retrieval": [], "remove_type": "abort"}, {"name": "APP_APP'_ITV'", "text": "Lemma APP_APP'_ITV' \u03b1 (\u03b2v : ITV \u03a3 A) : APP' \u03b1 (IT_of_V \u03b2v) \u2261 APP \u03b1 (Next (IT_of_V \u03b2v)).", "decomposition": ["APP'_Fun_r", "APP'_Ret_r"], "retrieval": [], "remove_type": "abort"}, {"name": "APP'_Vis_r", "text": "Lemma APP'_Vis_r f op i k : APP' f (Vis op i k) \u2261 Vis op i (laterO_map (APP' f) \u25ce k).", "decomposition": [], "retrieval": ["get_val_vis"], "remove_type": "abort"}, {"name": "APP'_Tick_r_n", "text": "Lemma APP'_Tick_r_n f n t : APP' f (Tick_n n t) \u2261 Tick_n n $ APP' f t.", "decomposition": ["APP'_Tick_r"], "retrieval": [], "remove_type": "abort"}, {"name": "APP'_Tick_r", "text": "Lemma APP'_Tick_r f t : APP' f (Tick t) \u2261 Tick $ APP' f t.", "decomposition": [], "retrieval": ["get_val_tick"], "remove_type": "abort"}, {"name": "APP'_Fun_r", "text": "Lemma APP'_Fun_r f x : APP' f (Fun x) \u2261 APP f (Next (Fun x)).", "decomposition": [], "retrieval": ["get_val_fun"], "remove_type": "abort"}, {"name": "APP'_Ret_r", "text": "Lemma APP'_Ret_r f x : APP' f (core.Ret x) \u2261 APP f (Next (core.Ret x)).", "decomposition": [], "retrieval": ["get_val_ret"], "remove_type": "abort"}, {"name": "APP'_Err_r", "text": "Lemma APP'_Err_r f e : APP' f (Err e) \u2261 Err e.", "decomposition": [], "retrieval": ["get_val_err"], "remove_type": "abort"}, {"name": "APP_Vis", "text": "Lemma APP_Vis op i k x : APP (Vis op i k) x \u2261 Vis op i (laterO_map (Ppa x) \u25ce k).", "decomposition": [], "retrieval": ["get_fun_vis"], "remove_type": "abort"}, {"name": "APP_Tick_n", "text": "Lemma APP_Tick_n n t x : APP (Tick_n n t) x \u2261 Tick_n n $ APP t x.", "decomposition": ["APP_Tick"], "retrieval": [], "remove_type": "abort"}, {"name": "APP_Tick", "text": "Lemma APP_Tick t x : APP (Tick t) x \u2261 Tick $ APP t x.", "decomposition": [], "retrieval": ["get_fun_tick"], "remove_type": "abort"}, {"name": "APP_Fun", "text": "Lemma APP_Fun f x : APP (Fun f) x \u2261 Tau $ laterO_ap f x.", "decomposition": [], "retrieval": ["get_fun_fun"], "remove_type": "abort"}, {"name": "APP_Err", "text": "Lemma APP_Err e x : APP (Err e) x \u2261 Err e.", "decomposition": [], "retrieval": ["get_fun_err"], "remove_type": "abort"}, {"name": "APP_Ret", "text": "Lemma APP_Ret x y : APP (core.Ret x) y \u2261 Err RuntimeErr.", "decomposition": [], "retrieval": ["get_fun_ret"], "remove_type": "abort"}, {"name": "IT_to_V_Ret", "text": "Lemma IT_to_V_Ret n : IT_to_V (Ret n) \u2261 Some (RetV n).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "IT_of_V_Ret", "text": "Lemma IT_of_V_Ret n : IT_of_V (RetV n) \u2261 Ret n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "get_fun_ret", "text": "Lemma get_fun_ret f n : get_fun f (Ret n) \u2261 Err RuntimeErr.", "decomposition": [], "retrieval": ["IT_rec1_ret"], "remove_type": "abort"}, {"name": "get_val_ret", "text": "Lemma get_val_ret f n : get_val f (Ret n) \u2261 f (Ret n).", "decomposition": [], "retrieval": ["IT_rec1_ret"], "remove_type": "abort"}, {"name": "get_ret_ret", "text": "Lemma get_ret_ret f n : get_ret f (Ret n) \u2261 f n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}]}, "055af10841a062b26d5182d891e136bcce2fd8bc": {"theories/gitree/core.v": [{"name": "get_val_ITV'", "text": "Lemma get_val_ITV' f \u03b2v : get_val f (IT_of_V \u03b2v) \u2261 f (IT_of_V \u03b2v).", "decomposition": ["get_val_ret"], "retrieval": ["get_val_fun"], "remove_type": "abort"}, {"name": "get_val_ret", "text": "Lemma get_val_ret f n : get_val f (Ret n) \u2261 f (Ret n).", "decomposition": [], "retrieval": ["IT_rec1_ret"], "remove_type": "abort"}, {"name": "get_ret_vis", "text": "Lemma get_ret_vis f op i k : get_ret f (Vis op i k) \u2261 Vis op i (laterO_map (get_ret f) \u25ce k).", "decomposition": [], "retrieval": ["IT_rec1_vis", "laterO_map_compose"], "remove_type": "abort"}, {"name": "get_ret_tick_n", "text": "Lemma get_ret_tick_n f n t : get_ret f (Tick_n n t) \u2261 Tick_n n (get_ret f t).", "decomposition": ["get_ret_tick"], "retrieval": [], "remove_type": "abort"}, {"name": "get_ret_tick", "text": "Lemma get_ret_tick f t : get_ret f (Tick t) \u2261 Tick (get_ret f t).", "decomposition": [], "retrieval": ["IT_rec1_tau", "laterO_map_compose"], "remove_type": "abort"}, {"name": "get_ret_ret", "text": "Lemma get_ret_ret f n : get_ret f (Ret n) \u2261 f n.", "decomposition": [], "retrieval": ["IT_rec1_ret"], "remove_type": "abort"}, {"name": "get_ret_fun", "text": "Lemma get_ret_fun f g : get_ret f (Fun g) \u2261 Err RuntimeErr.", "decomposition": [], "retrieval": ["IT_rec1_fun"], "remove_type": "abort"}, {"name": "get_ret_err", "text": "Lemma get_ret_err f e : get_ret f (Err e) \u2261 Err e.", "decomposition": [], "retrieval": ["IT_rec1_err"], "remove_type": "abort"}], "theories/input_lang/logrel.v": [{"name": "logrel_nat_adequacy", "text": "Lemma logrel_nat_adequacy \u03a3 `{!invGpreS \u03a3}`{!statePreG rs \u03a3} {S} (\u03b1 : IT (gReifiers_ops rs) natO) (e : expr S) n \u03c3 \u03c3' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs \u03a3}, (True \u22a2 logrel rs Tnat \u03b1 e)%I) \u2192 ssteps (gReifiers_sReifier rs) \u03b1 (\u03c3,()) (Nat n) \u03c3' k \u2192 \u2203 m \u03c3', prim_steps e \u03c3 (Val $ Lit n) \u03c3' m.", "decomposition": [], "retrieval": ["IT_ret_fun_ne", "wp_adequacy", "wp_wand", "Ret_inj'"], "remove_type": "abort"}, {"name": "fundamental", "text": "Lemma fundamental {S} (\u0393 : tyctx S) \u03c4 e : typed \u0393 e \u03c4 \u2192 \u22a2 logrel_valid \u0393 e (interp_expr rs e) \u03c4 with fundamental_val {S} (\u0393 : tyctx S) \u03c4 v : typed_val \u0393 v \u03c4 \u2192 \u22a2 logrel_valid \u0393 (Val v) (interp_val rs v) \u03c4.", "decomposition": [], "retrieval": ["compat_output", "compat_var", "compat_app", "logrel_of_val", "compat_natop", "compat_rec", "compat_if", "compat_input", "compat_recV"], "remove_type": "abort"}, {"name": "compat_natop", "text": "Lemma compat_natop {S} (\u0393 : tyctx S) e1 e2 \u03b11 \u03b12 op : \u22a2 logrel_valid \u0393 e1 \u03b11 Tnat -\u2217 logrel_valid \u0393 e2 \u03b12 Tnat -\u2217 logrel_valid \u0393 (NatOp op e1 e2) (interp_natop rs op \u03b11 \u03b12) Tnat.", "decomposition": [], "retrieval": ["logrel_step_pure", "logrel_bind", "Ectx_step'", "logrel_of_val"], "remove_type": "abort"}, {"name": "compat_output", "text": "Lemma compat_output {S} \u0393 (e: expr S) \u03b1 : \u22a2 logrel_valid \u0393 e \u03b1 Tnat -\u2217 logrel_valid \u0393 (Output e) (interp_output rs \u03b1) Tnat.", "decomposition": ["get_ret_ret"], "retrieval": ["Ectx_step'", "prim_step_steps", "wp_output", "logrel_bind"], "remove_type": "abort"}], "theories/input_lang/logpred.v": [{"name": "logpred_adequacy", "text": "Lemma logpred_adequacy cr \u03a3 `{!invGpreS \u03a3}`{!statePreG rs \u03a3} \u03c4 (\u03b1 : unitO -n> IT (gReifiers_ops rs) natO) (\u03b2 : IT (gReifiers_ops rs) natO) st st' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs \u03a3}, (\u00a3 cr \u22a2 valid1 rs notStuck (\u03bb _:unitO, True)%I empC \u03b1 \u03c4)%I) \u2192 ssteps (gReifiers_sReifier rs) (\u03b1 ()) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier rs) \u03b2 st' \u03b21 st1) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["IT_of_to_V'", "wp_safety", "ssubst_valid_nil", "wp_wand"], "remove_type": "abort"}, {"name": "compat_natop", "text": "Lemma compat_natop {S} (\u0393 : tyctx S) op \u03b1 \u03b2 : \u22a2 valid1 \u0393 \u03b1 Tnat -\u2217 valid1 \u0393 \u03b2 Tnat -\u2217 valid1 \u0393 (interp_natop _ op \u03b1 \u03b2) Tnat.", "decomposition": [], "retrieval": ["expr_pred_frame", "wp_val", "expr_pred_bind"], "remove_type": "abort"}, {"name": "compat_output", "text": "Lemma compat_output {S} (\u0393 : tyctx S) \u03b1 : \u22a2 valid1 \u0393 \u03b1 Tnat \u2192 valid1 \u0393 (interp_output rs \u03b1) Tnat.", "decomposition": ["get_ret_ret"], "retrieval": ["expr_pred_frame", "wp_output", "expr_pred_bind"], "remove_type": "abort"}], "theories/input_lang/interp.v": [{"name": "soundness", "text": "Lemma soundness {S} (e1 e2 : expr S) \u03c31 \u03c32 (\u03c3r : gState_rest sR_idx rs \u266f IT) n m env : prim_step e1 \u03c31 e2 \u03c32 (n,m) \u2192 ssteps (gReifiers_sReifier rs) (interp_expr e1 env) (gState_recomp \u03c3r (sR_state \u03c31)) (interp_expr e2 env) (gState_recomp \u03c3r (sR_state \u03c32)) n.", "decomposition": ["get_ret_ret"], "retrieval": ["head_step_no_io", "interp_expr_fill_no_reify", "interp_ectx_fill", "hom_INPUT", "interp_expr_fill_yes_reify", "ssteps_tick_n", "hom_OUTPUT_", "head_step_io_01"], "remove_type": "abort"}, {"name": "interp_expr_fill_yes_reify", "text": "Lemma interp_expr_fill_yes_reify {S} K env (e e' : expr S) (\u03c3 \u03c3' : stateO) (\u03c3r : gState_rest sR_idx rs \u266f IT) n : head_step e \u03c3 e' \u03c3' (n,1) \u2192 reify (gReifiers_sReifier rs) (interp_expr (fill K e) env) (gState_recomp \u03c3r (sR_state \u03c3)) \u2261 (gState_recomp \u03c3r (sR_state \u03c3'), Tick_n n $ interp_expr (fill K e') env).", "decomposition": ["get_ret_ret"], "retrieval": ["subReifier_reify", "interp_ectx_fill", "hom_INPUT", "Tick_eq", "reify_vis_eq", "hom_OUTPUT_"], "remove_type": "abort"}, {"name": "interp_expr_head_step", "text": "Lemma interp_expr_head_step {S} env (e : expr S) e' \u03c3 \u03c3' n : head_step e \u03c3 e' \u03c3' (n,0) \u2192 interp_expr e env \u2261 Tick_n n $ interp_expr e' env.", "decomposition": [], "retrieval": ["IF_False", "IF_True", "APP_APP'_ITV", "interp_expr_subst", "Tick_eq", "interp_rec_unfold", "APP_Fun", "interp_subs_scope_idsub"], "remove_type": "abort"}, {"name": "wp_output", "text": "Lemma wp_output (\u03c3 \u03c3' : stateO) (n : nat) \u03a6 s : update_output n \u03c3 = \u03c3' \u2192 has_substate \u03c3 -\u2217 \u25b7 (\u00a3 1 -\u2217 has_substate \u03c3' -\u2217 \u03a6 (RetV 0)) -\u2217 WP@{rs} (OUTPUT n) @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["wp_subreify", "wp_val"], "remove_type": "abort"}, {"name": "hom_OUTPUT_", "text": "Lemma hom_OUTPUT_ m \u03b1 f `{!IT_hom f} : f (OUTPUT_ m \u03b1) \u2261 OUTPUT_ m (f \u03b1).", "decomposition": [], "retrieval": ["laterO_map_Next"], "remove_type": "abort"}, {"name": "hom_INPUT", "text": "Lemma hom_INPUT k f `{!IT_hom f} : f (INPUT k) \u2261 INPUT (OfeMor f \u25ce k).", "decomposition": [], "retrieval": ["laterO_map_Next"], "remove_type": "abort"}], "theories/examples/factorial.v": [{"name": "wp_fact_io", "text": "Lemma wp_fact_io (n : nat) : heap_ctx \u2217 has_substate (State [n] []) \u22a2 WP@{rs} get_ret OUTPUT fact_io {{ _, has_substate (State [] [fact n]) }}.", "decomposition": ["get_ret_ret"], "retrieval": ["wp_input", "wp_bind", "wp_output", "wp_fact_imp", "wp_wand"], "remove_type": "abort"}, {"name": "wp_fact_imp", "text": "Lemma wp_fact_imp (n : nat) : heap_ctx \u22a2 WP@{rs} fact_imp \u2299 (Nat n) {{ \u03b2v, \u03b2v \u2261 RetV (fact n) }}.", "decomposition": ["get_ret_ret"], "retrieval": ["wp_seq", "wp_val", "wp_fact_imp_bod", "wp_read", "wp_alloc", "wp_lam", "wp_wand"], "remove_type": "abort"}, {"name": "wp_fact_imp_bod", "text": "Lemma wp_fact_imp_bod n m acc \u2113 : heap_ctx -\u2217 pointsto acc (Nat m) -\u2217 pointsto \u2113 (Nat n) -\u2217 WP@{rs} fact_imp_body acc \u2113 {{ _, pointsto acc (Nat (m * fact n)) }}.", "decomposition": [], "retrieval": ["wp_seq", "wp_write", "wp_val", "IF_False", "IF_True", "wp_bind", "wp_let", "WHILE_eq", "wp_read", "wp_wand"], "remove_type": "abort"}], "theories/examples/store.v": [{"name": "wp_dealloc", "text": "Lemma wp_dealloc (l : loc) \u03b1 s \u03a6 : heap_ctx -\u2217 \u25b7 pointsto l \u03b1 -\u2217 \u25b7 \u25b7 \u03a6 (RetV 0) -\u2217 WP@{rs} DEALLOC l @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["wp_dealloc_atomic"], "remove_type": "abort"}, {"name": "wp_dealloc_atomic", "text": "Lemma wp_dealloc_atomic (l : loc) E1 E2 s \u03a6 : nclose (nroot.@\"storeE\") ## E1 \u2192 heap_ctx -\u2217 (|={E1,E2}=> \u2203 \u03b1, \u25b7 pointsto l \u03b1 \u2217 \u25b7 \u25b7 (|={E2,E1}=> \u03a6 (RetV 0))) -\u2217 WP@{rs} DEALLOC l @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["istate_loc_dom", "wp_subreify'", "wp_val", "istate_delete"], "remove_type": "abort"}, {"name": "wp_write", "text": "Lemma wp_write (l : loc) (\u03b1 \u03b2 : IT) s \u03a6 : heap_ctx -\u2217 \u25b7 pointsto l \u03b1 -\u2217 \u25b7\u25b7 (pointsto l \u03b2 -\u2217 \u03a6 (RetV 0)) -\u2217 WP@{rs} WRITE l \u03b2 @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["wp_write_atomic"], "remove_type": "abort"}, {"name": "wp_write_atomic", "text": "Lemma wp_write_atomic (l : loc) E1 E2 \u03b2 s \u03a6 : nclose (nroot.@\"storeE\") ## E1 \u2192 heap_ctx -\u2217 (|={E1,E2}=> \u2203 \u03b1, \u25b7 pointsto l \u03b1 \u2217 \u25b7 \u25b7 (pointsto l \u03b2 ={E2,E1}=\u2217 \u03a6 (RetV 0))) -\u2217 WP@{rs} WRITE l \u03b2 @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["istate_loc_dom", "wp_subreify'", "wp_val", "istate_write"], "remove_type": "abort"}], "theories/gitree/reductions.v": [{"name": "istep_hom_inv", "text": "Lemma istep_hom_inv \u03b1 \u03c3 \u03b2 \u03c3' `{!IT_hom f} : istep (f \u03b1) \u03c3 \u03b2 \u03c3' \u22a2@{iProp} \u231cis_Some (IT_to_V \u03b1)\u231d \u2228 (IT_to_V \u03b1 \u2261 None \u2227 \u2203 \u03b1', istep \u03b1 \u03c3 \u03b1' \u03c3' \u2227 \u25b7 (\u03b2 \u2261 f \u03b1')).", "decomposition": [], "retrieval": ["IT_to_V_Ret", "Vis_inj_op'", "IT_dont_confuse", "IT_to_V_Vis", "IT_to_V_Tau", "istep_err", "Vis_inj'", "reify_input_cont_inv", "IT_tick_vis_ne", "istep_tick", "IT_to_V_Fun"], "remove_type": "abort"}, {"name": "isteps_tick", "text": "Lemma isteps_tick \u03b1 \u03b2v \u03c3 \u03c3' k : isteps (Tick \u03b1) \u03c3 (IT_of_V \u03b2v) \u03c3' k \u22a2 \u2203 k' : nat, \u231ck = (1 + k')%nat\u231d \u2227 \u25b7 isteps \u03b1 \u03c3 (IT_of_V \u03b2v) \u03c3' k'.", "decomposition": [], "retrieval": ["IT_fun_tick_ne", "isteps_unfold", "istep_tick", "IT_ret_tick_ne"], "remove_type": "abort"}, {"name": "isteps_val", "text": "Lemma isteps_val \u03b2v \u03b2 k \u03c3 \u03c3' : isteps (IT_of_V \u03b2v) \u03c3 \u03b2 \u03c3' k \u22a2 IT_of_V \u03b2v \u2261 \u03b2 \u2227 \u03c3 \u2261 \u03c3' \u2227 \u231ck = 0\u231d.", "decomposition": [], "retrieval": ["IT_fun_tick_ne", "IT_ret_vis_ne", "isteps_S", "IT_fun_vis_ne", "isteps_0", "IT_ret_tick_ne"], "remove_type": "abort"}, {"name": "effect_safe_externalize", "text": "Local Lemma effect_safe_externalize (\u03b1 : IT) \u03c3 : (\u22a2 \u2203 \u03b2 \u03c3', (\u2203 op i k, \u03b1 \u2261 Vis op i k \u2227 reify r \u03b1 \u03c3 \u2261 (\u03c3', Tick \u03b2)) : iProp) \u2192 \u2203 \u03b2 \u03c3', sstep r \u03b1 \u03c3 \u03b2 \u03c3'.", "decomposition": [], "retrieval": ["IT_vis_err_ne", "IT_tick_err_ne", "IT_dont_confuse", "reify_is_always_a_tick", "IT_ret_vis_ne", "IT_fun_vis_ne", "IT_tick_vis_ne"], "remove_type": "abort"}, {"name": "tick_safe_externalize", "text": "Local Lemma tick_safe_externalize (\u03b1 : IT) \u03c3 : (\u22a2 \u2203 \u03b2 \u03c3', \u03b1 \u2261 Tick \u03b2 \u2227 \u03c3 \u2261 \u03c3' : iProp) \u2192 \u2203 \u03b2 \u03c3', sstep r \u03b1 \u03c3 \u03b2 \u03c3'.", "decomposition": [], "retrieval": ["IT_tick_err_ne", "IT_fun_tick_ne", "IT_dont_confuse", "IT_tick_vis_ne", "IT_ret_tick_ne"], "remove_type": "abort"}], "theories/affine_lang/logrel2.v": [{"name": "logrel2_adequacy", "text": "Lemma logrel2_adequacy cr \u03a3 `{!invGpreS \u03a3}`{!statePreG rs \u03a3} `{!heapPreG rs \u03a3} `{!na_invG \u03a3} \u03c4 (\u03b1 : unitO -n> IT (gReifiers_ops rs) natO) (\u03b2 : IT (gReifiers_ops rs) natO) st st' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs \u03a3} `{H3: !heapG rs \u03a3} p, (\u00a3 cr \u22a2 valid2 rs p empC \u03b1 \u03c4)%I) \u2192 ssteps (gReifiers_sReifier rs) (\u03b1 ()) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier rs) \u03b2 st' \u03b21 st1) \u2228 (\u03b2 \u2261 Err OtherError) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["IT_of_to_V'", "ssubst_valid_nil", "fupd_wp", "wp_safety", "new_heapG", "wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_from_affine_fun", "text": "Lemma compat_glue_from_affine_fun (\u03c41 \u03c42 : ty) (\u03c41' \u03c42' : io_lang.ty) \u03b1 (glue_to_affine glue_from_affine : IT -n> IT) : (\u2200 \u03b1, io_valid empC \u03b1 \u03c41' \u22a2 valid2 empC (constO (glue_to_affine (\u03b1 ()))) \u03c41) \u2192 (\u2200 \u03b1, valid2 empC (constO \u03b1) \u03c42 \u22a2 heap_ctx -\u2217 io_valid empC (constO (glue_from_affine \u03b1)) \u03c42') \u2192 valid2 empC (constO \u03b1) (tArr \u03c41 \u03c42) \u22a2 heap_ctx -\u2217 io_valid empC (constO (glue_from_affine_fun _ glue_from_affine glue_to_affine \u03b1)) (Tarr (Tarr Tnat \u03c41') \u03c42').", "decomposition": [], "retrieval": ["wp_seq", "wp_write", "wp_val", "wp_Thunk", "IF_False", "IF_True", "fupd_wp", "wp_err", "wp_bind", "wp_read", "ssubst_valid_nil", "wp_let", "expr_pred_ret", "wp_lam", "wp_wand"], "remove_type": "abort"}], "theories/examples/pairs.v": [{"name": "projIT2_pair", "text": "Lemma projIT2_pair \u03b1 \u03b2 `{!AsVal \u03b1, !AsVal \u03b2} : projIT2 (pairIT \u03b1 \u03b2) \u2261 Tick_n 3 \u03b2.", "decomposition": [], "retrieval": ["get_val_ITV", "projIT2_pairV"], "remove_type": "abort"}, {"name": "projIT2_pairV", "text": "Lemma projIT2_pairV \u03b1 \u03b2 `{!AsVal \u03b1, !AsVal \u03b2} : projIT2 (pairITV \u03b1 \u03b2) \u2261 Tick_n 3 \u03b2.", "decomposition": [], "retrieval": ["APP'_Tick_l", "APP'_Fun_l", "Tick_eq"], "remove_type": "abort"}, {"name": "projIT1_pair", "text": "Lemma projIT1_pair \u03b1 \u03b2 `{!AsVal \u03b1, !AsVal \u03b2} : projIT1 (pairIT \u03b1 \u03b2) \u2261 Tick_n 3 \u03b1.", "decomposition": [], "retrieval": ["projIT1_pairV", "get_val_ITV"], "remove_type": "abort"}, {"name": "projIT1_pairV", "text": "Lemma projIT1_pairV \u03b1 \u03b2 `{!AsVal \u03b1, !AsVal \u03b2} : projIT1 (pairITV \u03b1 \u03b2) \u2261 Tick_n 3 \u03b1.", "decomposition": [], "retrieval": ["APP'_Tick_l", "APP'_Fun_l", "Tick_eq"], "remove_type": "abort"}], "theories/gitree/reify.v": [{"name": "reify_is_always_a_tick", "text": "Lemma reify_is_always_a_tick op x k \u03c3 \u03b2 \u03c3' : reify (Vis op x k) \u03c3 \u2261 (\u03c3', \u03b2) \u2192 (\u2203 \u03b2', \u03b2 \u2261 Tick \u03b2') \u2228 (\u03b2 \u2261 Err RuntimeErr).", "decomposition": [], "retrieval": ["reify_vis_eq", "Tick_eq", "reify_vis_None"], "remove_type": "abort"}, {"name": "reify_input_cont_inv", "text": "Lemma reify_input_cont_inv op i (k1 : _ -n> laterO IT) (k2 : IT -n> IT) \u03c31 \u03c32 \u03b2 {PROP : bi} `{!BiInternalEq PROP} : (reify (Vis op i (laterO_map k2 \u25ce k1)) \u03c31 \u2261 (\u03c32, Tick \u03b2) \u22a2 \u2203 \u03b1, reify (Vis op i k1) \u03c31 \u2261 (\u03c32, Tick \u03b1) \u2227 \u25b7 (\u03b2 \u2261 k2 \u03b1) : PROP)%I.", "decomposition": [], "retrieval": ["Tau_inj'", "IT_tick_err_ne", "reify_vis_None", "reify_vis_eq", "laterO_map_Next"], "remove_type": "abort"}, {"name": "reify_vis_None", "text": "Lemma reify_vis_None op i k \u03c3 : sReifier_re r op (i,\u03c3) \u2261 None \u2192 reify (Vis op i k) \u03c3 \u2261 (\u03c3, Err RuntimeErr).", "decomposition": [], "retrieval": ["IT_rec1_vis"], "remove_type": "abort"}, {"name": "reify_vis_dist", "text": "Lemma reify_vis_dist m op i o k \u03c3 \u03c3' : sReifier_re r op (i,\u03c3) \u2261{m}\u2261 Some (o,\u03c3') \u2192 reify (Vis op i k) \u03c3 \u2261{m}\u2261 (\u03c3', Tau $ k o).", "decomposition": [], "retrieval": ["IT_rec1_vis", "laterO_map_id", "laterO_map_compose"], "remove_type": "abort"}, {"name": "reify_fun_eq", "text": "Lemma reify_fun_eq f \u03c3 : reify (Fun f) \u03c3 \u2261 (\u03c3, Fun f).", "decomposition": [], "retrieval": ["laterO_map_id", "IT_rec1_fun", "laterO_map_compose"], "remove_type": "abort"}], "theories/gitree/weakestpre.v": [{"name": "wp_safety", "text": "Lemma wp_safety cr \u03a3 `{!invGpreS \u03a3} n (rs : gReifiers n) `{!statePreG rs \u03a3} s k (\u03b1 \u03b2 : IT (gReifiers_ops rs) natO) (\u03c3 \u03c3' : gReifiers_state rs \u266f IT (gReifiers_ops rs) natO) : (\u2200 \u03a3 P Q, @disjunction_property \u03a3 P Q) \u2192 ssteps (gReifiers_sReifier rs) \u03b1 \u03c3 \u03b2 \u03c3' k \u2192 IT_to_V \u03b2 \u2261 None \u2192 (\u2200 `{H1 : !invGS_gen HasLc \u03a3} `{H2: !stateG rs \u03a3}, \u2203 \u03a6, NonExpansive \u03a6 \u2227 (\u00a3 cr \u2217 has_full_state \u03c3 \u22a2 WP@{rs} \u03b1 @ s {{ \u03a6 }})%I) \u2192 ((\u2203 \u03b21 \u03c31, sstep (gReifiers_sReifier rs) \u03b2 \u03c3' \u03b21 \u03c31) \u2228 (\u2203 e, \u03b2 \u2261 Err e \u2227 s e)).", "decomposition": [], "retrieval": ["IT_vis_err_ne", "IT_tick_err_ne", "istep_safe_sstep", "wp_ssteps_isafe", "Err_inj'", "IT_dont_confuse", "IT_fun_err_ne", "IT_ret_err_ne", "new_state_interp"], "remove_type": "abort"}, {"name": "wp_adequacy", "text": "Lemma wp_adequacy cr \u03a3 `{!invGpreS \u03a3} n (rs : gReifiers n) `{!statePreG rs \u03a3} \u03b1 \u03c3 \u03b2v \u03c3' s k (\u03c8 : (ITV (gReifiers_ops rs) natO) \u2192 Prop) : ssteps (gReifiers_sReifier rs) \u03b1 \u03c3 (IT_of_V \u03b2v) \u03c3' k \u2192 (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs \u03a3}, \u2203 \u03a6, NonExpansive \u03a6 \u2227 (\u2200 \u03b2v, \u03a6 \u03b2v \u22a2 \u231c\u03c8 \u03b2v\u231d) \u2227 (\u00a3 cr \u2217 has_full_state \u03c3 \u22a2 WP@{rs} \u03b1 @ s {{ \u03a6 }})%I) \u2192 \u03c8 \u03b2v.", "decomposition": [], "retrieval": ["wp_val_inv", "wp_ssteps", "new_state_interp"], "remove_type": "abort"}, {"name": "IT_error_lem", "text": "Lemma IT_error_lem \u03b1 : \u22a2@{iProp} (\u2203 e, \u03b1 \u2261 Err e) \u2228 \u00ac (\u2203 e, \u03b1 \u2261 Err e).", "decomposition": [], "retrieval": ["IT_vis_err_ne", "IT_tick_err_ne", "IT_dont_confuse", "IT_fun_err_ne", "IT_ret_err_ne"], "remove_type": "abort"}], "theories/gitree/greifiers.v": [{"name": "reify_vis_eqI", "text": "Lemma reify_vis_eqI {A} `{!Cofe A} op i k o \u03c3 \u03c3' : (gReifiers_re rs op (i,\u03c3) \u2261 Some (o,\u03c3') \u22a2@{iProp} reify sr (Vis op i k : IT _ A) \u03c3 \u2261 (\u03c3', Tau $ k o))%I.", "decomposition": [], "retrieval": ["reify_vis_dist"], "remove_type": "abort"}]}, "5b177cb3b592e9df8c162684ca41bec9c55c5571": {}, "147e0d9f59aaffb23ffcc983cc8185a70f6cc7f3": {}, "2abfb431e054f0bbbc72b995c9442d5e5890841c": {}, "5bba9992c0051f8b1871a29512dcf95f51862646": {}, "e951175e715f04e0b651e33e30b81368ff707090": {}, "c27183ca2cd9cbdaa8a9bad853ccacfd1e09db3f": {}, "44dd464aaa3311b14490aa131305d44864743db9": {}, "06717bc1d5458a4ba4d0b01cba4fb1773ea34b0f": {}, "43a90f47b290791cc5a6328d2f993f739a65df5f": {}, "f07661bb4aabe28a7d6c09f7c75fb3ae6925078d": {}, "c0837ca2363c60529a1ac54615831734f9f40d7e": {}, "410b665603368867257c26633ba52b171a95badb": {}, "c840fe3c86477fbd54439e8599529cb5257e9a8b": {}, "83f01e135ac64403f19fe9748fcb16e1d7d2ee5e": {}, "9b442f7bc8217d4189779c9789538065d7690134": {}, "531a4b0c9c75fc43592e0fe5cccbf31020fd1dc9": {}, "93e6dc9d9eecc9624e6f20866b5c52fa6a997e29": {}, "167a7b071803a4a029f34525bb7c4aa2912b2551": {}, "3c34ea1e8ebcbc195243dc297f3d46e4eefb224b": {}, "ddddc3f0878bc70942f1fdd1a65f3a08acaa41cb": {}, "12c70c5c632c04696d2efdc0689b54788eed1edd": {"theories/lang_generic.v": [{"name": "ssubst_valid_fin_lookup1", "text": "Lemma ssubst_valid_fin_lookup1 {S : Set} `{!EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) (\u03b1s : interp_scope S) x : ssubst_valid_fin1 \u03a9 \u03b1s \u22a2 kripke (\u03b1s x) (interp_ty (\u03a9 x)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "ssubst_valid_fin_cons1", "text": "Lemma ssubst_valid_fin_cons1 {S : Set} `{!EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) (\u03b1s : interp_scope S) \u03c4 t : ssubst_valid_fin1 \u03a9 \u03b1s \u2217 kripke t (interp_ty \u03c4) \u22a2 ssubst_valid_fin1 (\u03a9 \u25b9 \u03c4) (extend_scope \u03b1s t).", "decomposition": ["fin_to_set_inc"], "retrieval": [], "remove_type": "abort"}, {"name": "ssubst_valid_fin_app1", "text": "Lemma ssubst_valid_fin_app1 {S1 S2 : Set} `{!EqDecision S1} `{!Finite S1} `{!EqDecision S2} `{!Finite S2} `{!EqDecision (S1 + S2)} `{!Finite (S1 + S2)} (\u03a91 : S1 \u2192 ty) (\u03a92 : S2 \u2192 ty) (\u03b1s : interp_scope (sum S1 S2)) : (ssubst_valid_fin1 (sum_map' \u03a91 \u03a92) \u03b1s) \u22a2 (ssubst_valid_fin1 \u03a91 (interp_scope_split \u03b1s).1) \u2217 (ssubst_valid_fin1 \u03a92 (interp_scope_split \u03b1s).2).", "decomposition": [], "retrieval": ["fin_to_set_sum"], "remove_type": "abort"}, {"name": "ssubst_valid_fin_empty1", "text": "Lemma ssubst_valid_fin_empty1 (\u03b1s : interp_scope \u2205) : \u22a2 ssubst_valid_fin1 \u25a1 \u03b1s.", "decomposition": [], "retrieval": ["fin_to_set_empty"], "remove_type": "abort"}], "theories/utils/finite_sets.v": [{"name": "FiniteRight", "text": "Lemma FiniteRight {S1 S2 : Set} `{EqDecision S2} `{EqDecision (S1 + S2)} `{H : Finite (S1 + S2)} : Finite S2.", "decomposition": [], "retrieval": ["l"], "remove_type": "abort"}, {"name": "FiniteLeft", "text": "Lemma FiniteLeft {S1 S2 : Set} `{EqDecision S1} `{EqDecision (S1 + S2)} `{Finite (S1 + S2)} : Finite S1.", "decomposition": [], "retrieval": ["l"], "remove_type": "abort"}, {"name": "EqDecisionRight", "text": "Lemma EqDecisionRight {S1 S2 : Set} {H : EqDecision (S1 + S2)} : EqDecision S2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "EqDecisionLeft", "text": "Lemma EqDecisionLeft {S1 S2 : Set} {H : EqDecision (S1 + S2)} : EqDecision S1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fin_to_set_inc", "text": "Lemma fin_to_set_inc {S : Set} `{!EqDecision S} `{!Finite S} `{HE : EqDecision (inc S)} `{HF : @Finite (inc S) HE} : fin_to_set (inc S) = ({[VZ]} : gset (inc S)) \u222a (set_map VS (fin_to_set S : gset S)) :> @gset (inc S) HE (@finite_countable _ HE HF).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fin_to_set_empty", "text": "Lemma fin_to_set_empty `{HE : EqDecision \u2205} `{HF : @Finite \u2205 HE} : fin_to_set \u2205 = empty :> @gset \u2205 HE (@finite_countable _ HE HF).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "fin_to_set_sum", "text": "Lemma fin_to_set_sum {S1 S2 : Set} `{!EqDecision S1} `{!EqDecision S2} `{!Finite S1} `{!Finite S2} `{HE : EqDecision (S1 + S2)} `{HF : @Finite (S1 + S2) HE} : fin_to_set (S1 + S2) = (set_map inl (fin_to_set S1 : gset S1)) \u222a (set_map inr (fin_to_set S2 : gset S2)) :> @gset (S1 + S2) HE (@finite_countable _ HE HF).", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/program_logic.v": [{"name": "wp_lam", "text": "Lemma wp_lam (f : IT -n> IT) \u03b2 s \u03a6 `{!AsVal \u03b2} : \u25b7 WP@{rs} f \u03b2 @ s {{ \u03a6 }} \u22a2 WP@{rs} Fun (Next f) \u2299 \u03b2 @ s{{ \u03a6 }}.", "decomposition": [], "retrieval": ["APP'_Fun_l", "Tick_eq"], "remove_type": "abort"}], "theories/gitree/greifiers.v": [{"name": "subReifier_reifyI_ctx_indep", "text": "Lemma subReifier_reifyI_ctx_indep (r : sReifier NotCtxDep) `{!@subReifier sz NotCtxDep r rs} {X} `{!Cofe X} (op : opid (sReifier_ops r)) (x : Ins (sReifier_ops _ op) \u266f X) (y : Outs (sReifier_ops _ op) \u266f X) (\u03c3 \u03c3' : sReifier_state r \u266f X) (rest : gState_rest NotCtxDep sR_idx rs \u266f X) : sReifier_re r op (x,\u03c3) \u2261 Some (y, \u03c3') \u22a2@{iProp} gReifiers_re NotCtxDep rs (subEff_opid op) (subEff_ins x, gState_recomp NotCtxDep rest (sR_state \u03c3)) \u2261 Some (subEff_outs y, gState_recomp NotCtxDep rest (sR_state \u03c3')).", "decomposition": [], "retrieval": ["gReifiers_re_idx", "gState_decomp'"], "remove_type": "abort"}, {"name": "subReifier_reifyI_ctx_dep", "text": "Lemma subReifier_reifyI_ctx_dep (r : sReifier CtxDep) `{!@subReifier sz CtxDep r rs} {X} `{!Cofe X} (op : opid (sReifier_ops r)) (x : Ins (sReifier_ops _ op) \u266f X) (y : laterO X) (k : (Outs (sReifier_ops r op) \u266f X -n> laterO X)) (\u03c3 \u03c3' : sReifier_state r \u266f X) (rest : gState_rest CtxDep sR_idx rs \u266f X) : sReifier_re r op (x,\u03c3, k) \u2261 Some (y, \u03c3') \u22a2@{iProp} gReifiers_re CtxDep rs (subEff_opid op) (subEff_ins x, gState_recomp CtxDep rest (sR_state \u03c3), k \u25ce (subEff_outs ^-1)) \u2261 Some (y, gState_recomp CtxDep rest (sR_state \u03c3')).", "decomposition": [], "retrieval": ["gReifiers_re_idx"], "remove_type": "abort"}, {"name": "subReifier_reify_idxI_ctx_indep", "text": "Lemma subReifier_reify_idxI_ctx_indep (r : sReifier NotCtxDep) `{!@subReifier sz NotCtxDep r rs} {X} `{!Cofe X} (op : opid (sReifier_ops r)) (x : Ins (sReifier_ops _ op) \u266f X) (y : Outs (sReifier_ops _ op) \u266f X) (s1 s2 : sReifier_state r \u266f X) : sReifier_re r op (x, s1) \u2261 Some (y, s2) \u22a2@{iProp} sReifier_re (rs !!! sR_idx) (subEff_opid op) (subEff_ins x, sR_state s1) \u2261 Some (subEff_outs y, sR_state s2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subReifier_reify_idxI_ctx_dep", "text": "Lemma subReifier_reify_idxI_ctx_dep (r : sReifier CtxDep) `{!@subReifier sz CtxDep r rs} {X} `{!Cofe X} (op : opid (sReifier_ops r)) (x : Ins (sReifier_ops _ op) \u266f X) (y : laterO X) (k : (Outs (sReifier_ops r op) \u266f X -n> laterO X)) (s1 s2 : sReifier_state r \u266f X) : sReifier_re r op (x, s1, k) \u2261 Some (y, s2) \u22a2@{iProp} sReifier_re (rs !!! sR_idx) (subEff_opid op) (subEff_ins x, sR_state s1, k \u25ce (subEff_outs ^-1)) \u2261 Some (y, sR_state s2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subReifier_reify", "text": "Lemma subReifier_reify {n} {a : is_ctx_dep} (r : sReifier a) (rs : gReifiers a n) `{!subReifier r rs} {X} `{!Cofe X} (op : opid (sReifier_ops r)) : subReifier_reify_type a r rs X op.", "decomposition": [], "retrieval": ["gReifiers_re_idx", "subReifier_reify_idx", "gState_decomp'"], "remove_type": "abort"}, {"name": "subReifier_reify_idx", "text": "Lemma subReifier_reify_idx {n} {a : is_ctx_dep} (r : sReifier a) (rs : gReifiers a n) `{!subReifier r rs} {X} `{!Cofe X} (op : opid (sReifier_ops r)) : subReifier_reify_idx_type a r rs X op.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "gReifiers_re_idx", "text": "Lemma gReifiers_re_idx {n} a (i : fin n) (rs : gReifiers a n) {X} `{!Cofe X} (op : opid (sReifier_ops (rs !!! i))) (x : Ins (sReifier_ops _ op) \u266f X) (\u03c3 : sReifier_state (rs !!! i) \u266f X) (rest : gState_rest a i rs \u266f X) : gReifiers_re_idx_type a i rs op x \u03c3 rest.", "decomposition": [], "retrieval": ["gReifiers_re_idx_ctx_dep", "gReifiers_re_idx_ctx_indep"], "remove_type": "admit"}, {"name": "gReifiers_re_idx_ctx_indep", "text": "Lemma gReifiers_re_idx_ctx_indep {n} (i : fin n) (rs : gReifiers NotCtxDep n) {X} `{!Cofe X} (op : opid (sReifier_ops (rs !!! i))) (x : Ins (sReifier_ops _ op) \u266f X) (\u03c3 : sReifier_state (rs !!! i) \u266f X) (rest : gState_rest NotCtxDep i rs \u266f X) : gReifiers_re NotCtxDep rs (existT i op) (x, gState_recomp NotCtxDep rest \u03c3) \u2261 optionO_map (prodO_map idfun (gState_recomp NotCtxDep rest)) (sReifier_re (rs !!! i) op (x, \u03c3)).", "decomposition": [], "retrieval": ["gState_decomp_recomp"], "remove_type": "abort"}, {"name": "gReifiers_re_idx_ctx_dep", "text": "Lemma gReifiers_re_idx_ctx_dep {n} (i : fin n) (rs : gReifiers CtxDep n) {X} `{!Cofe X} (op : opid (sReifier_ops (rs !!! i))) (x : Ins (sReifier_ops _ op) \u266f X) (\u03c3 : sReifier_state (rs !!! i) \u266f X) (rest : gState_rest CtxDep i rs \u266f X) (\u03ba : (Outs (sReifier_ops (rs !!! i) op) \u266f X -n> laterO X)) : gReifiers_re CtxDep rs (existT i op) (x, gState_recomp CtxDep rest \u03c3, \u03ba) \u2261 optionO_map (prodO_map idfun (gState_recomp CtxDep rest)) (sReifier_re (rs !!! i) op (x, \u03c3, \u03ba)).", "decomposition": [], "retrieval": ["gState_decomp_recomp"], "remove_type": "abort"}, {"name": "gState_decomp'", "text": "Lemma gState_decomp' {m} (i : fin m) (rs : gReifiers m) {X} `{!Cofe X} : gReifiers_state rs \u266f X \u2243 ((sReifier_state (rs !!! i) \u266f X) * (gState_rest i rs \u266f X))%type.", "decomposition": [], "retrieval": [], "remove_type": "admit"}], "theories/examples/input_lang/logpred.v": [{"name": "io_lang_safety", "text": "Lemma io_lang_safety e \u03c4 \u03c3 st' (\u03b2 : IT (sReifier_ops (gReifiers_sReifier NotCtxDep rs)) natO) k : typed \u25a1 e \u03c4 \u2192 ssteps (gReifiers_sReifier NotCtxDep rs) (interp_expr rs e \u0131_scope) (\u03c3, ()) \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier NotCtxDep rs) \u03b2 st' \u03b21 st1) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["logpred_adequacy", "fundamental"], "remove_type": "abort"}, {"name": "logpred_adequacy", "text": "Lemma logpred_adequacy cr \u03a3 R `{!Cofe R, SubOfe natO R} `{!invGpreS \u03a3} `{!statePreG rs R \u03a3} \u03c4 (\u03b1 : interp_scope \u2205 -n> IT (gReifiers_ops rs) R) (\u03b2 : IT (gReifiers_ops rs) R) st st' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs R \u03a3}, (\u00a3 cr \u22a2 valid1 rs notStuck (\u03bbne _ : unitO, True)%I \u25a1 \u03b1 \u03c4)%I) \u2192 ssteps (gReifiers_sReifier NotCtxDep rs) (\u03b1 \u0131_scope) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier NotCtxDep rs) \u03b2 st' \u03b21 st1) \u2228 (\u2203 \u03b2v, IT_of_V \u03b2v \u2261 \u03b2).", "decomposition": [], "retrieval": ["IT_of_to_V'", "wp_safety", "wp_wand"], "remove_type": "abort"}, {"name": "compat_rec", "text": "Lemma compat_rec {S : Set} (\u0393 : S \u2192 ty) \u03c41 \u03c42 \u03b1 : \u22a2 \u25a1 valid1 (\u0393 \u25b9 (Tarr \u03c41 \u03c42) \u25b9 \u03c41) \u03b1 \u03c42 -\u2217 valid1 \u0393 (interp_rec rs \u03b1) (Tarr \u03c41 \u03c42).", "decomposition": [], "retrieval": ["interp_rec_unfold", "wp_lam", "wp_val", "expr_pred_ret"], "remove_type": "abort"}], "theories/gitree/weakestpre.v": [{"name": "wp_safety", "text": "Lemma wp_safety cr \u03a3 `{!invGpreS \u03a3} n a (rs : gReifiers a n) {A} `{!Cofe A} `{!statePreG rs A \u03a3} s k (\u03b1 \u03b2 : IT (gReifiers_ops rs) A) (\u03c3 \u03c3' : gReifiers_state rs \u266f IT (gReifiers_ops rs) A) : (\u2200 \u03a3 P Q, @disjunction_property \u03a3 P Q) \u2192 ssteps (gReifiers_sReifier a rs) \u03b1 \u03c3 \u03b2 \u03c3' k \u2192 IT_to_V \u03b2 \u2261 None \u2192 (\u2200 `{H1 : !invGS_gen HasLc \u03a3} `{H2: !stateG rs A \u03a3}, \u2203 \u03a6, NonExpansive \u03a6 \u2227 (\u00a3 cr \u2217 has_full_state \u03c3 \u22a2 WP@{rs} \u03b1 @ s {{ \u03a6 }})%I) \u2192 ((\u2203 \u03b21 \u03c31, sstep (gReifiers_sReifier a rs) \u03b2 \u03c3' \u03b21 \u03c31) \u2228 (\u2203 e, \u03b2 \u2261 Err e \u2227 s e)).", "decomposition": [], "retrieval": ["IT_vis_err_ne", "IT_tick_err_ne", "istep_safe_sstep", "wp_ssteps_isafe", "Err_inj'", "IT_dont_confuse", "IT_fun_err_ne", "IT_ret_err_ne", "new_state_interp"], "remove_type": "abort"}, {"name": "wp_adequacy", "text": "Lemma wp_adequacy cr \u03a3 `{!invGpreS \u03a3} n a (rs : gReifiers a n) {A} `{!Cofe A} `{!statePreG rs A \u03a3} (\u03b1 : IT _ A) \u03c3 \u03b2v \u03c3' s k (\u03c8 : (ITV (gReifiers_ops rs) A) \u2192 Prop) : ssteps (gReifiers_sReifier a rs) \u03b1 \u03c3 (IT_of_V \u03b2v) \u03c3' k \u2192 (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs A \u03a3}, \u2203 \u03a6, NonExpansive \u03a6 \u2227 (\u2200 \u03b2v, \u03a6 \u03b2v \u22a2 \u231c\u03c8 \u03b2v\u231d) \u2227 (\u00a3 cr \u2217 has_full_state \u03c3 \u22a2 WP@{rs} \u03b1 @ s {{ \u03a6 }})%I) \u2192 \u03c8 \u03b2v.", "decomposition": [], "retrieval": ["wp_val_inv", "wp_ssteps", "new_state_interp"], "remove_type": "abort"}, {"name": "wp_subreify_ctx_indep", "text": "Lemma wp_subreify_ctx_indep (rs : gReifiers NotCtxDep n) `{!@stateG _ NotCtxDep rs A _ \u03a3} E1 s \u03a6 sR `{!subReifier sR rs} (op : opid (sReifier_ops sR)) (x : Ins (sReifier_ops sR op) \u266f IT NotCtxDep rs) (y : Outs (sReifier_ops sR op) \u266f IT NotCtxDep rs) (k : Outs (F NotCtxDep rs (subEff_opid op)) \u266f IT NotCtxDep rs -n> laterO (IT NotCtxDep rs)) (\u03c3 \u03c3' : sReifier_state sR \u266f IT NotCtxDep rs) \u03b2 : sReifier_re sR op (x, \u03c3) \u2261 Some (y, \u03c3') \u2192 k (subEff_outs y) \u2261 Next \u03b2 \u2192 has_substate NotCtxDep rs \u03c3 -\u2217 \u25b7 (\u00a3 1 -\u2217 has_substate NotCtxDep rs \u03c3' -\u2217 wp NotCtxDep rs \u03b2 s E1 \u03a6) -\u2217 wp NotCtxDep rs (Vis (subEff_opid op) (subEff_ins x) k) s E1 \u03a6.", "decomposition": [], "retrieval": ["reify_vis_eq_ctx_indep", "wp_reify", "subReifier_reify"], "remove_type": "abort"}, {"name": "wp_subreify_ctx_dep", "text": "Lemma wp_subreify_ctx_dep (rs : gReifiers CtxDep n) `{!@stateG _ CtxDep rs A _ \u03a3} E1 s \u03a6 sR `{!subReifier sR rs} (op : opid (sReifier_ops sR)) (x : Ins (sReifier_ops sR op) \u266f IT CtxDep rs) (y : laterO (IT CtxDep rs)) (k : Outs (F CtxDep rs (subEff_opid op)) \u266f IT CtxDep rs -n> laterO (IT CtxDep rs)) (\u03c3 \u03c3' : sReifier_state sR \u266f IT CtxDep rs) \u03b2 : sReifier_re sR op (x, \u03c3, (k \u25ce subEff_outs)) \u2261 Some (y, \u03c3') \u2192 y \u2261 Next \u03b2 \u2192 has_substate CtxDep rs \u03c3 -\u2217 \u25b7 (\u00a3 1 -\u2217 has_substate CtxDep rs \u03c3' -\u2217 wp CtxDep rs \u03b2 s E1 \u03a6) -\u2217 wp CtxDep rs (Vis (subEff_opid op) (subEff_ins x) k) s E1 \u03a6.", "decomposition": [], "retrieval": ["reify_vis_eq_ctx_dep", "wp_reify", "subReifier_reify"], "remove_type": "abort"}, {"name": "wp_subreify_ctx_indep'", "text": "Lemma wp_subreify_ctx_indep' (rs : gReifiers NotCtxDep n) `{!@stateG _ NotCtxDep rs A _ \u03a3} E1 E2 s \u03a6 sR `{!subReifier sR rs} (op : opid (sReifier_ops sR)) (x : Ins (sReifier_ops sR op) \u266f (IT NotCtxDep rs)) (k : Outs (F NotCtxDep rs (subEff_opid op)) \u266f IT NotCtxDep rs -n> laterO (IT NotCtxDep rs)) : (|={E1,E2}=> \u2203 \u03c3 y \u03c3' \u03b2, has_substate NotCtxDep rs \u03c3 \u2217 sReifier_re sR op (x, \u03c3) \u2261 Some (y, \u03c3') \u2217 k (subEff_outs y) \u2261 Next \u03b2 \u2217 \u25b7 (\u00a3 1 -\u2217 has_substate NotCtxDep rs \u03c3' ={E2,E1}=\u2217 wp NotCtxDep rs \u03b2 s E1 \u03a6)) -\u2217 wp NotCtxDep rs (Vis (subEff_opid op) (subEff_ins x) k) s E1 \u03a6.", "decomposition": [], "retrieval": ["subReifier_reify_idxI_ctx_indep", "wp_reify_idx_ctx_indep"], "remove_type": "abort"}, {"name": "wp_subreify_ctx_dep'", "text": "Lemma wp_subreify_ctx_dep' (rs : gReifiers CtxDep n) `{!@stateG _ CtxDep rs A _ \u03a3} E1 E2 s \u03a6 sR `{!subReifier sR rs} (op : opid (sReifier_ops sR)) (x : Ins (sReifier_ops sR op) \u266f (IT CtxDep rs)) (k : Outs (F CtxDep rs (subEff_opid op)) \u266f IT CtxDep rs -n> laterO (IT CtxDep rs)) : (|={E1,E2}=> \u2203 \u03c3 y \u03c3' \u03b2, has_substate CtxDep rs \u03c3 \u2217 sReifier_re sR op (x, \u03c3, (k \u25ce subEff_outs)) \u2261 Some (y, \u03c3') \u2217 y \u2261 Next \u03b2 \u2217 \u25b7 (\u00a3 1 -\u2217 has_substate CtxDep rs \u03c3' ={E2,E1}=\u2217 wp CtxDep rs \u03b2 s E1 \u03a6)) -\u2217 wp CtxDep rs (Vis (subEff_opid op) (subEff_ins x) k) s E1 \u03a6.", "decomposition": [], "retrieval": ["subReifier_reify_idxI_ctx_dep", "wp_reify_idx_ctx_dep"], "remove_type": "abort"}, {"name": "wp_reify_idx_ctx_indep", "text": "Lemma wp_reify_idx_ctx_indep (rs : gReifiers NotCtxDep n) `{!@stateG _ NotCtxDep rs A _ \u03a3} E1 E2 s \u03a6 i (lop : opid (sReifier_ops (rs !!! i))) : let op : opid (F NotCtxDep rs) := (existT i lop) in forall (x : Ins (F NotCtxDep rs op) \u266f IT NotCtxDep rs) (k : Outs (F NotCtxDep rs op) \u266f IT NotCtxDep rs -n> laterO (IT NotCtxDep rs)), (|={E1,E2}=> \u2203 \u03c3 y \u03c3' \u03b2, has_state_idx NotCtxDep rs i \u03c3 \u2217 sReifier_re (rs !!! i) lop (x, \u03c3) \u2261 Some (y, \u03c3') \u2217 k y \u2261 Next \u03b2 \u2217 \u25b7 (\u00a3 1 -\u2217 has_state_idx NotCtxDep rs i \u03c3' ={E2,E1}=\u2217 wp NotCtxDep rs \u03b2 s E1 \u03a6)) -\u2217 wp NotCtxDep rs (Vis op x k) s E1 \u03a6.", "decomposition": [], "retrieval": ["reify_vis_eqI_ctx_indep", "gReifiers_re_idx", "Tick_eq"], "remove_type": "abort"}, {"name": "wp_reify_idx_ctx_dep", "text": "Lemma wp_reify_idx_ctx_dep (rs : gReifiers CtxDep n) `{!@stateG _ CtxDep rs A _ \u03a3} E1 E2 s \u03a6 i (lop : opid (sReifier_ops (rs !!! i))) : let op : opid (F CtxDep rs) := (existT i lop) in forall (x : Ins (F CtxDep rs op) \u266f IT CtxDep rs) (k : Outs (F CtxDep rs op) \u266f IT CtxDep rs -n> laterO (IT CtxDep rs)), (|={E1,E2}=> \u2203 \u03c3 y \u03c3' \u03b2, has_state_idx CtxDep rs i \u03c3 \u2217 sReifier_re (rs !!! i) lop (x, \u03c3, k) \u2261 Some (y, \u03c3') \u2217 y \u2261 Next \u03b2 \u2217 \u25b7 (\u00a3 1 -\u2217 has_state_idx CtxDep rs i \u03c3' ={E2,E1}=\u2217 wp CtxDep rs \u03b2 s E1 \u03a6)) -\u2217 wp CtxDep rs (Vis op x k) s E1 \u03a6.", "decomposition": [], "retrieval": ["gReifiers_re_idx", "reify_vis_eqI_ctx_dep", "Tick_eq"], "remove_type": "abort"}, {"name": "wp_reify", "text": "Lemma wp_reify E1 s \u03a6 i (lop : opid (sReifier_ops (rs !!! i))) x k \u03c3 \u03c3' \u03b2 : let op : opid F := (existT i lop) in (\u2200 rest, reify (Vis op x k) (gState_recomp a rest \u03c3) \u2261 (gState_recomp a rest \u03c3', Tick \u03b2)) \u2192 has_state_idx i \u03c3 -\u2217 \u25b7 (\u00a3 1 -\u2217 has_state_idx i \u03c3' -\u2217 WP \u03b2 @ s;E1 {{ \u03a6 }}) -\u2217 WP (Vis op x k) @ s;E1 {{ \u03a6 }}.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "state_interp_has_state_idx_update", "text": "Lemma state_interp_has_state_idx_update (i : fin n) (\u03c3 \u03c31 \u03c32 : sReifier_state (rs !!! i) \u266f IT) (rest : gState_rest a i rs \u266f IT) `{!stateG \u03a3} : state_interp (gState_recomp a rest \u03c31) -\u2217 has_state_idx i \u03c32 ==\u2217 state_interp (gState_recomp a rest \u03c3) \u2217 has_state_idx i \u03c3.", "decomposition": [], "retrieval": ["of_state_decomp_local_update"], "remove_type": "abort"}, {"name": "state_interp_has_state_idx_agree", "text": "Lemma state_interp_has_state_idx_agree (i : fin n) (\u03c31 \u03c32 : sReifier_state (rs !!! i) \u266f IT) (rest : gState_rest a i rs \u266f IT) `{!stateG \u03a3} : state_interp (gState_recomp a rest \u03c31) -\u2217 has_state_idx i \u03c32 -\u2217 \u03c31 \u2261 \u03c32.", "decomposition": [], "retrieval": ["of_state_of_idx_agree"], "remove_type": "abort"}, {"name": "of_state_decomp_local_update", "text": "Lemma of_state_decomp_local_update i (\u03c3 \u03c31 \u03c32 : sReifier_state (rs !!! i) \u266f X) rest : (of_state (gState_recomp a rest \u03c31), of_idx i \u03c32) ~l~> (of_state (gState_recomp a rest \u03c3), of_idx i \u03c3).", "decomposition": [], "retrieval": ["of_state_recomp_lookup_ne", "of_state_recomp_lookup"], "remove_type": "abort"}, {"name": "of_state_recomp_lookup", "text": "Lemma of_state_recomp_lookup i (\u03c3 : sReifier_state (rs !!! i) \u266f X) rest : of_state (gState_recomp a rest \u03c3) i \u2261 Excl' \u03c3.", "decomposition": [], "retrieval": ["gState_decomp_recomp"], "remove_type": "abort"}, {"name": "of_state_valid", "text": "Lemma of_state_valid (\u03c3 : gReifiers_state rs \u266f X) : \u2713 (of_state \u03c3).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "of_state_recomp_lookup_ne", "text": "Lemma of_state_recomp_lookup_ne {n} (a : is_ctx_dep) (rs : gReifiers a n) (X : ofe) `{!Cofe X} i j (\u03c31 \u03c32 : sReifier_state (rs !!! i) \u266f X) rest : i \u2260 j \u2192 of_state a rs X (gState_recomp a rest \u03c31) j \u2261 of_state a rs X (gState_recomp a rest \u03c32) j.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/examples/affine_lang/logrel1.v": [{"name": "logrel1_adequacy", "text": "Lemma logrel1_adequacy cr \u03a3 R `{!Cofe R, !SubOfe natO R, !SubOfe unitO R, !SubOfe locO R} `{!invGpreS \u03a3} `{!statePreG rs R \u03a3} `{!heapPreG rs R \u03a3} \u03c4 (\u03b1 : interp_scope \u2205 -n> IT (gReifiers_ops rs) R) (\u03b2 : IT (gReifiers_ops rs) R) st st' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs R \u03a3} `{H3: !heapG rs R \u03a3}, (\u00a3 cr \u22a2 valid1 rs notStuck (\u03bbne _: unitO, True)%I \u25a1 \u03b1 \u03c4)%I) \u2192 ssteps (gReifiers_sReifier NotCtxDep rs) (\u03b1 \u0131_scope) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier NotCtxDep rs) \u03b2 st' \u03b21 st1) \u2228 (\u2203 \u03b2v, (IT_of_V \u03b2v \u2261 \u03b2)%stdpp).", "decomposition": ["ssubst_valid_fin_empty1"], "retrieval": ["IT_of_to_V'", "fupd_wp", "wp_safety", "new_heapG", "wp_wand"], "remove_type": "abort"}, {"name": "fundamental_affine", "text": "Lemma fundamental_affine (S : Set) (HE : EqDecision S) (HF : Finite S) (\u03a9 : S \u2192 ty) (e : expr S) \u03c4 : typed \u03a9 e \u03c4 \u2192 \u22a2 valid1 \u03a9 (interp_expr _ e) \u03c4.", "decomposition": ["EqDecisionLeft", "FiniteRight", "FiniteLeft", "EqDecisionRight"], "retrieval": ["compat_var", "compat_app", "compat_unit", "compat_nat", "compat_alloc", "compat_destruct", "compat_lam", "compat_dealloc", "compat_bool", "compat_pair", "compat_replace"], "remove_type": "abort"}, {"name": "compat_app", "text": "Lemma compat_app {S1 S2 : Set} `(!EqDecision S1) `(!Finite S1) `(!EqDecision S2) `(!Finite S2) `{!EqDecision (S1 + S2)} `{!Finite (S1 + S2)} (\u03a91 : S1 \u2192 ty) (\u03a92 : S2 \u2192 ty) \u03b1 \u03b2 \u03c41 \u03c42 : \u22a2 valid1 \u03a91 \u03b1 (tArr \u03c41 \u03c42) -\u2217 valid1 \u03a92 \u03b2 \u03c41 -\u2217 valid1 (sum_map' \u03a91 \u03a92) (interp_app \u03b1 \u03b2 \u25ce interp_scope_split) \u03c42.", "decomposition": ["ssubst_valid_fin_app1"], "retrieval": ["LET_Val", "expr_pred_bind"], "remove_type": "admit"}, {"name": "compat_var", "text": "Lemma compat_var {S : Set} `{!EqDecision S} `{!Finite S} \u03a9 (v : S) : \u22a2 valid1 \u03a9 (Force \u25ce interp_var v) (\u03a9 v).", "decomposition": ["ssubst_valid_fin_lookup1"], "retrieval": ["wp_val", "wp_bind", "IT_of_V_Ret", "wp_wand"], "remove_type": "abort"}, {"name": "compat_dealloc", "text": "Lemma compat_dealloc {S : Set} `{!EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) \u03b1 \u03c4: \u22a2 valid1 \u03a9 \u03b1 (tRef \u03c4) -\u2217 valid1 \u03a9 (interp_dealloc \u03b1) tUnit.", "decomposition": [], "retrieval": ["expr_pred_frame", "l", "get_ret_ret", "IT_of_V_Ret", "expr_pred_bind", "wp_dealloc"], "remove_type": "abort"}, {"name": "compat_replace", "text": "Lemma compat_replace {S1 S2 : Set} `(!EqDecision S1) `(!Finite S1) `(!EqDecision S2) `(!Finite S2) `{!EqDecision (S1 + S2)} `{!Finite (S1 + S2)} (\u03a91 : S1 \u2192 ty) (\u03a92 : S2 \u2192 ty) \u03b1 \u03b2 \u03c4 \u03c4' : \u22a2 valid1 \u03a91 \u03b1 (tRef \u03c4) -\u2217 valid1 \u03a92 \u03b2 \u03c4' -\u2217 valid1 (sum_map' \u03a91 \u03a92) (interp_replace \u03b1 \u03b2 \u25ce interp_scope_split) (tPair \u03c4 (tRef \u03c4')).", "decomposition": ["ssubst_valid_fin_app1"], "retrieval": ["wp_seq", "wp_write", "wp_val", "expr_pred_frame", "l", "get_val_ITV", "LET_Val", "get_ret_ret", "wp_let", "IT_of_V_Ret", "expr_pred_bind", "wp_read"], "remove_type": "admit"}], "theories/examples/input_lang/interp.v": [{"name": "soundness", "text": "Lemma soundness {S} (e1 e2 : expr S) \u03c31 \u03c32 (\u03c3r : gState_rest NotCtxDep sR_idx rs \u266f IT) n m (env : interp_scope S) : prim_step e1 \u03c31 e2 \u03c32 (n,m) \u2192 ssteps (gReifiers_sReifier NotCtxDep rs) (interp_expr e1 env) (gState_recomp NotCtxDep \u03c3r (sR_state \u03c31)) (interp_expr e2 env) (gState_recomp NotCtxDep \u03c3r (sR_state \u03c32)) n.", "decomposition": [], "retrieval": ["head_step_no_io", "interp_expr_fill_no_reify", "hom_INPUT", "interp_comp", "get_ret_ret", "interp_expr_fill_yes_reify", "ssteps_tick_n", "hom_OUTPUT_", "head_step_io_01"], "remove_type": "abort"}, {"name": "interp_rec_unfold", "text": "Lemma interp_rec_unfold {S : Set} (body : interp_scope (inc (inc S)) -n> IT) env : interp_rec body env \u2261 Fun $ Next $ ir_unf body env.", "decomposition": [], "retrieval": ["laterO_map_Next", "mmuu_unfold"], "remove_type": "abort"}], "theories/examples/affine_lang/logrel2.v": [{"name": "logrel2_adequacy", "text": "Lemma logrel2_adequacy (cr : nat) R `{!Cofe R, !SubOfe locO R, !SubOfe natO R, !SubOfe unitO R} \u03a3 `{!invGpreS \u03a3}`{!statePreG rs R \u03a3} `{!heapPreG rs R \u03a3} `{!na_invG \u03a3} (\u03c4 : ty) (\u03b1 : interp_scope Empty_set -n> IT (gReifiers_ops rs) R) (\u03b2 : IT (gReifiers_ops rs) R) st st' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs R \u03a3} `{H3: !heapG rs R \u03a3} p, (\u00a3 cr \u22a2 valid2 rs p \u25a1 \u03b1 \u03c4)%I) \u2192 ssteps (gReifiers_sReifier NotCtxDep rs) (\u03b1 \u0131_scope) st \u03b2 st' k \u2192 (\u2203 \u03b21 st1, sstep (gReifiers_sReifier NotCtxDep rs) \u03b2 st' \u03b21 st1) \u2228 (\u03b2 \u2261 Err OtherError)%stdpp \u2228 (\u2203 \u03b2v, (IT_of_V \u03b2v \u2261 \u03b2)%stdpp).", "decomposition": ["ssubst_valid_fin_empty1"], "retrieval": ["IT_of_to_V'", "fupd_wp", "wp_safety", "new_heapG", "wp_wand"], "remove_type": "abort"}, {"name": "fundamental_affine_glued", "text": "Lemma fundamental_affine_glued {S : Set} `{HE : EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) (e : expr S) \u03c4 : typed_glued \u03a9 e \u03c4 \u2192 \u22a2 valid2 \u03a9 (interp_expr _ e) \u03c4.", "decomposition": ["EqDecisionLeft", "FiniteRight", "FiniteLeft", "EqDecisionRight"], "retrieval": ["compat_var", "compat_app", "glue_to_affine_compatibility", "compat_unit", "compat_nat", "compat_alloc", "fundamental", "compat_destruct", "compat_lam", "compat_dealloc", "compat_bool", "compat_pair", "compat_replace"], "remove_type": "abort"}, {"name": "glue_to_affine_compatibility", "text": "Lemma glue_to_affine_compatibility {S : Set} `{HE : EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) (\u03c41 : ty) (\u03c41' : io_lang.ty) (Hconv : ty_conv \u03c41 \u03c41') \u03b1 : io_valid \u25a1 \u03b1 \u03c41' \u22a2 valid2 \u03a9 (constO (glue_to_affine _ Hconv (\u03b1 \u0131_scope))) \u03c41 with glue_from_affine_compatibility (\u03c41 : ty) (\u03c41' : io_lang.ty) (Hconv : ty_conv \u03c41 \u03c41') (\u03b1 : IT) : valid2 \u25a1 (constO \u03b1) \u03c41 \u22a2 heap_ctx -\u2217 io_valid \u25a1 (constO (glue_from_affine _ Hconv \u03b1)) \u03c41'.", "decomposition": [], "retrieval": ["compat_glue_from_affine_fun", "compat_unit", "compat_glue_from_affine_unit", "compat_glue_to_affine_fun", "compat_glue_to_affine_nat", "compat_glue_to_affine_bool", "compat_glue_from_affine_nat", "compat_glue_from_affine_bool"], "remove_type": "abort"}, {"name": "compat_glue_to_affine_fun", "text": "Lemma compat_glue_to_affine_fun {S : Set} `{HE : EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) (\u03c41 \u03c42 : ty) (\u03c41' \u03c42' : io_lang.ty) \u03b1 (glue_to_affine glue_from_affine : IT -n> IT) : (\u2200 \u03b1, io_valid \u25a1 \u03b1 \u03c42' \u22a2 valid2 \u03a9 (constO (glue_to_affine (\u03b1 \u0131_scope))) \u03c42) \u2192 (\u2200 \u03b1, valid2 \u25a1 (constO \u03b1) \u03c41 \u22a2 heap_ctx -\u2217 io_valid \u25a1 (constO (glue_from_affine \u03b1)) \u03c41') \u2192 io_valid \u25a1 \u03b1 (Tarr (Tarr Tnat \u03c41') \u03c42') \u22a2 valid2 \u03a9 (constO (glue_to_affine_fun _ glue_from_affine glue_to_affine (\u03b1 \u0131_scope))) (tArr \u03c41 \u03c42).", "decomposition": [], "retrieval": ["wp_seq", "wp_write", "wp_read_atomic", "wp_val", "wp_Thunk", "IF_True", "fupd_wp", "wp_lam", "wp_bind", "wp_err", "wp_write_atomic", "IF_False", "expr_pred_ret", "wp_let", "l", "wp_read", "wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_from_affine_fun", "text": "Lemma compat_glue_from_affine_fun (\u03c41 \u03c42 : ty) (\u03c41' \u03c42' : io_lang.ty) \u03b1 (glue_to_affine glue_from_affine : IT -n> IT) : (\u2200 \u03b1, io_valid \u25a1 \u03b1 \u03c41' \u22a2 valid2 \u25a1 (constO (glue_to_affine (\u03b1 \u0131_scope))) \u03c41) \u2192 (\u2200 \u03b1, valid2 \u25a1 (constO \u03b1) \u03c42 \u22a2 heap_ctx -\u2217 io_valid \u25a1 (constO (glue_from_affine \u03b1)) \u03c42') \u2192 valid2 \u25a1 (constO \u03b1) (tArr \u03c41 \u03c42) \u22a2 heap_ctx -\u2217 io_valid \u25a1 (constO (glue_from_affine_fun _ glue_from_affine glue_to_affine \u03b1)) (Tarr (Tarr Tnat \u03c41') \u03c42').", "decomposition": ["ssubst_valid_fin_empty1"], "retrieval": ["wp_seq", "wp_write", "l", "wp_val", "wp_Thunk", "IF_True", "fupd_wp", "wp_err", "wp_bind", "IF_False", "wp_read", "wp_let", "expr_pred_ret", "wp_lam", "wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_from_affine_nat", "text": "Lemma compat_glue_from_affine_nat \u03b1 : valid2 \u25a1 \u03b1 tInt \u22a2 heap_ctx -\u2217 io_valid \u25a1 \u03b1 Tnat.", "decomposition": ["ssubst_valid_fin_empty1"], "retrieval": ["wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_from_affine_bool", "text": "Lemma compat_glue_from_affine_bool \u03b1 : valid2 \u25a1 \u03b1 tBool \u22a2 heap_ctx -\u2217 io_valid \u25a1 \u03b1 Tnat.", "decomposition": ["ssubst_valid_fin_empty1"], "retrieval": ["wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_to_affine_nat", "text": "Lemma compat_glue_to_affine_nat {S : Set} `{HE : EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) \u03b1 : io_valid \u25a1 \u03b1 Tnat \u22a2 valid2 \u03a9 (constO (\u03b1 \u0131_scope)) tInt.", "decomposition": [], "retrieval": ["wp_wand"], "remove_type": "abort"}, {"name": "compat_glue_to_affine_bool", "text": "Lemma compat_glue_to_affine_bool {S : Set} `{HE : EqDecision S} `{!Finite S} (\u03a9 : S \u2192 ty) \u03b1 : io_valid \u25a1 \u03b1 Tnat \u22a2 valid2 \u03a9 (constO (glue2_bool _ (\u03b1 \u0131_scope))) tBool.", "decomposition": [], "retrieval": ["wp_val", "IF_False", "IF_True", "wp_bind", "wp_wand"], "remove_type": "abort"}], "theories/effects/store.v": [{"name": "wp_alloc", "text": "Lemma wp_alloc (\u03b1 : IT) (k : locO -n> IT) s \u03a6 `{!NonExpansive \u03a6} : heap_ctx -\u2217 \u25b7\u25b7 (\u2200 l, pointsto l \u03b1 -\u2217 WP@{rs} k l @ s {{ \u03a6 }}) -\u2217 WP@{rs} ALLOC \u03b1 k @ s {{ \u03a6 }}.", "decomposition": [], "retrieval": ["l", "wp_subreify_ctx_indep'", "istate_alloc"], "remove_type": "abort"}], "theories/gitree/reductions.v": [{"name": "istep_hom_inv", "text": "Lemma istep_hom_inv \u03b1 \u03c3 \u03b2 \u03c3' (f : IT \u2192 IT) `{!IT_hom f} : istep r (f \u03b1) \u03c3 \u03b2 \u03c3' \u22a2@{iProp} \u231cis_Some (IT_to_V \u03b1)\u231d \u2228 (IT_to_V \u03b1 \u2261 None \u2227 \u2203 \u03b1', istep r \u03b1 \u03c3 \u03b1' \u03c3' \u2227 \u25b7 (\u03b2 \u2261 f \u03b1')).", "decomposition": [], "retrieval": ["IT_to_V_Ret", "Vis_inj_op'", "IT_dont_confuse", "IT_to_V_Vis", "IT_to_V_Tau", "istep_err", "Vis_inj'", "reify_input_cont_inv", "IT_tick_vis_ne", "istep_tick", "IT_to_V_Fun"], "remove_type": "abort"}, {"name": "isteps_tick", "text": "Lemma isteps_tick \u03b1 \u03b2v \u03c3 \u03c3' k : isteps (Tick \u03b1) \u03c3 (IT_of_V \u03b2v) \u03c3' k \u22a2 \u2203 k' : nat, \u231ck = (1 + k')%nat\u231d \u2227 \u25b7 isteps \u03b1 \u03c3 (IT_of_V \u03b2v) \u03c3' k'.", "decomposition": [], "retrieval": ["IT_fun_tick_ne", "isteps_unfold", "istep_tick", "IT_ret_tick_ne"], "remove_type": "abort"}, {"name": "istep_safe_disj", "text": "Local Lemma istep_safe_disj \u03b1 \u03c3 : (\u2203 \u03b2 \u03c3', istep \u03b1 \u03c3 \u03b2 \u03c3') \u22a2 (\u2203 \u03b2 \u03c3', \u03b1 \u2261 Tick \u03b2 \u2227 \u03c3 \u2261 \u03c3') \u2228 (\u2203 \u03b2 \u03c3', (\u2203 op i k, \u03b1 \u2261 Vis op i k \u2227 reify r \u03b1 \u03c3 \u2261 (\u03c3', Tick \u03b2))).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "effect_safe_externalize", "text": "Local Lemma effect_safe_externalize (\u03b1 : IT) \u03c3 : (\u22a2 \u2203 \u03b2 \u03c3', (\u2203 op i k, \u03b1 \u2261 Vis op i k \u2227 reify r \u03b1 \u03c3 \u2261 (\u03c3', Tick \u03b2)) : iProp) \u2192 \u2203 \u03b2 \u03c3', sstep r \u03b1 \u03c3 \u03b2 \u03c3'.", "decomposition": [], "retrieval": ["IT_vis_err_ne", "IT_tick_err_ne", "IT_dont_confuse", "reify_is_always_a_tick", "IT_ret_vis_ne", "IT_fun_vis_ne", "IT_tick_vis_ne"], "remove_type": "abort"}], "theories/lib/factorial.v": [{"name": "wp_fact_io", "text": "Lemma wp_fact_io (n : nat) : heap_ctx \u2217 has_substate (State [n] []) \u22a2 WP@{rs} get_ret OUTPUT fact_io {{ _, has_substate (State [] [fact n]) }}.", "decomposition": [], "retrieval": ["wp_input", "wp_bind", "get_ret_ret", "wp_output", "wp_fact_imp", "wp_wand"], "remove_type": "abort"}, {"name": "wp_fact_imp_bod", "text": "Lemma wp_fact_imp_bod n m acc \u2113 : heap_ctx -\u2217 pointsto acc (Ret m) -\u2217 pointsto \u2113 (Ret n) -\u2217 WP@{rs} fact_imp_body acc \u2113 {{ _, pointsto acc (Ret (m * fact n)) }}.", "decomposition": [], "retrieval": ["wp_seq", "wp_write", "wp_val", "IF_False", "IF_True", "wp_bind", "wp_let", "WHILE_eq", "IT_of_V_Ret", "NATOP_Ret", "wp_read", "wp_wand"], "remove_type": "abort"}], "theories/examples/input_lang/logrel.v": [{"name": "logrel_nat_adequacy", "text": "Lemma logrel_nat_adequacy \u03a3 `{!invGpreS \u03a3}`{!statePreG rs natO \u03a3} {S} (\u03b1 : IT (gReifiers_ops rs) natO) (e : expr S) n \u03c3 \u03c3' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs natO \u03a3}, (True \u22a2 logrel rs Tnat \u03b1 e)%I) \u2192 ssteps (gReifiers_sReifier NotCtxDep rs) \u03b1 (\u03c3,()) (Ret n) \u03c3' k \u2192 \u2203 m \u03c3', prim_steps e \u03c3 (Val $ LitV n) \u03c3' m.", "decomposition": [], "retrieval": ["l", "wp_adequacy", "IT_of_V_Ret", "IT_ret_fun_ne", "wp_wand", "Ret_inj'"], "remove_type": "abort"}, {"name": "compat_recV", "text": "Lemma compat_recV {S : Set} (\u0393 : S -> ty) (e : expr (inc (inc S))) \u03c41 \u03c42 \u03b1 : \u22a2 \u25a1 logrel_valid ((\u0393 \u25b9 (Tarr \u03c41 \u03c42) \u25b9 \u03c41)) e \u03b1 \u03c42 -\u2217 logrel_valid \u0393 (Val $ RecV e) (interp_rec rs \u03b1) (Tarr \u03c41 \u03c42).", "decomposition": [], "retrieval": ["logrel_step_pure", "Ectx_step'", "APP_APP'_ITV", "Tick_eq", "interp_rec_unfold", "APP_Fun", "logrel_of_val", "bind_bind_comp'", "laterO_map_Next"], "remove_type": "abort"}], "theories/examples/input_lang_callcc/hom.v": [{"name": "HOM_compose_ccompose", "text": "Lemma HOM_compose_ccompose (f g h : HOM) : h = HOM_compose f g -> `f \u25ce `g = `h.", "decomposition": [], "retrieval": [], "remove_type": "abort"}], "theories/examples/input_lang_callcc/logrel.v": [{"name": "logrel_nat_adequacy", "text": "Lemma logrel_nat_adequacy \u03a3 `{!invGpreS \u03a3} `{!statePreG rs natO \u03a3} {S} (\u03b1 : IT (gReifiers_ops rs) natO) (e : expr S) n \u03c3 \u03c3' k : (\u2200 `{H1 : !invGS \u03a3} `{H2: !stateG rs natO \u03a3}, (\u22a2 logrel rs Tnat \u03b1 e)%I) \u2192 ssteps (gReifiers_sReifier CtxDep rs) \u03b1 (\u03c3, ()) (Ret n) \u03c3' k \u2192 \u2203 m \u03c3', prim_steps e \u03c3 (Val $ LitV n) \u03c3' m.", "decomposition": [], "retrieval": ["l", "wp_val", "wp_adequacy", "IT_of_V_Ret", "IT_ret_fun_ne", "wp_wand", "Ret_inj'"], "remove_type": "abort"}, {"name": "fundamental", "text": "Lemma fundamental {S : Set} (\u0393 : S -> ty) \u03c4 e : typed \u0393 e \u03c4 \u2192 \u22a2 logrel_valid \u0393 e (interp_expr rs e) \u03c4 with fundamental_val {S : Set} (\u0393 : S -> ty) \u03c4 v : typed_val \u0393 v \u03c4 \u2192 \u22a2 logrel_valid \u0393 (Val v) (interp_val rs v) \u03c4.", "decomposition": [], "retrieval": ["compat_output", "compat_var", "compat_app", "compat_nat", "compat_natop", "compat_callcc", "compat_if", "compat_throw", "compat_input", "compat_recV"], "remove_type": "abort"}], "theories/examples/input_lang_callcc/interp.v": [{"name": "soundness", "text": "Lemma soundness {S} (e1 e2 : expr S) \u03c31 \u03c32 (\u03c3r : gState_rest CtxDep sR_idx rs \u266f IT) n m (env : interp_scope S) : prim_step e1 \u03c31 e2 \u03c32 (n,m) \u2192 ssteps (gReifiers_sReifier CtxDep rs) (interp_expr e1 env) (gState_recomp CtxDep \u03c3r (sR_state \u03c31)) (interp_expr e2 env) (gState_recomp CtxDep \u03c3r (sR_state \u03c32)) n.", "decomposition": [], "retrieval": ["get_fun_fun", "head_step_no_io", "interp_expr_fill_no_reify", "get_val_ITV", "subReifier_reify", "hom_INPUT", "interp_expr_subst", "Tick_eq", "interp_comp", "get_ret_ret", "interp_expr_fill_yes_reify", "ssteps_tick_n", "hom_OUTPUT_", "reify_vis_eq_ctx_dep", "head_step_io_01"], "remove_type": "abort"}]}, "0487b73567509d981763ffe66b23b989bcf5250d": {}, "4a128e7f48e00b71134e2b95b35aaa643f4df1d1": {}, "b2c94538a8dbfc69bf3b98060eb8f9b54cc29849": {}, "426db0a6e6a750e8a56c27cefe78453e45abecef": {}, "aa9ae7affe91d1b6df0fbb177b2f2c89098b0a21": {}, "15dc2a2a569306f80383caeb3f68e6f091efce32": {}, "baf658c3a7b633466e6af366b964857e7d2ca40d": {}, "6ce529968185ef2ad2561a1daaf27d60ffd8c293": {}, "179a0f0bb08e0b31862692b5bc7d5ca520184e66": {}, "0a1c1775edd38608c1331f9d5499698256a2e93d": {}, "f7badce82922e5a4e877ed8fe3903402054cb6da": {}, "5e7f4947b7ada99c97fcb07703570fe0922a6b79": {}, "df0417f16a8255ef7d155a06bfc55a27fe595d17": {}, "41a300e4605f2cc9520028199a727cff9bd61415": {}}