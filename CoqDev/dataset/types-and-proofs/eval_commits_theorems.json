{"ae67b5a649162f7cade8dab214310e95254d5ab1": {"pub/stlc_refb_effb_equiv_beta.v": [{"name": "stchain_refl", "text": "Lemma stchain_refl: forall M, st_chain M M.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stchain_extend", "text": "Lemma stchain_extend: forall M, stty_wellformed M -> st_chain M (st_extend M).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stchain_pad", "text": "Lemma stchain_pad: forall L1 L2 M, st_chain M (st_pad L1 L2 M).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stchain_pad'", "text": "Lemma stchain_pad': forall L1 L2 M, st_chain (st_pad L1 L2 M) M.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stchain_chain'", "text": "Lemma stchain_chain': forall M1 M2 M3, st_chain M1 M2 -> st_chain M2 M3 -> st_chain M1 M3.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stchain_chain", "text": "Lemma stchain_chain: forall M1 M2 M3, st_chain M1 M2 -> st_chain M2 M3 -> st_chain M1 M3.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "envt_empty", "text": "Lemma envt_empty: env_type st_empty [] [] [].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "envt_extend", "text": "Lemma envt_extend: forall M H1 H2 G v1 v2 T1, env_type M H1 H2 G -> val_type M v1 v2 T1 -> env_type M (v1::H1) (v2::H2) (T1::G).", "decomposition": [], "retrieval": ["indexr_skip", "indexr_head"], "remove_type": "abort"}, {"name": "sttyw_empty", "text": "Lemma sttyw_empty: stty_wellformed st_empty.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "storet_empty", "text": "Lemma storet_empty: store_type [] [] st_empty .", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sttyw_extend", "text": "Lemma sttyw_extend: forall M, stty_wellformed M -> stty_wellformed (st_extend M).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "storet_extend", "text": "Lemma storet_extend: forall S1 S2 M vx1 vx2, store_type S1 S2 M -> val_type M vx1 vx2 TBool -> store_type (vx1 :: S1) (vx2 :: S2) (st_extend M).", "decomposition": [], "retrieval": ["indexr_skip", "indexr_head"], "remove_type": "abort"}, {"name": "sttyw_pad", "text": "Lemma sttyw_pad: forall L1 L2 M, stty_wellformed M -> stty_wellformed (st_pad L1 L2 M).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "storet_pad", "text": "Lemma storet_pad: forall SD1 SD2 S1 S2 M, store_type S1 S2 M -> store_type (SD1++S1) (SD2++S2) (st_pad (length SD1) (length SD2) M).", "decomposition": [], "retrieval": ["indexr_skips", "indexr_var_some'"], "remove_type": "abort"}, {"name": "storet_update", "text": "Lemma storet_update: forall S1 S2 M l1 l2 vx1 vx2, stty_wellformed M -> store_type S1 S2 M -> strel M l1 l2 -> val_type M vx1 vx2 TBool -> store_type (update S1 l1 vx1) (update S2 l2 vx2) M.", "decomposition": [], "retrieval": ["update_indexr_hit", "update_length", "update_indexr_miss"], "remove_type": "abort"}, {"name": "valt_store_extend'", "text": "Lemma valt_store_extend': forall M M' vx1 vx2 T, val_type M vx1 vx2 T -> st_chain M M' -> val_type M' vx1 vx2 T.", "decomposition": [], "retrieval": ["stchain_chain'"], "remove_type": "abort"}, {"name": "envt_store_extend", "text": "Lemma envt_store_extend: forall M M' H1 H2 G, env_type M H1 H2 G -> st_chain M M' -> env_type M' H1 H2 G.", "decomposition": [], "retrieval": ["valt_store_extend'"], "remove_type": "abort"}, {"name": "valt_store_extend", "text": "Lemma valt_store_extend: forall M M' vx1 vx2 T, val_type M vx1 vx2 T -> st_chain M M' -> val_type M' vx1 vx2 T.", "decomposition": [], "retrieval": ["valt_store_extend'"], "remove_type": "abort"}, {"name": "exp_sub_eff", "text": "Lemma exp_sub_eff: forall M H1 H2 t1 t2 T, exp_type_pure M H1 H2 t1 t2 T -> stty_wellformed M -> forall S1 S2, store_type S1 S2 M -> exp_type S1 S2 M H1 H2 t1 t2 T.", "decomposition": ["storet_pad", "stchain_pad", "sttyw_pad"], "retrieval": ["valt_store_extend"], "remove_type": "abort"}, {"name": "exp_true", "text": "Lemma exp_true: forall M H1 H2, exp_type_pure M H1 H2 ttrue ttrue TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_false", "text": "Lemma exp_false: forall M H1 H2, exp_type_pure M H1 H2 tfalse tfalse TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_var", "text": "Lemma exp_var: forall M H1 H2 x1 x2 v1 v2 T, indexr x1 H1 = Some v1 -> indexr x2 H2 = Some v2 -> val_type M v1 v2 T -> exp_type_pure M H1 H2 (tvar x1) (tvar x2) T.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_ref", "text": "Lemma exp_ref: forall S1 S2 M H1 H2 t1 t2, exp_type S1 S2 M H1 H2 t1 t2 TBool -> exp_type S1 S2 M H1 H2 (tref t1) (tref t2) TRef.", "decomposition": ["sttyw_extend"], "retrieval": ["stchain_extend", "storet_extend", "stchain_chain"], "remove_type": "abort"}, {"name": "exp_get", "text": "Lemma exp_get: forall S1 S2 M H1 H2 t1 t2, exp_type S1 S2 M H1 H2 t1 t2 TRef -> exp_type S1 S2 M H1 H2 (tget t1) (tget t2) TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_put", "text": "Lemma exp_put: forall S1 S2 M S1' S2' M' H1 H2 t1 t2 t1' t2', exp_type1 S1 S2 M H1 H2 t1 t2 S1' S2' M' TRef -> exp_type S1' S2' M' H1 H2 t1' t2' TBool -> exp_type S1 S2 M H1 H2 (tput t1 t1') (tput t2 t2') TBool.", "decomposition": [], "retrieval": ["storet_update", "valt_store_extend", "stchain_chain"], "remove_type": "abort"}, {"name": "exp_app_pure", "text": "Lemma exp_app_pure: forall M H1 H2 f1 f2 t1 t2 T1 T2, exp_type_pure M H1 H2 f1 f2 (TFun T1 T2 false) -> exp_type_pure M H1 H2 t1 t2 T1 -> exp_type_pure M H1 H2 (tapp f1 t1) (tapp f2 t2) T2.", "decomposition": [], "retrieval": ["stchain_refl"], "remove_type": "abort"}, {"name": "exp_app", "text": "Lemma exp_app: forall S1 S2 M S1' S2' M' H1 H2 f1 f2 t1 t2 T1 T2, exp_type1 S1 S2 M H1 H2 f1 f2 S1' S2' M' (TFun T1 T2 true) -> exp_type S1' S2' M' H1 H2 t1 t2 T1 -> exp_type S1 S2 M H1 H2 (tapp f1 t1) (tapp f2 t2) T2.", "decomposition": [], "retrieval": ["stchain_chain'"], "remove_type": "abort"}, {"name": "exp_abs_pure", "text": "Lemma exp_abs_pure: forall M H1 H2 t1 t2 T1 T2, (forall M' vx1 vx2, st_chain M M' -> val_type M' vx1 vx2 T1 -> exp_type_pure M' (vx1 :: H1) (vx2 :: H2) t1 t2 T2) -> exp_type_pure M H1 H2 (tabs t1) (tabs t2) (TFun T1 T2 false).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_abs", "text": "Lemma exp_abs: forall M H1 H2 t1 t2 T1 T2, (forall S1' S2' M' vx1 vx2, st_chain M M' -> stty_wellformed M' -> store_type S1' S2' M' -> val_type M' vx1 vx2 T1 -> exp_type S1' S2' M' (vx1 :: H1) (vx2 :: H2) t1 t2 T2) -> exp_type_pure M H1 H2 (tabs t1) (tabs t2) (TFun T1 T2 true).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_sub_fun_eff1", "text": "Lemma exp_sub_fun_eff1: forall S1 S2 M S1' S2' M' H1 H2 t1 t2 T1 T2 e, exp_type1 S1 S2 M H1 H2 t1 t2 S1' S2' M' (TFun T1 T2 e) -> exp_type1 S1 S2 M H1 H2 t1 t2 S1' S2' M' (TFun T1 T2 true).", "decomposition": ["exp_sub_eff"], "retrieval": [], "remove_type": "abort"}, {"name": "exp_sub_fun_eff", "text": "Lemma exp_sub_fun_eff: forall S1 S2 M H1 H2 t1 t2 T1 T2 e, exp_type S1 S2 M H1 H2 t1 t2 (TFun T1 T2 e) -> exp_type S1 S2 M H1 H2 t1 t2 (TFun T1 T2 true).", "decomposition": ["exp_sub_eff"], "retrieval": [], "remove_type": "abort"}, {"name": "fundamental", "text": "Theorem fundamental: forall G t T e, has_type G t T e -> sem_type_eff G t t T e.", "decomposition": ["exp_app_pure", "exp_sub_fun_eff", "exp_sub_eff", "exp_put", "exp_get", "exp_abs_pure", "exp_ref"], "retrieval": ["exp_true", "exp_var", "exp_app", "envt_store_extend", "envt_extend", "exp_false", "exp_abs"], "remove_type": "abort"}, {"name": "safety", "text": "Corollary safety: forall t T e, has_type [] t T e -> exp_type [] [] st_empty [] [] t t T.", "decomposition": ["sttyw_empty"], "retrieval": ["fundamental", "storet_empty", "envt_empty"], "remove_type": "abort"}, {"name": "safety_pure", "text": "Corollary safety_pure: forall t T, has_type [] t T false -> exp_type_pure st_empty [] [] t t T.", "decomposition": [], "retrieval": ["fundamental", "envt_empty"], "remove_type": "abort"}, {"name": "congr", "text": "Theorem congr: forall C G1 T1 e1 G2 T2 e2, ctx_type C G1 T1 e1 G2 T2 e2 -> sem_ctx_type C C G1 T1 e1 G2 T2 e2.", "decomposition": ["exp_app_pure", "exp_sub_eff", "exp_abs_pure", "exp_sub_fun_eff1"], "retrieval": ["fundamental", "exp_app", "envt_store_extend", "exp_abs", "envt_extend"], "remove_type": "abort"}, {"name": "adequacy", "text": "Lemma adequacy: forall t t' e, sem_type_eff [] t t' TBool e -> exists S S' v, tevaln [] [] t S v /\\ tevaln [] [] t' S' v.", "decomposition": ["sttyw_empty"], "retrieval": ["storet_empty", "envt_empty"], "remove_type": "abort"}, {"name": "soundess", "text": "Theorem soundess: forall G t1 t2 T e, sem_type_eff G t1 t2 T e -> contextual_equiv G t1 t2 T e.", "decomposition": [], "retrieval": ["adequacy"], "remove_type": "abort"}, {"name": "store_invariance", "text": "Theorem store_invariance : forall t G T (W: sem_type_eff G t t T false), forall H1 H2 M, env_type M H1 H2 G -> exists v1 v2 SD1 SD2, (forall S1 : stor, tevaln S1 H1 t (SD1 ++ S1) v1) /\\ (forall S2 : stor, tevaln S2 H2 t (SD2 ++ S2) v2) /\\ val_type M v1 v2 T.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "pure_typing_ex1", "text": "Lemma pure_typing_ex1 : forall G, sem_type_pure G (tget (tref ttrue)) (tget (tref ttrue)) TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "splice_acc", "text": "Lemma splice_acc: forall e1 a b c, splice_tm (splice_tm e1 a b) a c = splice_tm e1 a (c+b).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "splice_zero", "text": "Lemma splice_zero: forall e1 a, (splice_tm e1 a 0) = e1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "indexr_splice_gt", "text": "Lemma indexr_splice_gt: forall{X} x (G1 G3: list X) T , indexr x (G3 ++ G1) = Some T -> x >= length G1 -> forall G2, indexr (x + (length G2))(G3 ++ G2 ++ G1) = Some T.", "decomposition": [], "retrieval": ["indexr_var_some'"], "remove_type": "abort"}, {"name": "indexr_splice", "text": "Lemma indexr_splice: forall{X} (H2' H2 HX: list X) x, indexr (if x <? length H2 then x else x + length HX) (H2' ++ HX ++ H2) = indexr x (H2' ++ H2).", "decomposition": [], "retrieval": ["indexr_skips", "indexr_splice_gt", "indexr_var_none", "indexr_var_some"], "remove_type": "abort"}, {"name": "indexr_splice1", "text": "Lemma indexr_splice1: forall{X} (H2' H2: list X) x y, indexr (if x <? length H2 then x else (S x)) (H2' ++ y :: H2) = indexr x (H2' ++ H2).", "decomposition": [], "retrieval": ["indexr_splice"], "remove_type": "abort"}, {"name": "indexr_shift", "text": "Lemma indexr_shift : forall{X} (H H': list X) x vx v, x > length H -> indexr x (H' ++ vx :: H) = Some v <-> indexr (pred x) (H' ++ H) = Some v.", "decomposition": [], "retrieval": ["indexr_insert_ge", "indexr_splice_gt"], "remove_type": "abort"}, {"name": "st_weaken", "text": "Lemma st_weaken: forall t1 e T1 G (W: has_type G t1 T1 e), forall M H1 H2 H2' HX, env_type M H1 (H2'++H2) G -> exp_type_eff M H1 (H2'++HX++H2) t1 (splice_tm t1 (length H2) (length HX)) T1 e.", "decomposition": ["exp_app_pure", "exp_sub_fun_eff", "exp_sub_eff", "exp_put", "exp_get", "exp_abs_pure", "exp_ref"], "retrieval": ["exp_true", "indexr_splice", "exp_var", "exp_app", "envt_store_extend", "envt_extend", "exp_false", "exp_abs"], "remove_type": "abort"}, {"name": "tevaln_unique", "text": "Lemma tevaln_unique: forall S1 S1' S1'' H1 e1 v1 v1', tevaln S1 H1 e1 S1' v1 -> tevaln S1 H1 e1 S1'' v1' -> S1' = S1'' /\\ v1 = v1'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "st_weaken1", "text": "Lemma st_weaken1: forall t1 T1 G (W: has_type G t1 T1 false), forall M H1 H2 H2', env_type M H1 (H2'++H2) G -> exists S1' v1, (forall S1, tevaln S1 H1 t1 (S1'++S1) v1) /\\ forall HX, exists S2' v2, (forall S2, tevaln S2 (H2'++HX++H2) (splice_tm t1 (length H2) (length HX)) (S2'++S2) v2) /\\ val_type M v1 v2 T1.", "decomposition": [], "retrieval": ["fundamental", "st_weaken", "tevaln_unique"], "remove_type": "abort"}, {"name": "st_subst", "text": "Lemma st_subst: forall t2 e T2 G0 (W: has_type G0 t2 T2 e), forall G' G T1, G0 = G'++T1::G -> forall M H1 H1' H2 H2' t1 v1, env_type M (H1'++H1) (H2'++H2) (G'++G) -> length H1 = length G -> length H2 = length G -> (* (forall S1, tevaln S1 H1 t1 S1 v1) -> *) (forall H2', exists S2' v2, (* via st_weaken *) (forall S2, tevaln S2 (H2'++H2) (splice_tm t1 (length H2) (length H2')) (S2'++S2) v2) /\\ val_type M v1 v2 T1) -> exp_type_eff M (H1'++v1::H1) (H2'++H2) t2 (subst_tm t2 (length H2) (splice_tm t1 (length H2) (length H2'))) T2 e.", "decomposition": ["storet_pad", "exp_sub_fun_eff", "exp_sub_eff", "sttyw_pad", "stchain_pad", "exp_abs_pure", "exp_ref", "exp_get", "exp_app_pure", "exp_put"], "retrieval": ["envt_store_extend", "exp_false", "envt_extend", "exp_true", "exp_var", "valt_store_extend", "splice_acc", "indexr_insert", "indexr_insert_lt", "indexr_insert_ge", "exp_app", "exp_abs"], "remove_type": "abort"}, {"name": "st_subst1", "text": "Lemma st_subst1 : forall M t1 t2 G T1 T2 H1 H2 v1 e, has_type (T1::G) t2 T2 e -> env_type M H1 H2 G -> (forall H2', exists S2' v2, (* via st_weaken *) (forall S2, tevaln S2 (H2'++H2) (splice_tm t1 (length H2) (length H2')) (S2'++S2) v2) /\\ val_type M v1 v2 T1) -> exp_type_eff M (v1::H1) H2 t2 (subst_tm t2 (length H2) (splice_tm t1 (length H2) 0)) T2 e.", "decomposition": [], "retrieval": ["st_subst"], "remove_type": "abort"}, {"name": "beta_equivalence", "text": "Lemma beta_equivalence: forall t1 t2 G T1 T2 e, has_type (T1::G) t2 T2 e -> has_type G t1 T1 false -> sem_type_eff G (tapp (tabs t2) t1) (subst_tm t2 (length G) t1) T2 e.", "decomposition": ["storet_pad", "sttyw_pad", "stchain_pad'", "stchain_pad"], "retrieval": ["fundamental", "st_subst1", "st_weaken1", "envt_store_extend", "splice_zero", "valt_store_extend"], "remove_type": "abort"}]}, "3a2828fa81eb652eb4b36eb156610f192104a71d": {"pub/stlc_equiv_beta.v": [{"name": "envt_empty", "text": "Lemma envt_empty: env_type [] [] [].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "envt_extend", "text": "Lemma envt_extend: forall E1 E2 G v1 v2 T, env_type E1 E2 G -> val_type v1 v2 T -> env_type (v1::E1) (v2::E2) (T::G).", "decomposition": [], "retrieval": ["indexr_skip", "indexr_head"], "remove_type": "abort"}, {"name": "exp_true", "text": "Lemma exp_true: forall H1 H2, exp_type H1 H2 ttrue ttrue TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_false", "text": "Lemma exp_false: forall H1 H2, exp_type H1 H2 tfalse tfalse TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_var", "text": "Lemma exp_var: forall H1 H2 x1 x2 v1 v2 T, indexr x1 H1 = Some v1 -> indexr x2 H2 = Some v2 -> val_type v1 v2 T -> exp_type H1 H2 (tvar x1) (tvar x2) T.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_app", "text": "Lemma exp_app: forall H1 H2 f1 f2 t1 t2 T1 T2, exp_type H1 H2 f1 f2 (TFun T1 T2) -> exp_type H1 H2 t1 t2 T1 -> exp_type H1 H2 (tapp f1 t1) (tapp f2 t2) T2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "exp_abs", "text": "Lemma exp_abs: forall H1 H2 t1 t2 T1 T2, (forall vx1 vx2, val_type vx1 vx2 T1 -> exp_type (vx1 :: H1) (vx2 :: H2) t1 t2 T2) -> exp_type H1 H2 (tabs t1) (tabs t2) (TFun T1 T2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_true", "text": "Lemma sem_true: forall G, sem_type G ttrue ttrue TBool.", "decomposition": ["exp_true"], "retrieval": [], "remove_type": "abort"}, {"name": "sem_false", "text": "Lemma sem_false: forall G, sem_type G tfalse tfalse TBool.", "decomposition": ["exp_false"], "retrieval": [], "remove_type": "abort"}, {"name": "sem_var", "text": "Lemma sem_var: forall G x T, indexr x G = Some T -> sem_type G (tvar x) (tvar x) T.", "decomposition": ["exp_var"], "retrieval": [], "remove_type": "abort"}, {"name": "sem_app", "text": "Lemma sem_app: forall G f1 f2 t1 t2 T1 T2, sem_type G f1 f2 (TFun T1 T2) -> sem_type G t1 t2 T1 -> sem_type G (tapp f1 t1) (tapp f2 t2) T2.", "decomposition": ["exp_app"], "retrieval": [], "remove_type": "abort"}, {"name": "sem_abs", "text": "Lemma sem_abs: forall G t1 t2 T1 T2, sem_type (T1::G) t1 t2 T2 -> sem_type G (tabs t1) (tabs t2) (TFun T1 T2).", "decomposition": ["exp_abs"], "retrieval": ["envt_extend"], "remove_type": "abort"}, {"name": "fundamental", "text": "Theorem fundamental : forall e G T, has_type G e T -> sem_type G e e T.", "decomposition": [], "retrieval": ["sem_app", "sem_true", "sem_false", "sem_var", "sem_abs"], "remove_type": "abort"}, {"name": "safety", "text": "Corollary safety: forall t T, has_type [] t T -> exp_type [] [] t t T.", "decomposition": [], "retrieval": ["fundamental", "envt_empty"], "remove_type": "abort"}, {"name": "congr", "text": "Theorem congr: forall C G1 T1 G2 T2, ctx_type C G1 T1 G2 T2 -> forall e e', sem_type G1 e e' T1 -> sem_type G2 (C e) (C e') T2.", "decomposition": [], "retrieval": ["sem_app", "fundamental", "sem_abs"], "remove_type": "abort"}, {"name": "adequacy", "text": "Lemma adequacy: forall e e' T, sem_type [] e e' T -> (exists v, tevaln [] e v) <-> (exists v', tevaln [] e' v').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "soundess", "text": "Theorem soundess: forall G t1 t2 T, sem_type G t1 t2 T -> context_equiv G t1 t2 T.", "decomposition": [], "retrieval": ["adequacy"], "remove_type": "abort"}, {"name": "splice_acc", "text": "Lemma splice_acc: forall e1 a b c, splice_tm (splice_tm e1 a b) a c = splice_tm e1 a (c+b).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "splice_zero", "text": "Lemma splice_zero: forall e1 a, (splice_tm e1 a 0) = e1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "indexr_splice_gt", "text": "Lemma indexr_splice_gt: forall{X} x (G1 G3: list X) T , indexr x (G3 ++ G1) = Some T -> x >= length G1 -> forall G2, indexr (x + (length G2))(G3 ++ G2 ++ G1) = Some T.", "decomposition": [], "retrieval": ["indexr_var_some'"], "remove_type": "abort"}, {"name": "indexr_splice", "text": "Lemma indexr_splice: forall{X} (H2' H2 HX: list X) x, indexr (if x <? length H2 then x else x + length HX) (H2' ++ HX ++ H2) = indexr x (H2' ++ H2).", "decomposition": ["indexr_splice_gt"], "retrieval": ["indexr_skips", "indexr_var_none", "indexr_var_some"], "remove_type": "abort"}, {"name": "indexr_splice1", "text": "Lemma indexr_splice1: forall{X} (H2' H2: list X) x y, indexr (if x <? length H2 then x else (S x)) (H2' ++ y :: H2) = indexr x (H2' ++ H2).", "decomposition": ["indexr_splice"], "retrieval": [], "remove_type": "abort"}, {"name": "indexr_shift", "text": "Lemma indexr_shift : forall{X} (H H': list X) x vx v, x > length H -> indexr x (H' ++ vx :: H) = Some v <-> indexr (pred x) (H' ++ H) = Some v.", "decomposition": ["indexr_splice_gt"], "retrieval": ["indexr_insert_ge"], "remove_type": "abort"}, {"name": "st_weaken", "text": "Lemma st_weaken: forall e1 T1 G (W: has_type G e1 T1), forall H1 H2 H2' HX, env_type H1 (H2'++H2) G -> exp_type H1 (H2'++HX++H2) e1 (splice_tm e1 (length H2) (length HX)) T1.", "decomposition": ["indexr_splice", "exp_true", "exp_var", "exp_app", "exp_false", "exp_abs"], "retrieval": ["envt_extend"], "remove_type": "abort"}, {"name": "tevaln_unique", "text": "Lemma tevaln_unique: forall H1 e1 v1 v1', tevaln H1 e1 v1 -> tevaln H1 e1 v1' -> v1 = v1'.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "st_weaken1", "text": "Lemma st_weaken1: forall e1 T1 G (W: has_type G e1 T1), forall H1 H2 H2', env_type H1 (H2'++H2) G -> exists v1, tevaln H1 e1 v1 /\\ forall HX, exists v2, tevaln (H2'++HX++H2) (splice_tm e1 (length H2) (length HX)) v2 /\\ val_type v1 v2 T1.", "decomposition": ["st_weaken", "tevaln_unique"], "retrieval": ["fundamental"], "remove_type": "abort"}, {"name": "st_subst", "text": "Lemma st_subst : forall e2 T2 G0 (W: has_type G0 e2 T2), forall G' G T1, G0 = G'++T1::G -> forall H1 H1' H2 H2' e1 v1, env_type (H1'++H1) (H2'++H2) (G'++G) -> length H1 = length G -> length H2 = length G -> tevaln H1 e1 v1 -> (forall H2', exists v2, (* via st_weaken *) tevaln (H2'++H2) (splice_tm e1 (length H2) (length H2')) v2 /\\ val_type v1 v2 T1) -> exp_type (H1'++v1::H1) (H2'++H2) e2 (subst_tm e2 (length H2) (splice_tm e1 (length H2) (length H2'))) T2.", "decomposition": ["exp_true", "exp_app", "exp_var", "exp_false", "exp_abs", "splice_acc"], "retrieval": ["indexr_insert_ge", "indexr_insert_lt", "indexr_insert", "envt_extend"], "remove_type": "abort"}, {"name": "st_subst1", "text": "Lemma st_subst1 : forall e1 e2 G T1 T2 H1 H2 v1, has_type (T1::G) e2 T2 -> env_type H1 H2 G -> tevaln H1 e1 v1 -> (forall H2', exists v2, (* via st_weaken *) tevaln (H2'++H2) (splice_tm e1 (length H2) (length H2')) v2 /\\ val_type v1 v2 T1) -> exp_type (v1::H1) H2 e2 (subst_tm e2 (length H2) (splice_tm e1 (length H2) 0)) T2.", "decomposition": ["st_subst"], "retrieval": [], "remove_type": "abort"}, {"name": "beta_equivalence", "text": "Lemma beta_equivalence: forall e1 e2 G T1 T2, has_type (T1::G) e2 T2 -> has_type G e1 T1 -> sem_type G (tapp (tabs e2) e1) (subst_tm e2 (length G) e1) T2.", "decomposition": ["splice_zero", "st_subst1", "st_weaken1"], "retrieval": ["fundamental"], "remove_type": "abort"}]}, "8818bd6e622cb13902f6221cf18e0b21bc255ae6": {"pub/stlc_rec_indexed_eff.v": [{"name": "eval_deterministic", "text": "Lemma eval_deterministic: forall m n, n < m -> forall H t n1 r j, teval n H t = (n1, Some r) -> j >= n -> (* alt: j >= n1 ? *) teval j H t = (n1, Some r).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "eval_bounded", "text": "Lemma eval_bounded: forall m n, n < m -> forall H t n1 r, teval n H t = (n1, Some r) -> 1 <= n1 /\\ n1 <= n.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "envt_empty", "text": "Lemma envt_empty: forall n, env_type n [] [].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "envt_extend", "text": "Lemma envt_extend: forall n E G v1 T1, env_type n E G -> val_type n v1 T1 -> env_type n (v1::E) (T1::G).", "decomposition": [], "retrieval": ["indexr_skip", "indexr_head"], "remove_type": "abort"}, {"name": "valt_dec", "text": "Lemma valt_dec: forall T1 n n1 v1, val_type n v1 T1 -> n1 <= n -> val_type n1 v1 T1.", "decomposition": [], "retrieval": ["eval_deterministic"], "remove_type": "abort"}, {"name": "envt_dec", "text": "Lemma envt_dec: forall n n1 H G, env_type n H G -> n1 <= n -> env_type n1 H G.", "decomposition": [], "retrieval": ["valt_dec"], "remove_type": "abort"}, {"name": "sem_true", "text": "Lemma sem_true: forall G, sem_type G ttrue TBool false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_false", "text": "Lemma sem_false: forall G, sem_type G tfalse TBool false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_var", "text": "Lemma sem_var: forall G x T, indexr x G = Some T -> sem_type G (tvar x) T false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_sub_eff", "text": "Lemma sem_sub_eff: forall G t T, sem_type G t T false -> sem_type G t T true.", "decomposition": [], "retrieval": ["eval_deterministic", "valt_dec"], "remove_type": "abort"}, {"name": "valt_fun_sub_eff", "text": "Lemma valt_fun_sub_eff: forall n v T1 T2, val_type n v (TFun T1 T2 false) -> val_type n v (TFun T1 T2 true).", "decomposition": [], "retrieval": ["eval_deterministic", "valt_dec"], "remove_type": "abort"}, {"name": "sem_sub_fun_eff", "text": "Lemma sem_sub_fun_eff: forall G t T1 T2, sem_type G t (TFun T1 T2 false) true -> sem_type G t (TFun T1 T2 true) true.", "decomposition": ["valt_fun_sub_eff"], "retrieval": [], "remove_type": "abort"}, {"name": "sem_app_pure", "text": "Lemma sem_app_pure: forall G f t T1 T2, sem_type G f (TFun T1 T2 false) false -> sem_type G t T1 false -> sem_type G (tapp f t) T2 false.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_app_impure", "text": "Lemma sem_app_impure: forall G f t T1 T2, sem_type G f (TFun T1 T2 true) true -> sem_type G t T1 true -> sem_type G (tapp f t) T2 true.", "decomposition": [], "retrieval": ["eval_deterministic", "valt_dec", "eval_bounded"], "remove_type": "abort"}, {"name": "sem_app", "text": "Lemma sem_app: forall G f t T1 T2 e1 e2 e3, sem_type G f (TFun T1 T2 e3) e1 -> sem_type G t T1 e2 -> sem_type G (tapp f t) T2 (e1 || e2 || e3).", "decomposition": ["sem_sub_fun_eff", "sem_app_pure", "sem_app_impure"], "retrieval": ["sem_sub_eff"], "remove_type": "abort"}, {"name": "sem_abs_impure", "text": "Lemma sem_abs_impure: forall G t T1 T2, sem_type (T1::(TFun T1 T2 true)::G) t T2 true -> sem_type G (tabs t) (TFun T1 T2 true) false.", "decomposition": [], "retrieval": ["envt_dec", "envt_extend", "valt_dec"], "remove_type": "abort"}, {"name": "sem_abs_pure", "text": "Lemma sem_abs_pure: forall G t T1 T2, sem_type (T1::(TFun T1 T2 true)::G) t T2 false -> sem_type G (tabs t) (TFun T1 T2 false) false.", "decomposition": ["sem_abs_impure"], "retrieval": ["sem_sub_eff", "envt_dec", "envt_extend", "valt_dec"], "remove_type": "abort"}, {"name": "sem_abs", "text": "Lemma sem_abs: forall G t T1 T2 e, sem_type (T1::(TFun T1 T2 true)::G) t T2 e -> sem_type G (tabs t) (TFun T1 T2 e) false.", "decomposition": ["sem_abs_pure", "sem_abs_impure"], "retrieval": [], "remove_type": "abort"}, {"name": "fundamental", "text": "Theorem fundamental: forall G t T e, has_type G t T e -> sem_type G t T e.", "decomposition": [], "retrieval": ["sem_app", "sem_true", "sem_sub_eff", "sem_false", "sem_var", "sem_abs"], "remove_type": "abort"}, {"name": "safety", "text": "Corollary safety: forall t T e, has_type [] t T e -> forall n, exp_type_impure n [] t T.", "decomposition": [], "retrieval": ["fundamental", "sem_sub_eff", "envt_empty"], "remove_type": "abort"}, {"name": "safety_termination", "text": "Corollary safety_termination: forall t T, has_type [] t T false -> exists v, tevaln [] t v.", "decomposition": [], "retrieval": ["fundamental", "envt_empty"], "remove_type": "abort"}]}, "04fb1d5d87b22a6a4db12c77085d97c281ce79d3": {"pub/stlc_ref_indexed.v": [{"name": "map_eq_f", "text": "Lemma map_eq_f: forall {A B} (f1 f2: A -> B) M, f1 = f2 -> map f1 M = map f2 M.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "vt_approx_comm", "text": "Lemma vt_approx_comm: forall n1 n2 vt, (vt_approx n1 (vt_approx n2 vt)) = (vt_approx n2 (vt_approx n1 vt)).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "vt_approx_neutral", "text": "Lemma vt_approx_neutral: forall n1 n2 vt, n1 <= n2 -> (vt_approx n1 (vt_approx n2 vt)) = (vt_approx n1 vt).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "stty_approx_neutral", "text": "Lemma stty_approx_neutral: forall n1 n2 M, n1 <= n2 -> (stty_approx n1 (stty_approx n2 M)) = (stty_approx n1 M).", "decomposition": ["vt_approx_neutral", "map_eq_f"], "retrieval": ["map_map"], "remove_type": "admit"}, {"name": "vtyp_approx_equiv", "text": "Lemma vtyp_approx_equiv: forall j (vt1 vt2: vtype), vt1 = vt2 -> vtyp_equiv j (vt1) (vt2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "vte_approx", "text": "Lemma vte_approx: forall n n1 vt M v, vtyp_elem_approx n vt M v -> n1 <= n -> vtyp_elem_approx n1 vt M v.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "stchain_approx''", "text": "Lemma stchain_approx'': forall n j nx M M', st_chain (S n) (S j) M M' -> st_chain (S n - nx) (S j - nx) (stty_approx (S (n - nx)) M) (stty_approx (S (j - nx)) M').", "decomposition": ["vt_approx_neutral"], "retrieval": ["indexr_var_some", "indexr_map", "vtyp_equiv_dec", "indexr_var_some'"], "remove_type": "abort"}, {"name": "stchain_apprx", "text": "Lemma stchain_apprx: forall n j nx M M', isstoretypeD (S n) M -> isstoretypeD (S j) M' -> st_chain (S n) (S j) M M' -> st_chain (S n - nx) (S j - nx) (stty_apprx (n - nx) M) (stty_apprx (j - nx) M').", "decomposition": ["stchain_approx''"], "retrieval": [], "remove_type": "admit"}, {"name": "istc_valt", "text": "Lemma istc_valt: forall nu T, istypeC nu (vt_wrap1 (fun (n : nat) (M : stty) (v : vl) => val_type n M v T)).", "decomposition": [], "retrieval": ["aux_lt1", "sttyw_eq"], "remove_type": "admit"}, {"name": "istc_step'", "text": "Lemma istc_step': forall nu n vt, istypeC nu vt -> n <= nu -> istypeC n vt.", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "istc_approx", "text": "Lemma istc_approx: forall nu n vt, istypeC nu vt -> n <= nu -> istypeC n (vt_approx n vt).", "decomposition": [], "retrieval": [], "remove_type": "admit"}, {"name": "isstc_to_d", "text": "Lemma isstc_to_d: forall n1 M, isstoretypeC n1 M -> isstoretypeD n1 M.", "decomposition": [], "retrieval": ["indexr_skip", "indexr_head", "indexr_var_some'", "map_map"], "remove_type": "abort"}, {"name": "isstd_approx", "text": "Lemma isstd_approx: forall nu n M, isstoretypeD nu M -> n <= nu -> isstoretypeD n (stty_approx n M).", "decomposition": ["stty_approx_neutral", "map_eq_f"], "retrieval": ["map_map"], "remove_type": "abort"}, {"name": "storet_extend", "text": "Lemma storet_extend: forall n S M vx vt, store_type (n) S M -> istypeA vt -> istypeC n vt -> vtyp_elem_approx n vt (vt::M) vx -> store_type (n) (vx :: S) (vt :: M).", "decomposition": ["isstc_to_d", "isstd_approx"], "retrieval": ["indexr_skip", "stchain_extend'", "ista_approx", "indexr_head", "indexr_var_some'"], "remove_type": "admit"}, {"name": "storet_isstd", "text": "Lemma storet_isstd: forall n S M, store_type n S M -> isstoretypeD n M.", "decomposition": ["isstc_to_d"], "retrieval": [], "remove_type": "admit"}, {"name": "stchain_aux_ref'", "text": "Lemma stchain_aux_ref': forall n2 j nx0 M', isstoretypeD n2 M' -> S j < n2 -> st_chain n2 (S j - nx0) (stty_approx n2 M') (stty_apprx (j - nx0) (stty_approx (S j) (stty_approx n2 M'))).", "decomposition": ["stty_approx_neutral", "isstd_approx"], "retrieval": ["stchain_approx", "stchain_step''"], "remove_type": "abort"}, {"name": "stchain_aux_ref", "text": "Lemma stchain_aux_ref: forall n2 j nx0 M' vt, isstoretypeD n2 M' -> S j < n2 -> st_chain n2 (S j - nx0) (stty_approx n2 M') (stty_apprx (j - nx0) (stty_approx (S j) (vt :: (stty_approx n2 M')))).", "decomposition": ["stchain_aux_ref'"], "retrieval": ["stchain_extend'", "stchain_chain"], "remove_type": "admit"}, {"name": "stchain_aux_get", "text": "Lemma stchain_aux_get: forall nx1 M', isstoretypeD (S nx1) M' -> st_chain (S nx1) (S nx1) (stty_apprx (nx1 - 0) (stty_approx (S nx1) M')) (stty_approx (S nx1) M').", "decomposition": ["stty_approx_neutral", "isstd_approx"], "retrieval": ["stchain_refl"], "remove_type": "admit"}, {"name": "stchain_aux_put", "text": "Lemma stchain_aux_put: forall ny1 nx0 j M2, isstoretypeD (S ny1) M2 -> j < ny1 -> st_chain (Datatypes.S ny1) (Datatypes.S j - nx0) M2 (stty_apprx (j - nx0) (stty_approx (Datatypes.S j) M2)).", "decomposition": ["stty_approx_neutral", "isstd_approx"], "retrieval": ["stchain_approx", "stchain_step''"], "remove_type": "admit"}]}, "8a10245c40a54a9e09d5f31186471d584ff3c69c": {"pub/stlc.v": [{"name": "envt_empty", "text": "Lemma envt_empty: env_type [] [].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "envt_extend", "text": "Lemma envt_extend: forall E G v1 T1, env_type E G -> val_type v1 T1 -> env_type (v1::E) (T1::G).", "decomposition": [], "retrieval": ["indexr_skip", "indexr_head"], "remove_type": "abort"}, {"name": "sem_true", "text": "Lemma sem_true: forall G, sem_type G ttrue TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_false", "text": "Lemma sem_false: forall G, sem_type G tfalse TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_var", "text": "Lemma sem_var: forall G x T, indexr x G = Some T -> sem_type G (tvar x) T.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_app", "text": "Lemma sem_app: forall G f t T1 T2, sem_type G f (TFun T1 T2) -> sem_type G t T1 -> sem_type G (tapp f t) T2.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_abs", "text": "Lemma sem_abs: forall G t T1 T2, sem_type (T1::G) t T2 -> sem_type G (tabs t) (TFun T1 T2).", "decomposition": ["envt_extend"], "retrieval": [], "remove_type": "abort"}, {"name": "fundamental", "text": "Theorem fundamental: forall G t T, has_type G t T -> sem_type G t T.", "decomposition": ["sem_app", "sem_true", "sem_false", "sem_var", "sem_abs"], "retrieval": [], "remove_type": "abort"}, {"name": "safety", "text": "Corollary safety: forall t T, has_type [] t T -> exp_type [] t T.", "decomposition": ["fundamental", "envt_empty"], "retrieval": [], "remove_type": "abort"}], "pub/stlc_smallstep.v": [{"name": "closed_inc", "text": "Lemma closed_inc: forall t n n1, closedB t n -> n <= n1 -> closedB t n1.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "closed_open_id", "text": "Lemma closed_open_id: forall t t2 n, closedB t n -> open t n t2 = t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "closed_open_id'", "text": "Lemma closed_open_id': forall t t2 n n1, closedB t n -> n <= n1 -> open t n1 t2 = t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "open_closed", "text": "Lemma open_closed: forall t n m, closedB t (S m) -> closedB (open t m (tvar n)) m.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "open_closed'", "text": "Lemma open_closed': forall t n m, closedB (open t m (tvar n)) m -> closedB t (S m).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "subst_open_commute", "text": "Lemma subst_open_commute: forall t t1 E n, closed t (length E) -> (forall x t1, indexr x E = Some t1 -> closedB t1 0) -> subst (t1 :: E) (open t n (tvar (length E))) = (open (subst E t) n t1).", "decomposition": ["closed_open_id", "closed_inc"], "retrieval": ["indexr_var_some"], "remove_type": "abort"}, {"name": "subst_closed_commute", "text": "Lemma subst_closed_commute: forall t E n, (forall x t1, indexr x E = Some t1 -> closedB t1 0) -> (closedB t n) -> (closedB (subst E t) n).", "decomposition": ["closed_inc"], "retrieval": [], "remove_type": "abort"}, {"name": "subst_empty", "text": "Lemma subst_empty: forall t, subst [] t = t.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stepn_app_l", "text": "Lemma stepn_app_l : forall t1 t1' t2, stepn t1 t1' -> stepn (tapp t1 t2) (tapp t1' t2).", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stepn_app_r", "text": "Lemma stepn_app_r : forall t1 t2 t2', stepn t2 t2' -> stepn (tapp t1 t2) (tapp t1 t2').", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "stepn_trans", "text": "Lemma stepn_trans : forall t1 t2 t3, stepn t1 t2 -> stepn t2 t3 -> stepn t1 t3.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "envt_closed", "text": "Lemma envt_closed: forall E G, env_type E G -> forall x t1, indexr x E = Some t1 -> closedB t1 0.", "decomposition": [], "retrieval": ["indexr_var_some"], "remove_type": "abort"}, {"name": "envt_extend", "text": "Lemma envt_extend: forall E G t1 v1 T1, env_type E G -> closedB t1 0 -> stepn t1 v1 -> val_type v1 T1 -> env_type (t1::E) (T1::G).", "decomposition": [], "retrieval": ["indexr_skip", "indexr_head"], "remove_type": "abort"}, {"name": "sem_true", "text": "Lemma sem_true: forall G, sem_type G ttrue TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_false", "text": "Lemma sem_false: forall G, sem_type G tfalse TBool.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_var", "text": "Lemma sem_var: forall G x T, indexr x G = Some T -> sem_type G (tvar x) T.", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "sem_app", "text": "Lemma sem_app: forall G f t T1 T2, sem_type G f (TFun T1 T2) -> sem_type G t T1 -> sem_type G (tapp f t) T2.", "decomposition": ["envt_closed", "stepn_app_l", "stepn_trans", "subst_closed_commute"], "retrieval": [], "remove_type": "abort"}, {"name": "sem_abs", "text": "Lemma sem_abs: forall G t T1 T2, sem_type (T1::G) (open t 0 (tvar (length G))) T2 -> closed t (length G) -> sem_type G (tabs t) (TFun T1 T2).", "decomposition": ["subst_open_commute", "envt_closed", "envt_extend", "open_closed"], "retrieval": [], "remove_type": "abort"}, {"name": "fundamental", "text": "Theorem fundamental: forall G t T, has_type G t T -> sem_type G t T.", "decomposition": ["sem_app", "sem_true", "sem_false", "sem_var", "sem_abs"], "retrieval": [], "remove_type": "abort"}, {"name": "hast_closed", "text": "Lemma hast_closed: forall G t T, has_type G t T -> closedB t 0.", "decomposition": ["open_closed'"], "retrieval": [], "remove_type": "abort"}, {"name": "envt_empty", "text": "Lemma envt_empty: env_type [] [].", "decomposition": [], "retrieval": [], "remove_type": "abort"}, {"name": "safety", "text": "Corollary safety: forall t T, has_type [] t T -> exp_type t T.", "decomposition": ["subst_empty", "fundamental", "envt_empty", "hast_closed"], "retrieval": [], "remove_type": "abort"}]}}